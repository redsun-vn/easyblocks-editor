"use client";
import * as React from 'react';
import React__default, { useContext, useRef, useCallback, useEffect, useState, useLayoutEffect, createContext, useMemo, Fragment, forwardRef, memo } from 'react';
import { Colors, Fonts, ButtonSecondary, ButtonPrimary, Toggle as Toggle$1, Select, SelectSeparator, SelectItem, SelectInline, Icons, ToggleButton, Input, Loader, Typography, ButtonGhost, ThumbnailButton, RangeSlider, ToggleGroup, Tooltip as Tooltip$1, TooltipTrigger, ToggleGroupItem, TooltipContent, useToaster, Modal, FormElement, ButtonDanger, ButtonGhostColor, BasicRow, ModalContext, GlobalModalStyles, TooltipProvider, Toaster } from '@redsun-vn/easyblocks-design-system';
import isPropValid from '@emotion/is-prop-valid';
import styled, { css, keyframes, createGlobalStyle, StyleSheetManager } from 'styled-components';
import _extends from '@babel/runtime/helpers/extends';
import { getExternalReferenceLocationKey as getExternalReferenceLocationKey$1, isTrulyResponsiveValue as isTrulyResponsiveValue$2, responsiveValueFindDeviceWithDefinedValue as responsiveValueFindDeviceWithDefinedValue$1, responsiveValueForceGet as responsiveValueForceGet$2, isEmptyExternalReference, isIdReferenceToDocumentExternalValue, responsiveValueGetDefinedValue as responsiveValueGetDefinedValue$1, getDevicesWidths as getDevicesWidths$1, responsiveValueFill as responsiveValueFill$1, resolveExternalValue as resolveExternalValue$1, resolveLocalisedValue as resolveLocalisedValue$2, isResolvedCompoundExternalDataValue, getFallbackLocaleForLocale as getFallbackLocaleForLocale$1, isNoCodeComponentOfType, getDefaultLocale as getDefaultLocale$1, buildRichTextNoCodeEntry as buildRichTextNoCodeEntry$1, createCompilationContext, normalize as normalize$1, CompilationCache, buildEntry, findExternals, validate as validate$1, normalizeInput, compileInternal, mergeCompilationMeta, responsiveValueGet as responsiveValueGet$1, Easyblocks } from '@redsun-vn/easyblocks-core';
import throttle$1 from 'lodash.throttle';
import Modal$1 from 'react-modal';
import ReactDOM, { flushSync, createPortal } from 'react-dom';
import { useTooltipTrigger } from '@react-aria/tooltip';
import { usePopper } from 'react-popper';
import * as RadixRadioGroup from '@radix-ui/react-radio-group';
import { z as z$2 } from 'zod';
import debounce from 'lodash/debounce';
import { createForm as createForm$1, FORM_ERROR } from 'final-form';
import arrayMutators from 'final-form-arrays';
import { useDndContext, useSensor, MouseSensor, DndContext, pointerWithin, rectIntersection } from '@dnd-kit/core';
import { useSortable, horizontalListSortingStrategy, verticalListSortingStrategy, SortableContext } from '@dnd-kit/sortable';
import throttle from 'lodash/throttle';
import _extends$1 from '@babel/runtime/helpers/esm/extends';
import _objectWithoutPropertiesLoose$2 from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';

const EditorContext$1 = /*#__PURE__*/React__default.createContext(null);
function useEditorContext() {
  const context = useContext(EditorContext$1);
  if (!context) {
    throw new Error("EditorContext not defined");
  }
  return context;
}

/* with love from shopstory */
/**
 * This function is necessary because if we have Stitches styles object, its breakpoint values should be only on the top level.
 * We can have them nested so we need to transform styles object so that responsive styles goes to the top level.
 */

function flattenResponsiveStyles(styles) {
  const result = {};
  for (const key in styles) {
    const value = styles[key];
    if (key.startsWith("@")) {
      if (!result[key]) {
        result[key] = {};
      }
      result[key] = {
        ...result[key],
        ...value
      };
      continue;
    }
    if (typeof value === "object" && value !== null) {
      const flattenedValue = flattenResponsiveStyles(value);

      // MERGE

      const nonResponsiveValues = {};
      const responsiveValues = {};
      for (const key2 in flattenedValue) {
        const value2 = flattenedValue[key2];
        if (key2.startsWith("@")) {
          responsiveValues[key2] = value2;
        } else {
          nonResponsiveValues[key2] = value2;
        }
      }
      result[key] = nonResponsiveValues;
      for (const breakpoint in responsiveValues) {
        if (!result[breakpoint]) {
          result[breakpoint] = {};
        }
        result[breakpoint] = {
          ...result[breakpoint],
          [key]: responsiveValues[breakpoint]
        };
      }
    } else {
      result[key] = value;
    }
  }
  return result;
}

/* with love from shopstory */

function compileBox(input, devices) {
  if (typeof input === "object" && input.$res) {
    const ret = {};
    for (const key in input) {
      if (key !== "$res") {
        ret["@" + key] = input[key];
      }
    }
    return ret;
  } else if (typeof input === "object" && input !== null) {
    const ret = {};

    /**
     * FIXME: there's a bug here!!!
     *
     * I don't know what to do about it. We add items in a correct order to the ret object, and JS should keep this order
     * but it clearly doesn't work and order gets broken. This breaks where "unset" is set in CSS and hence, inheritance is broken.
     *
     * This can be fixed by adding "specific media queries" (from - to) here. It's gonna work.
     */

    for (const key in input) {
      const val = input[key];
      if (typeof val === "object" && val.$res === true) {
        // const maxBreakpoint = responsiveValueGetMaxDefinedBreakpoint(val, devices);

        let isFirst = true;
        for (let i = devices.length - 1; i >= 0; i--) {
          const breakpoint = devices[i].id;
          if (val[breakpoint] === null || val[breakpoint] === undefined) {
            continue;
          }
          if (isFirst) {
            ret[key] = val[breakpoint];
            isFirst = false;
          } else {
            if (!ret["@" + breakpoint]) {
              ret["@" + breakpoint] = {};
            }
            ret["@" + breakpoint][key] = val[breakpoint];
          }
        }
        continue;
      }
      ret[key] = compileBox(val, devices);
    }
    return ret;
  }
  return input;
}
function getBoxStyles(styles, devices) {
  const flattenStyles = flattenResponsiveStyles(styles);
  const ret = {};

  // First copy all the non-responsive values
  for (const key in flattenStyles) {
    if (!key.startsWith("@") && key !== "__isBox" && key !== "__hash") {
      ret[key] = flattenStyles[key];
    }
  }

  // now copy breakpoint values in correct order
  for (let i = devices.length - 1; i >= 0; i--) {
    const device = devices[i];
    const breakpoint = device.id;

    // correct order!
    if (flattenStyles["@" + breakpoint]) {
      const resolvedKey = resolveDeviceIdToMediaQuery(device);
      ret[resolvedKey] = flattenStyles["@" + breakpoint];
    }
  }
  return ret;
}
function resolveDeviceIdToMediaQuery(device) {
  return `@media (max-width: ${device.breakpoint - 1}px)`;
}

/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

function isObject(o) {
  return Object.prototype.toString.call(o) === '[object Object]';
}

function isPlainObject(o) {
  var ctor,prot;

  if (isObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (ctor === undefined) return true;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
}

function n$3(n){for(var r=arguments.length,t=Array(r>1?r-1:0),e=1;e<r;e++)t[e-1]=arguments[e];if("production"!==process.env.NODE_ENV){var i=Y[n],o=i?"function"==typeof i?i.apply(null,t):i:"unknown error nr: "+n;throw Error("[Immer] "+o)}throw Error("[Immer] minified error nr: "+n+(t.length?" "+t.map((function(n){return "'"+n+"'"})).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function r$2(n){return !!n&&!!n[Q]}function t$2(n){var r;return !!n&&(function(n){if(!n||"object"!=typeof n)return !1;var r=Object.getPrototypeOf(n);if(null===r)return !0;var t=Object.hasOwnProperty.call(r,"constructor")&&r.constructor;return t===Object||"function"==typeof t&&Function.toString.call(t)===Z$1}(n)||Array.isArray(n)||!!n[L$1]||!!(null===(r=n.constructor)||void 0===r?void 0:r[L$1])||s$1(n)||v$1(n))}function i$2(n,r,t){void 0===t&&(t=!1),0===o$1(n)?(t?Object.keys:nn)(n).forEach((function(e){t&&"symbol"==typeof e||r(e,n[e],n);})):n.forEach((function(t,e){return r(e,t,n)}));}function o$1(n){var r=n[Q];return r?r.i>3?r.i-4:r.i:Array.isArray(n)?1:s$1(n)?2:v$1(n)?3:0}function u$1(n,r){return 2===o$1(n)?n.has(r):Object.prototype.hasOwnProperty.call(n,r)}function a$1(n,r){return 2===o$1(n)?n.get(r):n[r]}function f$2(n,r,t){var e=o$1(n);2===e?n.set(r,t):3===e?n.add(t):n[r]=t;}function c$1(n,r){return n===r?0!==n||1/n==1/r:n!=n&&r!=r}function s$1(n){return X$1&&n instanceof Map}function v$1(n){return q&&n instanceof Set}function p$1(n){return n.o||n.t}function l$1(n){if(Array.isArray(n))return Array.prototype.slice.call(n);var r=rn(n);delete r[Q];for(var t=nn(r),e=0;e<t.length;e++){var i=t[e],o=r[i];!1===o.writable&&(o.writable=!0,o.configurable=!0),(o.get||o.set)&&(r[i]={configurable:!0,writable:!0,enumerable:o.enumerable,value:n[i]});}return Object.create(Object.getPrototypeOf(n),r)}function d$1(n,e){return void 0===e&&(e=!1),y$1(n)||r$2(n)||!t$2(n)||(o$1(n)>1&&(n.set=n.add=n.clear=n.delete=h$1),Object.freeze(n),e&&i$2(n,(function(n,r){return d$1(r,!0)}),!0)),n}function h$1(){n$3(2);}function y$1(n){return null==n||"object"!=typeof n||Object.isFrozen(n)}function b$1(r){var t=tn[r];return t||n$3(18,r),t}function _(){return "production"===process.env.NODE_ENV||U$1||n$3(0),U$1}function j$1(n,r){r&&(b$1("Patches"),n.u=[],n.s=[],n.v=r);}function g$1(n){O$1(n),n.p.forEach(S$1),n.p=null;}function O$1(n){n===U$1&&(U$1=n.l);}function w$1(n){return U$1={p:[],l:U$1,h:n,m:!0,_:0}}function S$1(n){var r=n[Q];0===r.i||1===r.i?r.j():r.g=!0;}function P$1(r,e){e._=e.p.length;var i=e.p[0],o=void 0!==r&&r!==i;return e.h.O||b$1("ES5").S(e,r,o),o?(i[Q].P&&(g$1(e),n$3(4)),t$2(r)&&(r=M$1(e,r),e.l||x$1(e,r)),e.u&&b$1("Patches").M(i[Q].t,r,e.u,e.s)):r=M$1(e,i,[]),g$1(e),e.u&&e.v(e.u,e.s),r!==H$1?r:void 0}function M$1(n,r,t){if(y$1(r))return r;var e=r[Q];if(!e)return i$2(r,(function(i,o){return A$1(n,e,r,i,o,t)}),!0),r;if(e.A!==n)return r;if(!e.P)return x$1(n,e.t,!0),e.t;if(!e.I){e.I=!0,e.A._--;var o=4===e.i||5===e.i?e.o=l$1(e.k):e.o,u=o,a=!1;3===e.i&&(u=new Set(o),o.clear(),a=!0),i$2(u,(function(r,i){return A$1(n,e,o,r,i,t,a)})),x$1(n,o,!1),t&&n.u&&b$1("Patches").N(e,t,n.u,n.s);}return e.o}function A$1(e,i,o,a,c,s,v){if("production"!==process.env.NODE_ENV&&c===o&&n$3(5),r$2(c)){var p=M$1(e,c,s&&i&&3!==i.i&&!u$1(i.R,a)?s.concat(a):void 0);if(f$2(o,a,p),!r$2(p))return;e.m=!1;}else v&&o.add(c);if(t$2(c)&&!y$1(c)){if(!e.h.D&&e._<1)return;M$1(e,c),i&&i.A.l||x$1(e,c);}}function x$1(n,r,t){void 0===t&&(t=!1),!n.l&&n.h.D&&n.m&&d$1(r,t);}function z$1(n,r){var t=n[Q];return (t?p$1(t):n)[r]}function I$1(n,r){if(r in n)for(var t=Object.getPrototypeOf(n);t;){var e=Object.getOwnPropertyDescriptor(t,r);if(e)return e;t=Object.getPrototypeOf(t);}}function k$1(n){n.P||(n.P=!0,n.l&&k$1(n.l));}function E$1(n){n.o||(n.o=l$1(n.t));}function N$1(n,r,t){var e=s$1(r)?b$1("MapSet").F(r,t):v$1(r)?b$1("MapSet").T(r,t):n.O?function(n,r){var t=Array.isArray(n),e={i:t?1:0,A:r?r.A:_(),P:!1,I:!1,R:{},l:r,t:n,k:null,o:null,j:null,C:!1},i=e,o=en;t&&(i=[e],o=on);var u=Proxy.revocable(i,o),a=u.revoke,f=u.proxy;return e.k=f,e.j=a,f}(r,t):b$1("ES5").J(r,t);return (t?t.A:_()).p.push(e),e}function R$1(e){return r$2(e)||n$3(22,e),function n(r){if(!t$2(r))return r;var e,u=r[Q],c=o$1(r);if(u){if(!u.P&&(u.i<4||!b$1("ES5").K(u)))return u.t;u.I=!0,e=D$1(r,c),u.I=!1;}else e=D$1(r,c);return i$2(e,(function(r,t){u&&a$1(u.t,r)===t||f$2(e,r,n(t));})),3===c?new Set(e):e}(e)}function D$1(n,r){switch(r){case 2:return new Map(n);case 3:return Array.from(n)}return l$1(n)}var G$1,U$1,W$1="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),X$1="undefined"!=typeof Map,q="undefined"!=typeof Set,B$1="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,H$1=W$1?Symbol.for("immer-nothing"):((G$1={})["immer-nothing"]=!0,G$1),L$1=W$1?Symbol.for("immer-draftable"):"__$immer_draftable",Q=W$1?Symbol.for("immer-state"):"__$immer_state",Y={0:"Illegal state",1:"Immer drafts cannot have computed properties",2:"This object has been frozen and should not be mutated",3:function(n){return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? "+n},4:"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",5:"Immer forbids circular references",6:"The first or second argument to `produce` must be a function",7:"The third argument to `produce` must be a function or undefined",8:"First argument to `createDraft` must be a plain object, an array, or an immerable object",9:"First argument to `finishDraft` must be a draft returned by `createDraft`",10:"The given draft is already finalized",11:"Object.defineProperty() cannot be used on an Immer draft",12:"Object.setPrototypeOf() cannot be used on an Immer draft",13:"Immer only supports deleting array indices",14:"Immer only supports setting array indices and the 'length' property",15:function(n){return "Cannot apply patch, path doesn't resolve: "+n},16:'Sets cannot have "replace" patches.',17:function(n){return "Unsupported patch operation: "+n},18:function(n){return "The plugin for '"+n+"' has not been loaded into Immer. To enable the plugin, import and call `enable"+n+"()` when initializing your application."},20:"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available",21:function(n){return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '"+n+"'"},22:function(n){return "'current' expects a draft, got: "+n},23:function(n){return "'original' expects a draft, got: "+n},24:"Patching reserved attributes like __proto__, prototype and constructor is not allowed"},Z$1=""+Object.prototype.constructor,nn="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:Object.getOwnPropertyNames,rn=Object.getOwnPropertyDescriptors||function(n){var r={};return nn(n).forEach((function(t){r[t]=Object.getOwnPropertyDescriptor(n,t);})),r},tn={},en={get:function(n,r){if(r===Q)return n;var e=p$1(n);if(!u$1(e,r))return function(n,r,t){var e,i=I$1(r,t);return i?"value"in i?i.value:null===(e=i.get)||void 0===e?void 0:e.call(n.k):void 0}(n,e,r);var i=e[r];return n.I||!t$2(i)?i:i===z$1(n.t,r)?(E$1(n),n.o[r]=N$1(n.A.h,i,n)):i},has:function(n,r){return r in p$1(n)},ownKeys:function(n){return Reflect.ownKeys(p$1(n))},set:function(n,r,t){var e=I$1(p$1(n),r);if(null==e?void 0:e.set)return e.set.call(n.k,t),!0;if(!n.P){var i=z$1(p$1(n),r),o=null==i?void 0:i[Q];if(o&&o.t===t)return n.o[r]=t,n.R[r]=!1,!0;if(c$1(t,i)&&(void 0!==t||u$1(n.t,r)))return !0;E$1(n),k$1(n);}return n.o[r]===t&&(void 0!==t||r in n.o)||Number.isNaN(t)&&Number.isNaN(n.o[r])||(n.o[r]=t,n.R[r]=!0),!0},deleteProperty:function(n,r){return void 0!==z$1(n.t,r)||r in n.t?(n.R[r]=!1,E$1(n),k$1(n)):delete n.R[r],n.o&&delete n.o[r],!0},getOwnPropertyDescriptor:function(n,r){var t=p$1(n),e=Reflect.getOwnPropertyDescriptor(t,r);return e?{writable:!0,configurable:1!==n.i||"length"!==r,enumerable:e.enumerable,value:t[r]}:e},defineProperty:function(){n$3(11);},getPrototypeOf:function(n){return Object.getPrototypeOf(n.t)},setPrototypeOf:function(){n$3(12);}},on={};i$2(en,(function(n,r){on[n]=function(){return arguments[0]=arguments[0][0],r.apply(this,arguments)};})),on.deleteProperty=function(r,t){return "production"!==process.env.NODE_ENV&&isNaN(parseInt(t))&&n$3(13),on.set.call(this,r,t,void 0)},on.set=function(r,t,e){return "production"!==process.env.NODE_ENV&&"length"!==t&&isNaN(parseInt(t))&&n$3(14),en.set.call(this,r[0],t,e,r[0])};var un=function(){function e(r){var e=this;this.O=B$1,this.D=!0,this.produce=function(r,i,o){if("function"==typeof r&&"function"!=typeof i){var u=i;i=r;var a=e;return function(n){var r=this;void 0===n&&(n=u);for(var t=arguments.length,e=Array(t>1?t-1:0),o=1;o<t;o++)e[o-1]=arguments[o];return a.produce(n,(function(n){var t;return (t=i).call.apply(t,[r,n].concat(e))}))}}var f;if("function"!=typeof i&&n$3(6),void 0!==o&&"function"!=typeof o&&n$3(7),t$2(r)){var c=w$1(e),s=N$1(e,r,void 0),v=!0;try{f=i(s),v=!1;}finally{v?g$1(c):O$1(c);}return "undefined"!=typeof Promise&&f instanceof Promise?f.then((function(n){return j$1(c,o),P$1(n,c)}),(function(n){throw g$1(c),n})):(j$1(c,o),P$1(f,c))}if(!r||"object"!=typeof r){if(void 0===(f=i(r))&&(f=r),f===H$1&&(f=void 0),e.D&&d$1(f,!0),o){var p=[],l=[];b$1("Patches").M(r,f,p,l),o(p,l);}return f}n$3(21,r);},this.produceWithPatches=function(n,r){if("function"==typeof n)return function(r){for(var t=arguments.length,i=Array(t>1?t-1:0),o=1;o<t;o++)i[o-1]=arguments[o];return e.produceWithPatches(r,(function(r){return n.apply(void 0,[r].concat(i))}))};var t,i,o=e.produce(n,r,(function(n,r){t=n,i=r;}));return "undefined"!=typeof Promise&&o instanceof Promise?o.then((function(n){return [n,t,i]})):[o,t,i]},"boolean"==typeof(null==r?void 0:r.useProxies)&&this.setUseProxies(r.useProxies),"boolean"==typeof(null==r?void 0:r.autoFreeze)&&this.setAutoFreeze(r.autoFreeze);}var i=e.prototype;return i.createDraft=function(e){t$2(e)||n$3(8),r$2(e)&&(e=R$1(e));var i=w$1(this),o=N$1(this,e,void 0);return o[Q].C=!0,O$1(i),o},i.finishDraft=function(r,t){var e=r&&r[Q];"production"!==process.env.NODE_ENV&&(e&&e.C||n$3(9),e.I&&n$3(10));var i=e.A;return j$1(i,t),P$1(void 0,i)},i.setAutoFreeze=function(n){this.D=n;},i.setUseProxies=function(r){r&&!B$1&&n$3(20),this.O=r;},i.applyPatches=function(n,t){var e;for(e=t.length-1;e>=0;e--){var i=t[e];if(0===i.path.length&&"replace"===i.op){n=i.value;break}}e>-1&&(t=t.slice(e+1));var o=b$1("Patches").$;return r$2(n)?o(n,t):this.produce(n,(function(n){return o(n,t)}))},e}(),an=new un,fn=an.produce;an.produceWithPatches.bind(an);an.setAutoFreeze.bind(an);an.setUseProxies.bind(an);an.applyPatches.bind(an);var ln=an.createDraft.bind(an),dn=an.finishDraft.bind(an);

function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var DIRTY_PATHS = new WeakMap();
var DIRTY_PATH_KEYS = new WeakMap();
var FLUSHING = new WeakMap();
var NORMALIZING = new WeakMap();
var PATH_REFS = new WeakMap();
var POINT_REFS = new WeakMap();
var RANGE_REFS = new WeakMap();

function ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$9(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$9(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * Create a new Slate `Editor` object.
 */

var createEditor = () => {
  var editor = {
    children: [],
    operations: [],
    selection: null,
    marks: null,
    isInline: () => false,
    isVoid: () => false,
    onChange: () => {},
    apply: op => {
      for (var ref of Editor$1.pathRefs(editor)) {
        PathRef.transform(ref, op);
      }

      for (var _ref of Editor$1.pointRefs(editor)) {
        PointRef.transform(_ref, op);
      }

      for (var _ref2 of Editor$1.rangeRefs(editor)) {
        RangeRef.transform(_ref2, op);
      }

      var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];
      var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || new Set();
      var dirtyPaths;
      var dirtyPathKeys;

      var add = path => {
        if (path) {
          var key = path.join(',');

          if (!dirtyPathKeys.has(key)) {
            dirtyPathKeys.add(key);
            dirtyPaths.push(path);
          }
        }
      };

      if (Path.operationCanTransformPath(op)) {
        dirtyPaths = [];
        dirtyPathKeys = new Set();

        for (var path of oldDirtyPaths) {
          var newPath = Path.transform(path, op);
          add(newPath);
        }
      } else {
        dirtyPaths = oldDirtyPaths;
        dirtyPathKeys = oldDirtyPathKeys;
      }

      var newDirtyPaths = getDirtyPaths(op);

      for (var _path of newDirtyPaths) {
        add(_path);
      }

      DIRTY_PATHS.set(editor, dirtyPaths);
      DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);
      Transforms.transform(editor, op);
      editor.operations.push(op);
      Editor$1.normalize(editor); // Clear any formats applied to the cursor if the selection changes.

      if (op.type === 'set_selection') {
        editor.marks = null;
      }

      if (!FLUSHING.get(editor)) {
        FLUSHING.set(editor, true);
        Promise.resolve().then(() => {
          FLUSHING.set(editor, false);
          editor.onChange();
          editor.operations = [];
        });
      }
    },
    addMark: (key, value) => {
      var {
        selection
      } = editor;

      if (selection) {
        if (Range.isExpanded(selection)) {
          Transforms.setNodes(editor, {
            [key]: value
          }, {
            match: Text$1.isText,
            split: true
          });
        } else {
          var marks = _objectSpread$9(_objectSpread$9({}, Editor$1.marks(editor) || {}), {}, {
            [key]: value
          });

          editor.marks = marks;

          if (!FLUSHING.get(editor)) {
            editor.onChange();
          }
        }
      }
    },
    deleteBackward: unit => {
      var {
        selection
      } = editor;

      if (selection && Range.isCollapsed(selection)) {
        Transforms.delete(editor, {
          unit,
          reverse: true
        });
      }
    },
    deleteForward: unit => {
      var {
        selection
      } = editor;

      if (selection && Range.isCollapsed(selection)) {
        Transforms.delete(editor, {
          unit
        });
      }
    },
    deleteFragment: direction => {
      var {
        selection
      } = editor;

      if (selection && Range.isExpanded(selection)) {
        Transforms.delete(editor, {
          reverse: direction === 'backward'
        });
      }
    },
    getFragment: () => {
      var {
        selection
      } = editor;

      if (selection) {
        return Node.fragment(editor, selection);
      }

      return [];
    },
    insertBreak: () => {
      Transforms.splitNodes(editor, {
        always: true
      });
    },
    insertSoftBreak: () => {
      Transforms.splitNodes(editor, {
        always: true
      });
    },
    insertFragment: fragment => {
      Transforms.insertFragment(editor, fragment);
    },
    insertNode: node => {
      Transforms.insertNodes(editor, node);
    },
    insertText: text => {
      var {
        selection,
        marks
      } = editor;

      if (selection) {
        if (marks) {
          var node = _objectSpread$9({
            text
          }, marks);

          Transforms.insertNodes(editor, node);
        } else {
          Transforms.insertText(editor, text);
        }

        editor.marks = null;
      }
    },
    normalizeNode: entry => {
      var [node, path] = entry; // There are no core normalizations for text nodes.

      if (Text$1.isText(node)) {
        return;
      } // Ensure that block and inline nodes have at least one text child.


      if (Element$1.isElement(node) && node.children.length === 0) {
        var child = {
          text: ''
        };
        Transforms.insertNodes(editor, child, {
          at: path.concat(0),
          voids: true
        });
        return;
      } // Determine whether the node should have block or inline children.


      var shouldHaveInlines = Editor$1.isEditor(node) ? false : Element$1.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text$1.isText(node.children[0]) || editor.isInline(node.children[0])); // Since we'll be applying operations while iterating, keep track of an
      // index that accounts for any added/removed nodes.

      var n = 0;

      for (var i = 0; i < node.children.length; i++, n++) {
        var currentNode = Node.get(editor, path);
        if (Text$1.isText(currentNode)) continue;
        var _child = node.children[i];
        var prev = currentNode.children[n - 1];
        var isLast = i === node.children.length - 1;
        var isInlineOrText = Text$1.isText(_child) || Element$1.isElement(_child) && editor.isInline(_child); // Only allow block nodes in the top-level children and parent blocks
        // that only contain block nodes. Similarly, only allow inline nodes in
        // other inline nodes, or parent blocks that only contain inlines and
        // text.

        if (isInlineOrText !== shouldHaveInlines) {
          Transforms.removeNodes(editor, {
            at: path.concat(n),
            voids: true
          });
          n--;
        } else if (Element$1.isElement(_child)) {
          // Ensure that inline nodes are surrounded by text nodes.
          if (editor.isInline(_child)) {
            if (prev == null || !Text$1.isText(prev)) {
              var newChild = {
                text: ''
              };
              Transforms.insertNodes(editor, newChild, {
                at: path.concat(n),
                voids: true
              });
              n++;
            } else if (isLast) {
              var _newChild = {
                text: ''
              };
              Transforms.insertNodes(editor, _newChild, {
                at: path.concat(n + 1),
                voids: true
              });
              n++;
            }
          }
        } else {
          // Merge adjacent text nodes that are empty or match.
          if (prev != null && Text$1.isText(prev)) {
            if (Text$1.equals(_child, prev, {
              loose: true
            })) {
              Transforms.mergeNodes(editor, {
                at: path.concat(n),
                voids: true
              });
              n--;
            } else if (prev.text === '') {
              Transforms.removeNodes(editor, {
                at: path.concat(n - 1),
                voids: true
              });
              n--;
            } else if (_child.text === '') {
              Transforms.removeNodes(editor, {
                at: path.concat(n),
                voids: true
              });
              n--;
            }
          }
        }
      }
    },
    removeMark: key => {
      var {
        selection
      } = editor;

      if (selection) {
        if (Range.isExpanded(selection)) {
          Transforms.unsetNodes(editor, key, {
            match: Text$1.isText,
            split: true
          });
        } else {
          var marks = _objectSpread$9({}, Editor$1.marks(editor) || {});

          delete marks[key];
          editor.marks = marks;

          if (!FLUSHING.get(editor)) {
            editor.onChange();
          }
        }
      }
    }
  };
  return editor;
};
/**
 * Get the "dirty" paths generated from an operation.
 */

var getDirtyPaths = op => {
  switch (op.type) {
    case 'insert_text':
    case 'remove_text':
    case 'set_node':
      {
        var {
          path
        } = op;
        return Path.levels(path);
      }

    case 'insert_node':
      {
        var {
          node,
          path: _path2
        } = op;
        var levels = Path.levels(_path2);
        var descendants = Text$1.isText(node) ? [] : Array.from(Node.nodes(node), _ref3 => {
          var [, p] = _ref3;
          return _path2.concat(p);
        });
        return [...levels, ...descendants];
      }

    case 'merge_node':
      {
        var {
          path: _path3
        } = op;
        var ancestors = Path.ancestors(_path3);
        var previousPath = Path.previous(_path3);
        return [...ancestors, previousPath];
      }

    case 'move_node':
      {
        var {
          path: _path4,
          newPath
        } = op;

        if (Path.equals(_path4, newPath)) {
          return [];
        }

        var oldAncestors = [];
        var newAncestors = [];

        for (var ancestor of Path.ancestors(_path4)) {
          var p = Path.transform(ancestor, op);
          oldAncestors.push(p);
        }

        for (var _ancestor of Path.ancestors(newPath)) {
          var _p = Path.transform(_ancestor, op);

          newAncestors.push(_p);
        }

        var newParent = newAncestors[newAncestors.length - 1];
        var newIndex = newPath[newPath.length - 1];
        var resultPath = newParent.concat(newIndex);
        return [...oldAncestors, ...newAncestors, resultPath];
      }

    case 'remove_node':
      {
        var {
          path: _path5
        } = op;

        var _ancestors = Path.ancestors(_path5);

        return [..._ancestors];
      }

    case 'split_node':
      {
        var {
          path: _path6
        } = op;

        var _levels = Path.levels(_path6);

        var nextPath = Path.next(_path6);
        return [..._levels, nextPath];
      }

    default:
      {
        return [];
      }
  }
};

function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties$1(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

// Character (grapheme cluster) boundaries are determined according to
// the default grapheme cluster boundary specification, extended grapheme clusters variant[1].
//
// References:
//
// [1] https://www.unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table
// [2] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt
// [3] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.html
// [4] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt

/**
 * Get the distance to the end of the first character in a string of text.
 */
var getCharacterDistance = function getCharacterDistance(str) {
  var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var isLTR = !isRTL;
  var codepoints = isRTL ? codepointsIteratorRTL(str) : str;
  var left = CodepointType.None;
  var right = CodepointType.None;
  var distance = 0; // Evaluation of these conditions are deferred.

  var gb11 = null; // Is GB11 applicable?

  var gb12Or13 = null; // Is GB12 or GB13 applicable?

  for (var char of codepoints) {
    var code = char.codePointAt(0);
    if (!code) break;
    var type = getCodepointType(char, code);
    [left, right] = isLTR ? [right, type] : [type, left];

    if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {
      if (isLTR) {
        gb11 = endsWithEmojiZWJ(str.substring(0, distance));
      } else {
        gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));
      }

      if (!gb11) break;
    }

    if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {
      if (gb12Or13 !== null) {
        gb12Or13 = !gb12Or13;
      } else {
        if (isLTR) {
          gb12Or13 = true;
        } else {
          gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));
        }
      }

      if (!gb12Or13) break;
    }

    if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {
      break;
    }

    distance += char.length;
  }

  return distance || 1;
};
var SPACE = /\s/;
var PUNCTUATION = /[\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
var CHAMELEON = /['\u2018\u2019]/;
/**
 * Get the distance to the end of the first word in a string of text.
 */

var getWordDistance = function getWordDistance(text) {
  var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var dist = 0;
  var started = false;

  while (text.length > 0) {
    var charDist = getCharacterDistance(text, isRTL);
    var [char, remaining] = splitByCharacterDistance(text, charDist, isRTL);

    if (isWordCharacter(char, remaining, isRTL)) {
      started = true;
      dist += charDist;
    } else if (!started) {
      dist += charDist;
    } else {
      break;
    }

    text = remaining;
  }

  return dist;
};
/**
 * Split a string in two parts at a given distance starting from the end when
 * `isRTL` is set to `true`.
 */

var splitByCharacterDistance = (str, dist, isRTL) => {
  if (isRTL) {
    var at = str.length - dist;
    return [str.slice(at, str.length), str.slice(0, at)];
  }

  return [str.slice(0, dist), str.slice(dist)];
};
/**
 * Check if a character is a word character. The `remaining` argument is used
 * because sometimes you must read subsequent characters to truly determine it.
 */

var isWordCharacter = function isWordCharacter(char, remaining) {
  var isRTL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (SPACE.test(char)) {
    return false;
  } // Chameleons count as word characters as long as they're in a word, so
  // recurse to see if the next one is a word character or not.


  if (CHAMELEON.test(char)) {
    var charDist = getCharacterDistance(remaining, isRTL);
    var [nextChar, nextRemaining] = splitByCharacterDistance(remaining, charDist, isRTL);

    if (isWordCharacter(nextChar, nextRemaining, isRTL)) {
      return true;
    }
  }

  if (PUNCTUATION.test(char)) {
    return false;
  }

  return true;
};
/**
 * Iterate on codepoints from right to left.
 */


var codepointsIteratorRTL = function* codepointsIteratorRTL(str) {
  var end = str.length - 1;

  for (var i = 0; i < str.length; i++) {
    var char1 = str.charAt(end - i);

    if (isLowSurrogate(char1.charCodeAt(0))) {
      var char2 = str.charAt(end - i - 1);

      if (isHighSurrogate(char2.charCodeAt(0))) {
        yield char2 + char1;
        i++;
        continue;
      }
    }

    yield char1;
  }
};
/**
 * Is `charCode` a high surrogate.
 *
 * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates
 */

var isHighSurrogate = charCode => {
  return charCode >= 0xd800 && charCode <= 0xdbff;
};
/**
 * Is `charCode` a low surrogate.
 *
 * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates
 */


var isLowSurrogate = charCode => {
  return charCode >= 0xdc00 && charCode <= 0xdfff;
};

var CodepointType;

(function (CodepointType) {
  CodepointType[CodepointType["None"] = 0] = "None";
  CodepointType[CodepointType["Extend"] = 1] = "Extend";
  CodepointType[CodepointType["ZWJ"] = 2] = "ZWJ";
  CodepointType[CodepointType["RI"] = 4] = "RI";
  CodepointType[CodepointType["Prepend"] = 8] = "Prepend";
  CodepointType[CodepointType["SpacingMark"] = 16] = "SpacingMark";
  CodepointType[CodepointType["L"] = 32] = "L";
  CodepointType[CodepointType["V"] = 64] = "V";
  CodepointType[CodepointType["T"] = 128] = "T";
  CodepointType[CodepointType["LV"] = 256] = "LV";
  CodepointType[CodepointType["LVT"] = 512] = "LVT";
  CodepointType[CodepointType["ExtPict"] = 1024] = "ExtPict";
  CodepointType[CodepointType["Any"] = 2048] = "Any";
})(CodepointType || (CodepointType = {}));

var reExtend = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1AC0\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/;
var rePrepend = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/;
var reSpacingMark = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/;
var reL = /^[\u1100-\u115F\uA960-\uA97C]$/;
var reV = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/;
var reT = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/;
var reLV = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/;
var reLVT = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/;
var reExtPict = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/;

var getCodepointType = (char, code) => {
  var type = CodepointType.Any;

  if (char.search(reExtend) !== -1) {
    type |= CodepointType.Extend;
  }

  if (code === 0x200d) {
    type |= CodepointType.ZWJ;
  }

  if (code >= 0x1f1e6 && code <= 0x1f1ff) {
    type |= CodepointType.RI;
  }

  if (char.search(rePrepend) !== -1) {
    type |= CodepointType.Prepend;
  }

  if (char.search(reSpacingMark) !== -1) {
    type |= CodepointType.SpacingMark;
  }

  if (char.search(reL) !== -1) {
    type |= CodepointType.L;
  }

  if (char.search(reV) !== -1) {
    type |= CodepointType.V;
  }

  if (char.search(reT) !== -1) {
    type |= CodepointType.T;
  }

  if (char.search(reLV) !== -1) {
    type |= CodepointType.LV;
  }

  if (char.search(reLVT) !== -1) {
    type |= CodepointType.LVT;
  }

  if (char.search(reExtPict) !== -1) {
    type |= CodepointType.ExtPict;
  }

  return type;
};

function intersects(x, y) {
  return (x & y) !== 0;
}

var NonBoundaryPairs = [// GB6
[CodepointType.L, CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT], // GB7
[CodepointType.LV | CodepointType.V, CodepointType.V | CodepointType.T], // GB8
[CodepointType.LVT | CodepointType.T, CodepointType.T], // GB9
[CodepointType.Any, CodepointType.Extend | CodepointType.ZWJ], // GB9a
[CodepointType.Any, CodepointType.SpacingMark], // GB9b
[CodepointType.Prepend, CodepointType.Any], // GB11
[CodepointType.ZWJ, CodepointType.ExtPict], // GB12 and GB13
[CodepointType.RI, CodepointType.RI]];

function isBoundaryPair(left, right) {
  return NonBoundaryPairs.findIndex(r => intersects(left, r[0]) && intersects(right, r[1])) === -1;
}

var endingEmojiZWJ = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1AC0\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/;

var endsWithEmojiZWJ = str => {
  return str.search(endingEmojiZWJ) !== -1;
};

var endingRIs = /(?:\uD83C[\uDDE6-\uDDFF])+$/g;

var endsWithOddNumberOfRIs = str => {
  var match = str.match(endingRIs);

  if (match === null) {
    return false;
  } else {
    // A RI is represented by a surrogate pair.
    var numRIs = match[0].length / 2;
    return numRIs % 2 === 1;
  }
};

/**
 * Shared the function with isElementType utility
 */

var isElement = value => {
  return isPlainObject(value) && Node.isNodeList(value.children) && !Editor$1.isEditor(value);
};

var Element$1 = {
  /**
   * Check if a value implements the 'Ancestor' interface.
   */
  isAncestor(value) {
    return isPlainObject(value) && Node.isNodeList(value.children);
  },

  /**
   * Check if a value implements the `Element` interface.
   */
  isElement,

  /**
   * Check if a value is an array of `Element` objects.
   */
  isElementList(value) {
    return Array.isArray(value) && value.every(val => Element$1.isElement(val));
  },

  /**
   * Check if a set of props is a partial of Element.
   */
  isElementProps(props) {
    return props.children !== undefined;
  },

  /**
   * Check if a value implements the `Element` interface and has elementKey with selected value.
   * Default it check to `type` key value
   */
  isElementType: function isElementType(value, elementVal) {
    var elementKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'type';
    return isElement(value) && value[elementKey] === elementVal;
  },

  /**
   * Check if an element matches set of properties.
   *
   * Note: this checks custom properties, and it does not ensure that any
   * children are equivalent.
   */
  matches(element, props) {
    for (var key in props) {
      if (key === 'children') {
        continue;
      }

      if (element[key] !== props[key]) {
        return false;
      }
    }

    return true;
  }

};

var _excluded$4$1 = ["text"],
    _excluded2$3 = ["text"];

function ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$8(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var IS_EDITOR_CACHE = new WeakMap();
var Editor$1 = {
  /**
   * Get the ancestor above a location in the document.
   */
  above(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      voids = false,
      mode = 'lowest',
      at = editor.selection,
      match
    } = options;

    if (!at) {
      return;
    }

    var path = Editor$1.path(editor, at);
    var reverse = mode === 'lowest';

    for (var [n, p] of Editor$1.levels(editor, {
      at: path,
      voids,
      match,
      reverse
    })) {
      if (!Text$1.isText(n) && !Path.equals(path, p)) {
        return [n, p];
      }
    }
  },

  /**
   * Add a custom property to the leaf text nodes in the current selection.
   *
   * If the selection is currently collapsed, the marks will be added to the
   * `editor.marks` property instead, and applied when text is inserted next.
   */
  addMark(editor, key, value) {
    editor.addMark(key, value);
  },

  /**
   * Get the point after a location.
   */
  after(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var anchor = Editor$1.point(editor, at, {
      edge: 'end'
    });
    var focus = Editor$1.end(editor, []);
    var range = {
      anchor,
      focus
    };
    var {
      distance = 1
    } = options;
    var d = 0;
    var target;

    for (var p of Editor$1.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {
      at: range
    }))) {
      if (d > distance) {
        break;
      }

      if (d !== 0) {
        target = p;
      }

      d++;
    }

    return target;
  },

  /**
   * Get the point before a location.
   */
  before(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var anchor = Editor$1.start(editor, []);
    var focus = Editor$1.point(editor, at, {
      edge: 'start'
    });
    var range = {
      anchor,
      focus
    };
    var {
      distance = 1
    } = options;
    var d = 0;
    var target;

    for (var p of Editor$1.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {
      at: range,
      reverse: true
    }))) {
      if (d > distance) {
        break;
      }

      if (d !== 0) {
        target = p;
      }

      d++;
    }

    return target;
  },

  /**
   * Delete content in the editor backward from the current selection.
   */
  deleteBackward(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      unit = 'character'
    } = options;
    editor.deleteBackward(unit);
  },

  /**
   * Delete content in the editor forward from the current selection.
   */
  deleteForward(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      unit = 'character'
    } = options;
    editor.deleteForward(unit);
  },

  /**
   * Delete the content in the current selection.
   */
  deleteFragment(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      direction = 'forward'
    } = options;
    editor.deleteFragment(direction);
  },

  /**
   * Get the start and end points of a location.
   */
  edges(editor, at) {
    return [Editor$1.start(editor, at), Editor$1.end(editor, at)];
  },

  /**
   * Get the end point of a location.
   */
  end(editor, at) {
    return Editor$1.point(editor, at, {
      edge: 'end'
    });
  },

  /**
   * Get the first node at a location.
   */
  first(editor, at) {
    var path = Editor$1.path(editor, at, {
      edge: 'start'
    });
    return Editor$1.node(editor, path);
  },

  /**
   * Get the fragment at a location.
   */
  fragment(editor, at) {
    var range = Editor$1.range(editor, at);
    var fragment = Node.fragment(editor, range);
    return fragment;
  },

  /**
   * Check if a node has block children.
   */
  hasBlocks(editor, element) {
    return element.children.some(n => Editor$1.isBlock(editor, n));
  },

  /**
   * Check if a node has inline and text children.
   */
  hasInlines(editor, element) {
    return element.children.some(n => Text$1.isText(n) || Editor$1.isInline(editor, n));
  },

  /**
   * Check if a node has text children.
   */
  hasTexts(editor, element) {
    return element.children.every(n => Text$1.isText(n));
  },

  /**
   * Insert a block break at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertBreak(editor) {
    editor.insertBreak();
  },

  /**
   * Insert a soft break at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertSoftBreak(editor) {
    editor.insertSoftBreak();
  },

  /**
   * Insert a fragment at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertFragment(editor, fragment) {
    editor.insertFragment(fragment);
  },

  /**
   * Insert a node at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertNode(editor, node) {
    editor.insertNode(node);
  },

  /**
   * Insert text at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertText(editor, text) {
    editor.insertText(text);
  },

  /**
   * Check if a value is a block `Element` object.
   */
  isBlock(editor, value) {
    return Element$1.isElement(value) && !editor.isInline(value);
  },

  /**
   * Check if a value is an `Editor` object.
   */
  isEditor(value) {
    if (!isPlainObject(value)) return false;
    var cachedIsEditor = IS_EDITOR_CACHE.get(value);

    if (cachedIsEditor !== undefined) {
      return cachedIsEditor;
    }

    var isEditor = typeof value.addMark === 'function' && typeof value.apply === 'function' && typeof value.deleteBackward === 'function' && typeof value.deleteForward === 'function' && typeof value.deleteFragment === 'function' && typeof value.insertBreak === 'function' && typeof value.insertSoftBreak === 'function' && typeof value.insertFragment === 'function' && typeof value.insertNode === 'function' && typeof value.insertText === 'function' && typeof value.isInline === 'function' && typeof value.isVoid === 'function' && typeof value.normalizeNode === 'function' && typeof value.onChange === 'function' && typeof value.removeMark === 'function' && (value.marks === null || isPlainObject(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);
    IS_EDITOR_CACHE.set(value, isEditor);
    return isEditor;
  },

  /**
   * Check if a point is the end point of a location.
   */
  isEnd(editor, point, at) {
    var end = Editor$1.end(editor, at);
    return Point.equals(point, end);
  },

  /**
   * Check if a point is an edge of a location.
   */
  isEdge(editor, point, at) {
    return Editor$1.isStart(editor, point, at) || Editor$1.isEnd(editor, point, at);
  },

  /**
   * Check if an element is empty, accounting for void nodes.
   */
  isEmpty(editor, element) {
    var {
      children
    } = element;
    var [first] = children;
    return children.length === 0 || children.length === 1 && Text$1.isText(first) && first.text === '' && !editor.isVoid(element);
  },

  /**
   * Check if a value is an inline `Element` object.
   */
  isInline(editor, value) {
    return Element$1.isElement(value) && editor.isInline(value);
  },

  /**
   * Check if the editor is currently normalizing after each operation.
   */
  isNormalizing(editor) {
    var isNormalizing = NORMALIZING.get(editor);
    return isNormalizing === undefined ? true : isNormalizing;
  },

  /**
   * Check if a point is the start point of a location.
   */
  isStart(editor, point, at) {
    // PERF: If the offset isn't `0` we know it's not the start.
    if (point.offset !== 0) {
      return false;
    }

    var start = Editor$1.start(editor, at);
    return Point.equals(point, start);
  },

  /**
   * Check if a value is a void `Element` object.
   */
  isVoid(editor, value) {
    return Element$1.isElement(value) && editor.isVoid(value);
  },

  /**
   * Get the last node at a location.
   */
  last(editor, at) {
    var path = Editor$1.path(editor, at, {
      edge: 'end'
    });
    return Editor$1.node(editor, path);
  },

  /**
   * Get the leaf text node at a location.
   */
  leaf(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var path = Editor$1.path(editor, at, options);
    var node = Node.leaf(editor, path);
    return [node, path];
  },

  /**
   * Iterate through all of the levels at a location.
   */
  *levels(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      at = editor.selection,
      reverse = false,
      voids = false
    } = options;
    var {
      match
    } = options;

    if (match == null) {
      match = () => true;
    }

    if (!at) {
      return;
    }

    var levels = [];
    var path = Editor$1.path(editor, at);

    for (var [n, p] of Node.levels(editor, path)) {
      if (!match(n, p)) {
        continue;
      }

      levels.push([n, p]);

      if (!voids && Editor$1.isVoid(editor, n)) {
        break;
      }
    }

    if (reverse) {
      levels.reverse();
    }

    yield* levels;
  },

  /**
   * Get the marks that would be added to text at the current selection.
   */
  marks(editor) {
    var {
      marks,
      selection
    } = editor;

    if (!selection) {
      return null;
    }

    if (marks) {
      return marks;
    }

    if (Range.isExpanded(selection)) {
      var [match] = Editor$1.nodes(editor, {
        match: Text$1.isText
      });

      if (match) {
        var [_node] = match;

        var _rest = _objectWithoutProperties$1(_node, _excluded$4$1);

        return _rest;
      } else {
        return {};
      }
    }

    var {
      anchor
    } = selection;
    var {
      path
    } = anchor;
    var [node] = Editor$1.leaf(editor, path);

    if (anchor.offset === 0) {
      var prev = Editor$1.previous(editor, {
        at: path,
        match: Text$1.isText
      });
      var block = Editor$1.above(editor, {
        match: n => Editor$1.isBlock(editor, n)
      });

      if (prev && block) {
        var [prevNode, prevPath] = prev;
        var [, blockPath] = block;

        if (Path.isAncestor(blockPath, prevPath)) {
          node = prevNode;
        }
      }
    }

    var rest = _objectWithoutProperties$1(node, _excluded2$3);

    return rest;
  },

  /**
   * Get the matching node in the branch of the document after a location.
   */
  next(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      mode = 'lowest',
      voids = false
    } = options;
    var {
      match,
      at = editor.selection
    } = options;

    if (!at) {
      return;
    }

    var pointAfterLocation = Editor$1.after(editor, at, {
      voids
    });
    if (!pointAfterLocation) return;
    var [, to] = Editor$1.last(editor, []);
    var span = [pointAfterLocation.path, to];

    if (Path.isPath(at) && at.length === 0) {
      throw new Error("Cannot get the next node from the root node!");
    }

    if (match == null) {
      if (Path.isPath(at)) {
        var [parent] = Editor$1.parent(editor, at);

        match = n => parent.children.includes(n);
      } else {
        match = () => true;
      }
    }

    var [next] = Editor$1.nodes(editor, {
      at: span,
      match,
      mode,
      voids
    });
    return next;
  },

  /**
   * Get the node at a location.
   */
  node(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var path = Editor$1.path(editor, at, options);
    var node = Node.get(editor, path);
    return [node, path];
  },

  /**
   * Iterate through all of the nodes in the Editor.
   */
  *nodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      at = editor.selection,
      mode = 'all',
      universal = false,
      reverse = false,
      voids = false
    } = options;
    var {
      match
    } = options;

    if (!match) {
      match = () => true;
    }

    if (!at) {
      return;
    }

    var from;
    var to;

    if (Span.isSpan(at)) {
      from = at[0];
      to = at[1];
    } else {
      var first = Editor$1.path(editor, at, {
        edge: 'start'
      });
      var last = Editor$1.path(editor, at, {
        edge: 'end'
      });
      from = reverse ? last : first;
      to = reverse ? first : last;
    }

    var nodeEntries = Node.nodes(editor, {
      reverse,
      from,
      to,
      pass: _ref => {
        var [n] = _ref;
        return voids ? false : Editor$1.isVoid(editor, n);
      }
    });
    var matches = [];
    var hit;

    for (var [node, path] of nodeEntries) {
      var isLower = hit && Path.compare(path, hit[1]) === 0; // In highest mode any node lower than the last hit is not a match.

      if (mode === 'highest' && isLower) {
        continue;
      }

      if (!match(node, path)) {
        // If we've arrived at a leaf text node that is not lower than the last
        // hit, then we've found a branch that doesn't include a match, which
        // means the match is not universal.
        if (universal && !isLower && Text$1.isText(node)) {
          return;
        } else {
          continue;
        }
      } // If there's a match and it's lower than the last, update the hit.


      if (mode === 'lowest' && isLower) {
        hit = [node, path];
        continue;
      } // In lowest mode we emit the last hit, once it's guaranteed lowest.


      var emit = mode === 'lowest' ? hit : [node, path];

      if (emit) {
        if (universal) {
          matches.push(emit);
        } else {
          yield emit;
        }
      }

      hit = [node, path];
    } // Since lowest is always emitting one behind, catch up at the end.


    if (mode === 'lowest' && hit) {
      if (universal) {
        matches.push(hit);
      } else {
        yield hit;
      }
    } // Universal defers to ensure that the match occurs in every branch, so we
    // yield all of the matches after iterating.


    if (universal) {
      yield* matches;
    }
  },

  /**
   * Normalize any dirty objects in the editor.
   */
  normalize(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      force = false
    } = options;

    var getDirtyPaths = editor => {
      return DIRTY_PATHS.get(editor) || [];
    };

    var getDirtyPathKeys = editor => {
      return DIRTY_PATH_KEYS.get(editor) || new Set();
    };

    var popDirtyPath = editor => {
      var path = getDirtyPaths(editor).pop();
      var key = path.join(',');
      getDirtyPathKeys(editor).delete(key);
      return path;
    };

    if (!Editor$1.isNormalizing(editor)) {
      return;
    }

    if (force) {
      var allPaths = Array.from(Node.nodes(editor), _ref2 => {
        var [, p] = _ref2;
        return p;
      });
      var allPathKeys = new Set(allPaths.map(p => p.join(',')));
      DIRTY_PATHS.set(editor, allPaths);
      DIRTY_PATH_KEYS.set(editor, allPathKeys);
    }

    if (getDirtyPaths(editor).length === 0) {
      return;
    }

    Editor$1.withoutNormalizing(editor, () => {
      /*
        Fix dirty elements with no children.
        editor.normalizeNode() does fix this, but some normalization fixes also require it to work.
        Running an initial pass avoids the catch-22 race condition.
      */
      for (var dirtyPath of getDirtyPaths(editor)) {
        if (Node.has(editor, dirtyPath)) {
          var entry = Editor$1.node(editor, dirtyPath);
          var [node, _] = entry;
          /*
            The default normalizer inserts an empty text node in this scenario, but it can be customised.
            So there is some risk here.
                       As long as the normalizer only inserts child nodes for this case it is safe to do in any order;
            by definition adding children to an empty node can't cause other paths to change.
          */

          if (Element$1.isElement(node) && node.children.length === 0) {
            editor.normalizeNode(entry);
          }
        }
      }

      var max = getDirtyPaths(editor).length * 42; // HACK: better way?

      var m = 0;

      while (getDirtyPaths(editor).length !== 0) {
        if (m > max) {
          throw new Error("\n            Could not completely normalize the editor after ".concat(max, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\n          "));
        }

        var _dirtyPath = popDirtyPath(editor); // If the node doesn't exist in the tree, it does not need to be normalized.


        if (Node.has(editor, _dirtyPath)) {
          var _entry = Editor$1.node(editor, _dirtyPath);

          editor.normalizeNode(_entry);
        }

        m++;
      }
    });
  },

  /**
   * Get the parent node of a location.
   */
  parent(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var path = Editor$1.path(editor, at, options);
    var parentPath = Path.parent(path);
    var entry = Editor$1.node(editor, parentPath);
    return entry;
  },

  /**
   * Get the path of a location.
   */
  path(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      depth,
      edge
    } = options;

    if (Path.isPath(at)) {
      if (edge === 'start') {
        var [, firstPath] = Node.first(editor, at);
        at = firstPath;
      } else if (edge === 'end') {
        var [, lastPath] = Node.last(editor, at);
        at = lastPath;
      }
    }

    if (Range.isRange(at)) {
      if (edge === 'start') {
        at = Range.start(at);
      } else if (edge === 'end') {
        at = Range.end(at);
      } else {
        at = Path.common(at.anchor.path, at.focus.path);
      }
    }

    if (Point.isPoint(at)) {
      at = at.path;
    }

    if (depth != null) {
      at = at.slice(0, depth);
    }

    return at;
  },

  hasPath(editor, path) {
    return Node.has(editor, path);
  },

  /**
   * Create a mutable ref for a `Path` object, which will stay in sync as new
   * operations are applied to the editor.
   */
  pathRef(editor, path) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      affinity = 'forward'
    } = options;
    var ref = {
      current: path,
      affinity,

      unref() {
        var {
          current
        } = ref;
        var pathRefs = Editor$1.pathRefs(editor);
        pathRefs.delete(ref);
        ref.current = null;
        return current;
      }

    };
    var refs = Editor$1.pathRefs(editor);
    refs.add(ref);
    return ref;
  },

  /**
   * Get the set of currently tracked path refs of the editor.
   */
  pathRefs(editor) {
    var refs = PATH_REFS.get(editor);

    if (!refs) {
      refs = new Set();
      PATH_REFS.set(editor, refs);
    }

    return refs;
  },

  /**
   * Get the start or end point of a location.
   */
  point(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      edge = 'start'
    } = options;

    if (Path.isPath(at)) {
      var path;

      if (edge === 'end') {
        var [, lastPath] = Node.last(editor, at);
        path = lastPath;
      } else {
        var [, firstPath] = Node.first(editor, at);
        path = firstPath;
      }

      var node = Node.get(editor, path);

      if (!Text$1.isText(node)) {
        throw new Error("Cannot get the ".concat(edge, " point in the node at path [").concat(at, "] because it has no ").concat(edge, " text node."));
      }

      return {
        path,
        offset: edge === 'end' ? node.text.length : 0
      };
    }

    if (Range.isRange(at)) {
      var [start, end] = Range.edges(at);
      return edge === 'start' ? start : end;
    }

    return at;
  },

  /**
   * Create a mutable ref for a `Point` object, which will stay in sync as new
   * operations are applied to the editor.
   */
  pointRef(editor, point) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      affinity = 'forward'
    } = options;
    var ref = {
      current: point,
      affinity,

      unref() {
        var {
          current
        } = ref;
        var pointRefs = Editor$1.pointRefs(editor);
        pointRefs.delete(ref);
        ref.current = null;
        return current;
      }

    };
    var refs = Editor$1.pointRefs(editor);
    refs.add(ref);
    return ref;
  },

  /**
   * Get the set of currently tracked point refs of the editor.
   */
  pointRefs(editor) {
    var refs = POINT_REFS.get(editor);

    if (!refs) {
      refs = new Set();
      POINT_REFS.set(editor, refs);
    }

    return refs;
  },

  /**
   * Return all the positions in `at` range where a `Point` can be placed.
   *
   * By default, moves forward by individual offsets at a time, but
   * the `unit` option can be used to to move by character, word, line, or block.
   *
   * The `reverse` option can be used to change iteration direction.
   *
   * Note: By default void nodes are treated as a single point and iteration
   * will not happen inside their content unless you pass in true for the
   * `voids` option, then iteration will occur.
   */
  *positions(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      at = editor.selection,
      unit = 'offset',
      reverse = false,
      voids = false
    } = options;

    if (!at) {
      return;
    }
    /**
     * Algorithm notes:
     *
     * Each step `distance` is dynamic depending on the underlying text
     * and the `unit` specified.  Each step, e.g., a line or word, may
     * span multiple text nodes, so we iterate through the text both on
     * two levels in step-sync:
     *
     * `leafText` stores the text on a text leaf level, and is advanced
     * through using the counters `leafTextOffset` and `leafTextRemaining`.
     *
     * `blockText` stores the text on a block level, and is shortened
     * by `distance` every time it is advanced.
     *
     * We only maintain a window of one blockText and one leafText because
     * a block node always appears before all of its leaf nodes.
     */


    var range = Editor$1.range(editor, at);
    var [start, end] = Range.edges(range);
    var first = reverse ? end : start;
    var isNewBlock = false;
    var blockText = '';
    var distance = 0; // Distance for leafText to catch up to blockText.

    var leafTextRemaining = 0;
    var leafTextOffset = 0; // Iterate through all nodes in range, grabbing entire textual content
    // of block nodes in blockText, and text nodes in leafText.
    // Exploits the fact that nodes are sequenced in such a way that we first
    // encounter the block node, then all of its text nodes, so when iterating
    // through the blockText and leafText we just need to remember a window of
    // one block node and leaf node, respectively.

    for (var [node, path] of Editor$1.nodes(editor, {
      at,
      reverse,
      voids
    })) {
      /*
       * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks
       */
      if (Element$1.isElement(node)) {
        // Void nodes are a special case, so by default we will always
        // yield their first point. If the `voids` option is set to true,
        // then we will iterate over their content.
        if (!voids && editor.isVoid(node)) {
          yield Editor$1.start(editor, path); // It's possible the start of the range we're iterating over is in a void, in which case
          // we want to make sure we don't incorrectly yield the start of a subsequent text node for unit !== 'offset'

          isNewBlock = false;
          continue;
        } // Inline element nodes are ignored as they don't themselves
        // contribute to `blockText` or `leafText` - their parent and
        // children do.


        if (editor.isInline(node)) continue; // Block element node - set `blockText` to its text content.

        if (Editor$1.hasInlines(editor, node)) {
          // We always exhaust block nodes before encountering a new one:
          //   console.assert(blockText === '',
          //     `blockText='${blockText}' - `+
          //     `not exhausted before new block node`, path)
          // Ensure range considered is capped to `range`, in the
          // start/end edge cases where block extends beyond range.
          // Equivalent to this, but presumably more performant:
          //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))
          //   blockRange = Range.intersection(range, blockRange) // intersect
          //   blockText = Editor.string(editor, blockRange, { voids })
          var e = Path.isAncestor(path, end.path) ? end : Editor$1.end(editor, path);
          var s = Path.isAncestor(path, start.path) ? start : Editor$1.start(editor, path);
          blockText = Editor$1.string(editor, {
            anchor: s,
            focus: e
          }, {
            voids
          });
          isNewBlock = true;
        }
      }
      /*
       * TEXT LEAF NODE - Iterate through text content, yielding
       * positions every `distance` offset according to `unit`.
       */


      if (Text$1.isText(node)) {
        var isFirst = Path.equals(path, first.path); // Proof that we always exhaust text nodes before encountering a new one:
        //   console.assert(leafTextRemaining <= 0,
        //     `leafTextRemaining=${leafTextRemaining} - `+
        //     `not exhausted before new leaf text node`, path)
        // Reset `leafText` counters for new text node.

        if (isFirst) {
          leafTextRemaining = reverse ? first.offset : node.text.length - first.offset;
          leafTextOffset = first.offset; // Works for reverse too.
        } else {
          leafTextRemaining = node.text.length;
          leafTextOffset = reverse ? leafTextRemaining : 0;
        } // Yield position at the start of node (potentially).


        if (isFirst || isNewBlock || unit === 'offset') {
          yield {
            path,
            offset: leafTextOffset
          };
          isNewBlock = false;
        } // Yield positions every (dynamically calculated) `distance` offset.


        while (true) {
          // If `leafText` has caught up with `blockText` (distance=0),
          // and if blockText is exhausted, break to get another block node,
          // otherwise advance blockText forward by the new `distance`.
          if (distance === 0) {
            if (blockText === '') break;
            distance = calcDistance(blockText, unit, reverse); // Split the string at the previously found distance and use the
            // remaining string for the next iteration.

            blockText = splitByCharacterDistance(blockText, distance, reverse)[1];
          } // Advance `leafText` by the current `distance`.


          leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;
          leafTextRemaining = leafTextRemaining - distance; // If `leafText` is exhausted, break to get a new leaf node
          // and set distance to the overflow amount, so we'll (maybe)
          // catch up to blockText in the next leaf text node.

          if (leafTextRemaining < 0) {
            distance = -leafTextRemaining;
            break;
          } // Successfully walked `distance` offsets through `leafText`
          // to catch up with `blockText`, so we can reset `distance`
          // and yield this position in this node.


          distance = 0;
          yield {
            path,
            offset: leafTextOffset
          };
        }
      }
    } // Proof that upon completion, we've exahusted both leaf and block text:
    //   console.assert(leafTextRemaining <= 0, "leafText wasn't exhausted")
    //   console.assert(blockText === '', "blockText wasn't exhausted")
    // Helper:
    // Return the distance in offsets for a step of size `unit` on given string.


    function calcDistance(text, unit, reverse) {
      if (unit === 'character') {
        return getCharacterDistance(text, reverse);
      } else if (unit === 'word') {
        return getWordDistance(text, reverse);
      } else if (unit === 'line' || unit === 'block') {
        return text.length;
      }

      return 1;
    }
  },

  /**
   * Get the matching node in the branch of the document before a location.
   */
  previous(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      mode = 'lowest',
      voids = false
    } = options;
    var {
      match,
      at = editor.selection
    } = options;

    if (!at) {
      return;
    }

    var pointBeforeLocation = Editor$1.before(editor, at, {
      voids
    });

    if (!pointBeforeLocation) {
      return;
    }

    var [, to] = Editor$1.first(editor, []); // The search location is from the start of the document to the path of
    // the point before the location passed in

    var span = [pointBeforeLocation.path, to];

    if (Path.isPath(at) && at.length === 0) {
      throw new Error("Cannot get the previous node from the root node!");
    }

    if (match == null) {
      if (Path.isPath(at)) {
        var [parent] = Editor$1.parent(editor, at);

        match = n => parent.children.includes(n);
      } else {
        match = () => true;
      }
    }

    var [previous] = Editor$1.nodes(editor, {
      reverse: true,
      at: span,
      match,
      mode,
      voids
    });
    return previous;
  },

  /**
   * Get a range of a location.
   */
  range(editor, at, to) {
    if (Range.isRange(at) && !to) {
      return at;
    }

    var start = Editor$1.start(editor, at);
    var end = Editor$1.end(editor, to || at);
    return {
      anchor: start,
      focus: end
    };
  },

  /**
   * Create a mutable ref for a `Range` object, which will stay in sync as new
   * operations are applied to the editor.
   */
  rangeRef(editor, range) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      affinity = 'forward'
    } = options;
    var ref = {
      current: range,
      affinity,

      unref() {
        var {
          current
        } = ref;
        var rangeRefs = Editor$1.rangeRefs(editor);
        rangeRefs.delete(ref);
        ref.current = null;
        return current;
      }

    };
    var refs = Editor$1.rangeRefs(editor);
    refs.add(ref);
    return ref;
  },

  /**
   * Get the set of currently tracked range refs of the editor.
   */
  rangeRefs(editor) {
    var refs = RANGE_REFS.get(editor);

    if (!refs) {
      refs = new Set();
      RANGE_REFS.set(editor, refs);
    }

    return refs;
  },

  /**
   * Remove a custom property from all of the leaf text nodes in the current
   * selection.
   *
   * If the selection is currently collapsed, the removal will be stored on
   * `editor.marks` and applied to the text inserted next.
   */
  removeMark(editor, key) {
    editor.removeMark(key);
  },

  /**
   * Manually set if the editor should currently be normalizing.
   *
   * Note: Using this incorrectly can leave the editor in an invalid state.
   *
   */
  setNormalizing(editor, isNormalizing) {
    NORMALIZING.set(editor, isNormalizing);
  },

  /**
   * Get the start point of a location.
   */
  start(editor, at) {
    return Editor$1.point(editor, at, {
      edge: 'start'
    });
  },

  /**
   * Get the text string content of a location.
   *
   * Note: by default the text of void nodes is considered to be an empty
   * string, regardless of content, unless you pass in true for the voids option
   */
  string(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      voids = false
    } = options;
    var range = Editor$1.range(editor, at);
    var [start, end] = Range.edges(range);
    var text = '';

    for (var [node, path] of Editor$1.nodes(editor, {
      at: range,
      match: Text$1.isText,
      voids
    })) {
      var t = node.text;

      if (Path.equals(path, end.path)) {
        t = t.slice(0, end.offset);
      }

      if (Path.equals(path, start.path)) {
        t = t.slice(start.offset);
      }

      text += t;
    }

    return text;
  },

  /**
   * Convert a range into a non-hanging one.
   */
  unhangRange(editor, range) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      voids = false
    } = options;
    var [start, end] = Range.edges(range); // PERF: exit early if we can guarantee that the range isn't hanging.

    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range)) {
      return range;
    }

    var endBlock = Editor$1.above(editor, {
      at: end,
      match: n => Editor$1.isBlock(editor, n)
    });
    var blockPath = endBlock ? endBlock[1] : [];
    var first = Editor$1.start(editor, start);
    var before = {
      anchor: first,
      focus: end
    };
    var skip = true;

    for (var [node, path] of Editor$1.nodes(editor, {
      at: before,
      match: Text$1.isText,
      reverse: true,
      voids
    })) {
      if (skip) {
        skip = false;
        continue;
      }

      if (node.text !== '' || Path.isBefore(path, blockPath)) {
        end = {
          path,
          offset: node.text.length
        };
        break;
      }
    }

    return {
      anchor: start,
      focus: end
    };
  },

  /**
   * Match a void node in the current branch of the editor.
   */
  void(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return Editor$1.above(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {
      match: n => Editor$1.isVoid(editor, n)
    }));
  },

  /**
   * Call a function, deferring normalization until after it completes.
   */
  withoutNormalizing(editor, fn) {
    var value = Editor$1.isNormalizing(editor);
    Editor$1.setNormalizing(editor, false);

    try {
      fn();
    } finally {
      Editor$1.setNormalizing(editor, value);
    }

    Editor$1.normalize(editor);
  }

};
var Span = {
  /**
   * Check if a value implements the `Span` interface.
   */
  isSpan(value) {
    return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);
  }

};

var _excluded$3$1 = ["children"],
    _excluded2$2 = ["text"];
var IS_NODE_LIST_CACHE = new WeakMap();
var Node = {
  /**
   * Get the node at a specific path, asserting that it's an ancestor node.
   */
  ancestor(root, path) {
    var node = Node.get(root, path);

    if (Text$1.isText(node)) {
      throw new Error("Cannot get the ancestor node at path [".concat(path, "] because it refers to a text node instead: ").concat(node));
    }

    return node;
  },

  /**
   * Return a generator of all the ancestor nodes above a specific path.
   *
   * By default the order is bottom-up, from lowest to highest ancestor in
   * the tree, but you can pass the `reverse: true` option to go top-down.
   */
  *ancestors(root, path) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    for (var p of Path.ancestors(path, options)) {
      var n = Node.ancestor(root, p);
      var entry = [n, p];
      yield entry;
    }
  },

  /**
   * Get the child of a node at a specific index.
   */
  child(root, index) {
    if (Text$1.isText(root)) {
      throw new Error("Cannot get the child of a text node: ".concat(JSON.stringify(root)));
    }

    var c = root.children[index];

    if (c == null) {
      throw new Error("Cannot get child at index `".concat(index, "` in node: ").concat(JSON.stringify(root)));
    }

    return c;
  },

  /**
   * Iterate over the children of a node at a specific path.
   */
  *children(root, path) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      reverse = false
    } = options;
    var ancestor = Node.ancestor(root, path);
    var {
      children
    } = ancestor;
    var index = reverse ? children.length - 1 : 0;

    while (reverse ? index >= 0 : index < children.length) {
      var child = Node.child(ancestor, index);
      var childPath = path.concat(index);
      yield [child, childPath];
      index = reverse ? index - 1 : index + 1;
    }
  },

  /**
   * Get an entry for the common ancesetor node of two paths.
   */
  common(root, path, another) {
    var p = Path.common(path, another);
    var n = Node.get(root, p);
    return [n, p];
  },

  /**
   * Get the node at a specific path, asserting that it's a descendant node.
   */
  descendant(root, path) {
    var node = Node.get(root, path);

    if (Editor$1.isEditor(node)) {
      throw new Error("Cannot get the descendant node at path [".concat(path, "] because it refers to the root editor node instead: ").concat(node));
    }

    return node;
  },

  /**
   * Return a generator of all the descendant node entries inside a root node.
   */
  *descendants(root) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    for (var [node, path] of Node.nodes(root, options)) {
      if (path.length !== 0) {
        // NOTE: we have to coerce here because checking the path's length does
        // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.
        yield [node, path];
      }
    }
  },

  /**
   * Return a generator of all the element nodes inside a root node. Each iteration
   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the
   * root node is an element it will be included in the iteration as well.
   */
  *elements(root) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    for (var [node, path] of Node.nodes(root, options)) {
      if (Element$1.isElement(node)) {
        yield [node, path];
      }
    }
  },

  /**
   * Extract props from a Node.
   */
  extractProps(node) {
    if (Element$1.isAncestor(node)) {
      var properties = _objectWithoutProperties$1(node, _excluded$3$1);

      return properties;
    } else {
      var properties = _objectWithoutProperties$1(node, _excluded2$2);

      return properties;
    }
  },

  /**
   * Get the first node entry in a root node from a path.
   */
  first(root, path) {
    var p = path.slice();
    var n = Node.get(root, p);

    while (n) {
      if (Text$1.isText(n) || n.children.length === 0) {
        break;
      } else {
        n = n.children[0];
        p.push(0);
      }
    }

    return [n, p];
  },

  /**
   * Get the sliced fragment represented by a range inside a root node.
   */
  fragment(root, range) {
    if (Text$1.isText(root)) {
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(JSON.stringify(root)));
    }

    var newRoot = fn({
      children: root.children
    }, r => {
      var [start, end] = Range.edges(range);
      var nodeEntries = Node.nodes(r, {
        reverse: true,
        pass: _ref => {
          var [, path] = _ref;
          return !Range.includes(range, path);
        }
      });

      for (var [, path] of nodeEntries) {
        if (!Range.includes(range, path)) {
          var parent = Node.parent(r, path);
          var index = path[path.length - 1];
          parent.children.splice(index, 1);
        }

        if (Path.equals(path, end.path)) {
          var leaf = Node.leaf(r, path);
          leaf.text = leaf.text.slice(0, end.offset);
        }

        if (Path.equals(path, start.path)) {
          var _leaf = Node.leaf(r, path);

          _leaf.text = _leaf.text.slice(start.offset);
        }
      }

      if (Editor$1.isEditor(r)) {
        r.selection = null;
      }
    });
    return newRoot.children;
  },

  /**
   * Get the descendant node referred to by a specific path. If the path is an
   * empty array, it refers to the root node itself.
   */
  get(root, path) {
    var node = root;

    for (var i = 0; i < path.length; i++) {
      var p = path[i];

      if (Text$1.isText(node) || !node.children[p]) {
        throw new Error("Cannot find a descendant at path [".concat(path, "] in node: ").concat(JSON.stringify(root)));
      }

      node = node.children[p];
    }

    return node;
  },

  /**
   * Check if a descendant node exists at a specific path.
   */
  has(root, path) {
    var node = root;

    for (var i = 0; i < path.length; i++) {
      var p = path[i];

      if (Text$1.isText(node) || !node.children[p]) {
        return false;
      }

      node = node.children[p];
    }

    return true;
  },

  /**
   * Check if a value implements the `Node` interface.
   */
  isNode(value) {
    return Text$1.isText(value) || Element$1.isElement(value) || Editor$1.isEditor(value);
  },

  /**
   * Check if a value is a list of `Node` objects.
   */
  isNodeList(value) {
    if (!Array.isArray(value)) {
      return false;
    }

    var cachedResult = IS_NODE_LIST_CACHE.get(value);

    if (cachedResult !== undefined) {
      return cachedResult;
    }

    var isNodeList = value.every(val => Node.isNode(val));
    IS_NODE_LIST_CACHE.set(value, isNodeList);
    return isNodeList;
  },

  /**
   * Get the last node entry in a root node from a path.
   */
  last(root, path) {
    var p = path.slice();
    var n = Node.get(root, p);

    while (n) {
      if (Text$1.isText(n) || n.children.length === 0) {
        break;
      } else {
        var i = n.children.length - 1;
        n = n.children[i];
        p.push(i);
      }
    }

    return [n, p];
  },

  /**
   * Get the node at a specific path, ensuring it's a leaf text node.
   */
  leaf(root, path) {
    var node = Node.get(root, path);

    if (!Text$1.isText(node)) {
      throw new Error("Cannot get the leaf node at path [".concat(path, "] because it refers to a non-leaf node: ").concat(node));
    }

    return node;
  },

  /**
   * Return a generator of the in a branch of the tree, from a specific path.
   *
   * By default the order is top-down, from lowest to highest node in the tree,
   * but you can pass the `reverse: true` option to go bottom-up.
   */
  *levels(root, path) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    for (var p of Path.levels(path, options)) {
      var n = Node.get(root, p);
      yield [n, p];
    }
  },

  /**
   * Check if a node matches a set of props.
   */
  matches(node, props) {
    return Element$1.isElement(node) && Element$1.isElementProps(props) && Element$1.matches(node, props) || Text$1.isText(node) && Text$1.isTextProps(props) && Text$1.matches(node, props);
  },

  /**
   * Return a generator of all the node entries of a root node. Each entry is
   * returned as a `[Node, Path]` tuple, with the path referring to the node's
   * position inside the root node.
   */
  *nodes(root) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      pass,
      reverse = false
    } = options;
    var {
      from = [],
      to
    } = options;
    var visited = new Set();
    var p = [];
    var n = root;

    while (true) {
      if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {
        break;
      }

      if (!visited.has(n)) {
        yield [n, p];
      } // If we're allowed to go downward and we haven't descended yet, do.


      if (!visited.has(n) && !Text$1.isText(n) && n.children.length !== 0 && (pass == null || pass([n, p]) === false)) {
        visited.add(n);
        var nextIndex = reverse ? n.children.length - 1 : 0;

        if (Path.isAncestor(p, from)) {
          nextIndex = from[p.length];
        }

        p = p.concat(nextIndex);
        n = Node.get(root, p);
        continue;
      } // If we're at the root and we can't go down, we're done.


      if (p.length === 0) {
        break;
      } // If we're going forward...


      if (!reverse) {
        var newPath = Path.next(p);

        if (Node.has(root, newPath)) {
          p = newPath;
          n = Node.get(root, p);
          continue;
        }
      } // If we're going backward...


      if (reverse && p[p.length - 1] !== 0) {
        var _newPath = Path.previous(p);

        p = _newPath;
        n = Node.get(root, p);
        continue;
      } // Otherwise we're going upward...


      p = Path.parent(p);
      n = Node.get(root, p);
      visited.add(n);
    }
  },

  /**
   * Get the parent of a node at a specific path.
   */
  parent(root, path) {
    var parentPath = Path.parent(path);
    var p = Node.get(root, parentPath);

    if (Text$1.isText(p)) {
      throw new Error("Cannot get the parent of path [".concat(path, "] because it does not exist in the root."));
    }

    return p;
  },

  /**
   * Get the concatenated text string of a node's content.
   *
   * Note that this will not include spaces or line breaks between block nodes.
   * It is not a user-facing string, but a string for performing offset-related
   * computations for a node.
   */
  string(node) {
    if (Text$1.isText(node)) {
      return node.text;
    } else {
      return node.children.map(Node.string).join('');
    }
  },

  /**
   * Return a generator of all leaf text nodes in a root node.
   */
  *texts(root) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    for (var [node, path] of Node.nodes(root, options)) {
      if (Text$1.isText(node)) {
        yield [node, path];
      }
    }
  }

};

function ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var Operation = {
  /**
   * Check of a value is a `NodeOperation` object.
   */
  isNodeOperation(value) {
    return Operation.isOperation(value) && value.type.endsWith('_node');
  },

  /**
   * Check of a value is an `Operation` object.
   */
  isOperation(value) {
    if (!isPlainObject(value)) {
      return false;
    }

    switch (value.type) {
      case 'insert_node':
        return Path.isPath(value.path) && Node.isNode(value.node);

      case 'insert_text':
        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);

      case 'merge_node':
        return typeof value.position === 'number' && Path.isPath(value.path) && isPlainObject(value.properties);

      case 'move_node':
        return Path.isPath(value.path) && Path.isPath(value.newPath);

      case 'remove_node':
        return Path.isPath(value.path) && Node.isNode(value.node);

      case 'remove_text':
        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);

      case 'set_node':
        return Path.isPath(value.path) && isPlainObject(value.properties) && isPlainObject(value.newProperties);

      case 'set_selection':
        return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || isPlainObject(value.properties) && isPlainObject(value.newProperties);

      case 'split_node':
        return Path.isPath(value.path) && typeof value.position === 'number' && isPlainObject(value.properties);

      default:
        return false;
    }
  },

  /**
   * Check if a value is a list of `Operation` objects.
   */
  isOperationList(value) {
    return Array.isArray(value) && value.every(val => Operation.isOperation(val));
  },

  /**
   * Check of a value is a `SelectionOperation` object.
   */
  isSelectionOperation(value) {
    return Operation.isOperation(value) && value.type.endsWith('_selection');
  },

  /**
   * Check of a value is a `TextOperation` object.
   */
  isTextOperation(value) {
    return Operation.isOperation(value) && value.type.endsWith('_text');
  },

  /**
   * Invert an operation, returning a new operation that will exactly undo the
   * original when applied.
   */
  inverse(op) {
    switch (op.type) {
      case 'insert_node':
        {
          return _objectSpread$7(_objectSpread$7({}, op), {}, {
            type: 'remove_node'
          });
        }

      case 'insert_text':
        {
          return _objectSpread$7(_objectSpread$7({}, op), {}, {
            type: 'remove_text'
          });
        }

      case 'merge_node':
        {
          return _objectSpread$7(_objectSpread$7({}, op), {}, {
            type: 'split_node',
            path: Path.previous(op.path)
          });
        }

      case 'move_node':
        {
          var {
            newPath,
            path
          } = op; // PERF: in this case the move operation is a no-op anyways.

          if (Path.equals(newPath, path)) {
            return op;
          } // If the move happens completely within a single parent the path and
          // newPath are stable with respect to each other.


          if (Path.isSibling(path, newPath)) {
            return _objectSpread$7(_objectSpread$7({}, op), {}, {
              path: newPath,
              newPath: path
            });
          } // If the move does not happen within a single parent it is possible
          // for the move to impact the true path to the location where the node
          // was removed from and where it was inserted. We have to adjust for this
          // and find the original path. We can accomplish this (only in non-sibling)
          // moves by looking at the impact of the move operation on the node
          // after the original move path.


          var inversePath = Path.transform(path, op);
          var inverseNewPath = Path.transform(Path.next(path), op);
          return _objectSpread$7(_objectSpread$7({}, op), {}, {
            path: inversePath,
            newPath: inverseNewPath
          });
        }

      case 'remove_node':
        {
          return _objectSpread$7(_objectSpread$7({}, op), {}, {
            type: 'insert_node'
          });
        }

      case 'remove_text':
        {
          return _objectSpread$7(_objectSpread$7({}, op), {}, {
            type: 'insert_text'
          });
        }

      case 'set_node':
        {
          var {
            properties,
            newProperties
          } = op;
          return _objectSpread$7(_objectSpread$7({}, op), {}, {
            properties: newProperties,
            newProperties: properties
          });
        }

      case 'set_selection':
        {
          var {
            properties: _properties,
            newProperties: _newProperties
          } = op;

          if (_properties == null) {
            return _objectSpread$7(_objectSpread$7({}, op), {}, {
              properties: _newProperties,
              newProperties: null
            });
          } else if (_newProperties == null) {
            return _objectSpread$7(_objectSpread$7({}, op), {}, {
              properties: null,
              newProperties: _properties
            });
          } else {
            return _objectSpread$7(_objectSpread$7({}, op), {}, {
              properties: _newProperties,
              newProperties: _properties
            });
          }
        }

      case 'split_node':
        {
          return _objectSpread$7(_objectSpread$7({}, op), {}, {
            type: 'merge_node',
            path: Path.next(op.path)
          });
        }
    }
  }

};

var Path = {
  /**
   * Get a list of ancestor paths for a given path.
   *
   * The paths are sorted from deepest to shallowest ancestor. However, if the
   * `reverse: true` option is passed, they are reversed.
   */
  ancestors(path) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      reverse = false
    } = options;
    var paths = Path.levels(path, options);

    if (reverse) {
      paths = paths.slice(1);
    } else {
      paths = paths.slice(0, -1);
    }

    return paths;
  },

  /**
   * Get the common ancestor path of two paths.
   */
  common(path, another) {
    var common = [];

    for (var i = 0; i < path.length && i < another.length; i++) {
      var av = path[i];
      var bv = another[i];

      if (av !== bv) {
        break;
      }

      common.push(av);
    }

    return common;
  },

  /**
   * Compare a path to another, returning an integer indicating whether the path
   * was before, at, or after the other.
   *
   * Note: Two paths of unequal length can still receive a `0` result if one is
   * directly above or below the other. If you want exact matching, use
   * [[Path.equals]] instead.
   */
  compare(path, another) {
    var min = Math.min(path.length, another.length);

    for (var i = 0; i < min; i++) {
      if (path[i] < another[i]) return -1;
      if (path[i] > another[i]) return 1;
    }

    return 0;
  },

  /**
   * Check if a path ends after one of the indexes in another.
   */
  endsAfter(path, another) {
    var i = path.length - 1;
    var as = path.slice(0, i);
    var bs = another.slice(0, i);
    var av = path[i];
    var bv = another[i];
    return Path.equals(as, bs) && av > bv;
  },

  /**
   * Check if a path ends at one of the indexes in another.
   */
  endsAt(path, another) {
    var i = path.length;
    var as = path.slice(0, i);
    var bs = another.slice(0, i);
    return Path.equals(as, bs);
  },

  /**
   * Check if a path ends before one of the indexes in another.
   */
  endsBefore(path, another) {
    var i = path.length - 1;
    var as = path.slice(0, i);
    var bs = another.slice(0, i);
    var av = path[i];
    var bv = another[i];
    return Path.equals(as, bs) && av < bv;
  },

  /**
   * Check if a path is exactly equal to another.
   */
  equals(path, another) {
    return path.length === another.length && path.every((n, i) => n === another[i]);
  },

  /**
   * Check if the path of previous sibling node exists
   */
  hasPrevious(path) {
    return path[path.length - 1] > 0;
  },

  /**
   * Check if a path is after another.
   */
  isAfter(path, another) {
    return Path.compare(path, another) === 1;
  },

  /**
   * Check if a path is an ancestor of another.
   */
  isAncestor(path, another) {
    return path.length < another.length && Path.compare(path, another) === 0;
  },

  /**
   * Check if a path is before another.
   */
  isBefore(path, another) {
    return Path.compare(path, another) === -1;
  },

  /**
   * Check if a path is a child of another.
   */
  isChild(path, another) {
    return path.length === another.length + 1 && Path.compare(path, another) === 0;
  },

  /**
   * Check if a path is equal to or an ancestor of another.
   */
  isCommon(path, another) {
    return path.length <= another.length && Path.compare(path, another) === 0;
  },

  /**
   * Check if a path is a descendant of another.
   */
  isDescendant(path, another) {
    return path.length > another.length && Path.compare(path, another) === 0;
  },

  /**
   * Check if a path is the parent of another.
   */
  isParent(path, another) {
    return path.length + 1 === another.length && Path.compare(path, another) === 0;
  },

  /**
   * Check is a value implements the `Path` interface.
   */
  isPath(value) {
    return Array.isArray(value) && (value.length === 0 || typeof value[0] === 'number');
  },

  /**
   * Check if a path is a sibling of another.
   */
  isSibling(path, another) {
    if (path.length !== another.length) {
      return false;
    }

    var as = path.slice(0, -1);
    var bs = another.slice(0, -1);
    var al = path[path.length - 1];
    var bl = another[another.length - 1];
    return al !== bl && Path.equals(as, bs);
  },

  /**
   * Get a list of paths at every level down to a path. Note: this is the same
   * as `Path.ancestors`, but including the path itself.
   *
   * The paths are sorted from shallowest to deepest. However, if the `reverse:
   * true` option is passed, they are reversed.
   */
  levels(path) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      reverse = false
    } = options;
    var list = [];

    for (var i = 0; i <= path.length; i++) {
      list.push(path.slice(0, i));
    }

    if (reverse) {
      list.reverse();
    }

    return list;
  },

  /**
   * Given a path, get the path to the next sibling node.
   */
  next(path) {
    if (path.length === 0) {
      throw new Error("Cannot get the next path of a root path [".concat(path, "], because it has no next index."));
    }

    var last = path[path.length - 1];
    return path.slice(0, -1).concat(last + 1);
  },

  /**
   * Returns whether this operation can affect paths or not. Used as an
   * optimization when updating dirty paths during normalization
   *
   * NOTE: This *must* be kept in sync with the implementation of 'transform'
   * below
   */
  operationCanTransformPath(operation) {
    switch (operation.type) {
      case 'insert_node':
      case 'remove_node':
      case 'merge_node':
      case 'split_node':
      case 'move_node':
        return true;

      default:
        return false;
    }
  },

  /**
   * Given a path, return a new path referring to the parent node above it.
   */
  parent(path) {
    if (path.length === 0) {
      throw new Error("Cannot get the parent path of the root path [".concat(path, "]."));
    }

    return path.slice(0, -1);
  },

  /**
   * Given a path, get the path to the previous sibling node.
   */
  previous(path) {
    if (path.length === 0) {
      throw new Error("Cannot get the previous path of a root path [".concat(path, "], because it has no previous index."));
    }

    var last = path[path.length - 1];

    if (last <= 0) {
      throw new Error("Cannot get the previous path of a first child path [".concat(path, "] because it would result in a negative index."));
    }

    return path.slice(0, -1).concat(last - 1);
  },

  /**
   * Get a path relative to an ancestor.
   */
  relative(path, ancestor) {
    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {
      throw new Error("Cannot get the relative path of [".concat(path, "] inside ancestor [").concat(ancestor, "], because it is not above or equal to the path."));
    }

    return path.slice(ancestor.length);
  },

  /**
   * Transform a path by an operation.
   */
  transform(path, operation) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return fn(path, p => {
      var {
        affinity = 'forward'
      } = options; // PERF: Exit early if the operation is guaranteed not to have an effect.

      if (!path || (path === null || path === void 0 ? void 0 : path.length) === 0) {
        return;
      }

      if (p === null) {
        return null;
      }

      switch (operation.type) {
        case 'insert_node':
          {
            var {
              path: op
            } = operation;

            if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {
              p[op.length - 1] += 1;
            }

            break;
          }

        case 'remove_node':
          {
            var {
              path: _op
            } = operation;

            if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {
              return null;
            } else if (Path.endsBefore(_op, p)) {
              p[_op.length - 1] -= 1;
            }

            break;
          }

        case 'merge_node':
          {
            var {
              path: _op2,
              position
            } = operation;

            if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {
              p[_op2.length - 1] -= 1;
            } else if (Path.isAncestor(_op2, p)) {
              p[_op2.length - 1] -= 1;
              p[_op2.length] += position;
            }

            break;
          }

        case 'split_node':
          {
            var {
              path: _op3,
              position: _position
            } = operation;

            if (Path.equals(_op3, p)) {
              if (affinity === 'forward') {
                p[p.length - 1] += 1;
              } else if (affinity === 'backward') ; else {
                return null;
              }
            } else if (Path.endsBefore(_op3, p)) {
              p[_op3.length - 1] += 1;
            } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {
              p[_op3.length - 1] += 1;
              p[_op3.length] -= _position;
            }

            break;
          }

        case 'move_node':
          {
            var {
              path: _op4,
              newPath: onp
            } = operation; // If the old and new path are the same, it's a no-op.

            if (Path.equals(_op4, onp)) {
              return;
            }

            if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {
              var copy = onp.slice();

              if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {
                copy[_op4.length - 1] -= 1;
              }

              return copy.concat(p.slice(_op4.length));
            } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {
              if (Path.endsBefore(_op4, p)) {
                p[_op4.length - 1] -= 1;
              } else {
                p[_op4.length - 1] += 1;
              }
            } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {
              if (Path.endsBefore(_op4, p)) {
                p[_op4.length - 1] -= 1;
              }

              p[onp.length - 1] += 1;
            } else if (Path.endsBefore(_op4, p)) {
              if (Path.equals(onp, p)) {
                p[onp.length - 1] += 1;
              }

              p[_op4.length - 1] -= 1;
            }

            break;
          }
      }
    });
  }

};

var PathRef = {
  /**
   * Transform the path ref's current value by an operation.
   */
  transform(ref, op) {
    var {
      current,
      affinity
    } = ref;

    if (current == null) {
      return;
    }

    var path = Path.transform(current, op, {
      affinity
    });
    ref.current = path;

    if (path == null) {
      ref.unref();
    }
  }

};

function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var Point = {
  /**
   * Compare a point to another, returning an integer indicating whether the
   * point was before, at, or after the other.
   */
  compare(point, another) {
    var result = Path.compare(point.path, another.path);

    if (result === 0) {
      if (point.offset < another.offset) return -1;
      if (point.offset > another.offset) return 1;
      return 0;
    }

    return result;
  },

  /**
   * Check if a point is after another.
   */
  isAfter(point, another) {
    return Point.compare(point, another) === 1;
  },

  /**
   * Check if a point is before another.
   */
  isBefore(point, another) {
    return Point.compare(point, another) === -1;
  },

  /**
   * Check if a point is exactly equal to another.
   */
  equals(point, another) {
    // PERF: ensure the offsets are equal first since they are cheaper to check.
    return point.offset === another.offset && Path.equals(point.path, another.path);
  },

  /**
   * Check if a value implements the `Point` interface.
   */
  isPoint(value) {
    return isPlainObject(value) && typeof value.offset === 'number' && Path.isPath(value.path);
  },

  /**
   * Transform a point by an operation.
   */
  transform(point, op) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return fn(point, p => {
      if (p === null) {
        return null;
      }

      var {
        affinity = 'forward'
      } = options;
      var {
        path,
        offset
      } = p;

      switch (op.type) {
        case 'insert_node':
        case 'move_node':
          {
            p.path = Path.transform(path, op, options);
            break;
          }

        case 'insert_text':
          {
            if (Path.equals(op.path, path) && (op.offset < offset || op.offset === offset && affinity === 'forward')) {
              p.offset += op.text.length;
            }

            break;
          }

        case 'merge_node':
          {
            if (Path.equals(op.path, path)) {
              p.offset += op.position;
            }

            p.path = Path.transform(path, op, options);
            break;
          }

        case 'remove_text':
          {
            if (Path.equals(op.path, path) && op.offset <= offset) {
              p.offset -= Math.min(offset - op.offset, op.text.length);
            }

            break;
          }

        case 'remove_node':
          {
            if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {
              return null;
            }

            p.path = Path.transform(path, op, options);
            break;
          }

        case 'split_node':
          {
            if (Path.equals(op.path, path)) {
              if (op.position === offset && affinity == null) {
                return null;
              } else if (op.position < offset || op.position === offset && affinity === 'forward') {
                p.offset -= op.position;
                p.path = Path.transform(path, op, _objectSpread$6(_objectSpread$6({}, options), {}, {
                  affinity: 'forward'
                }));
              }
            } else {
              p.path = Path.transform(path, op, options);
            }

            break;
          }
      }
    });
  }

};

var PointRef = {
  /**
   * Transform the point ref's current value by an operation.
   */
  transform(ref, op) {
    var {
      current,
      affinity
    } = ref;

    if (current == null) {
      return;
    }

    var point = Point.transform(current, op, {
      affinity
    });
    ref.current = point;

    if (point == null) {
      ref.unref();
    }
  }

};

var _excluded$2$1 = ["anchor", "focus"];

function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var Range = {
  /**
   * Get the start and end points of a range, in the order in which they appear
   * in the document.
   */
  edges(range) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      reverse = false
    } = options;
    var {
      anchor,
      focus
    } = range;
    return Range.isBackward(range) === reverse ? [anchor, focus] : [focus, anchor];
  },

  /**
   * Get the end point of a range.
   */
  end(range) {
    var [, end] = Range.edges(range);
    return end;
  },

  /**
   * Check if a range is exactly equal to another.
   */
  equals(range, another) {
    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);
  },

  /**
   * Check if a range includes a path, a point or part of another range.
   */
  includes(range, target) {
    if (Range.isRange(target)) {
      if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {
        return true;
      }

      var [rs, re] = Range.edges(range);
      var [ts, te] = Range.edges(target);
      return Point.isBefore(rs, ts) && Point.isAfter(re, te);
    }

    var [start, end] = Range.edges(range);
    var isAfterStart = false;
    var isBeforeEnd = false;

    if (Point.isPoint(target)) {
      isAfterStart = Point.compare(target, start) >= 0;
      isBeforeEnd = Point.compare(target, end) <= 0;
    } else {
      isAfterStart = Path.compare(target, start.path) >= 0;
      isBeforeEnd = Path.compare(target, end.path) <= 0;
    }

    return isAfterStart && isBeforeEnd;
  },

  /**
   * Get the intersection of a range with another.
   */
  intersection(range, another) {
    var rest = _objectWithoutProperties$1(range, _excluded$2$1);

    var [s1, e1] = Range.edges(range);
    var [s2, e2] = Range.edges(another);
    var start = Point.isBefore(s1, s2) ? s2 : s1;
    var end = Point.isBefore(e1, e2) ? e1 : e2;

    if (Point.isBefore(end, start)) {
      return null;
    } else {
      return _objectSpread$5({
        anchor: start,
        focus: end
      }, rest);
    }
  },

  /**
   * Check if a range is backward, meaning that its anchor point appears in the
   * document _after_ its focus point.
   */
  isBackward(range) {
    var {
      anchor,
      focus
    } = range;
    return Point.isAfter(anchor, focus);
  },

  /**
   * Check if a range is collapsed, meaning that both its anchor and focus
   * points refer to the exact same position in the document.
   */
  isCollapsed(range) {
    var {
      anchor,
      focus
    } = range;
    return Point.equals(anchor, focus);
  },

  /**
   * Check if a range is expanded.
   *
   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.
   */
  isExpanded(range) {
    return !Range.isCollapsed(range);
  },

  /**
   * Check if a range is forward.
   *
   * This is the opposite of [[Range.isBackward]] and is provided for legibility.
   */
  isForward(range) {
    return !Range.isBackward(range);
  },

  /**
   * Check if a value implements the [[Range]] interface.
   */
  isRange(value) {
    return isPlainObject(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);
  },

  /**
   * Iterate through all of the point entries in a range.
   */
  *points(range) {
    yield [range.anchor, 'anchor'];
    yield [range.focus, 'focus'];
  },

  /**
   * Get the start point of a range.
   */
  start(range) {
    var [start] = Range.edges(range);
    return start;
  },

  /**
   * Transform a range by an operation.
   */
  transform(range, op) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return fn(range, r => {
      if (r === null) {
        return null;
      }

      var {
        affinity = 'inward'
      } = options;
      var affinityAnchor;
      var affinityFocus;

      if (affinity === 'inward') {
        // If the range is collapsed, make sure to use the same affinity to
        // avoid the two points passing each other and expanding in the opposite
        // direction
        var isCollapsed = Range.isCollapsed(r);

        if (Range.isForward(r)) {
          affinityAnchor = 'forward';
          affinityFocus = isCollapsed ? affinityAnchor : 'backward';
        } else {
          affinityAnchor = 'backward';
          affinityFocus = isCollapsed ? affinityAnchor : 'forward';
        }
      } else if (affinity === 'outward') {
        if (Range.isForward(r)) {
          affinityAnchor = 'backward';
          affinityFocus = 'forward';
        } else {
          affinityAnchor = 'forward';
          affinityFocus = 'backward';
        }
      } else {
        affinityAnchor = affinity;
        affinityFocus = affinity;
      }

      var anchor = Point.transform(r.anchor, op, {
        affinity: affinityAnchor
      });
      var focus = Point.transform(r.focus, op, {
        affinity: affinityFocus
      });

      if (!anchor || !focus) {
        return null;
      }

      r.anchor = anchor;
      r.focus = focus;
    });
  }

};

var RangeRef = {
  /**
   * Transform the range ref's current value by an operation.
   */
  transform(ref, op) {
    var {
      current,
      affinity
    } = ref;

    if (current == null) {
      return;
    }

    var path = Range.transform(current, op, {
      affinity
    });
    ref.current = path;

    if (path == null) {
      ref.unref();
    }
  }

};

/*
  Custom deep equal comparison for Slate nodes.

  We don't need general purpose deep equality;
  Slate only supports plain values, Arrays, and nested objects.
  Complex values nested inside Arrays are not supported.

  Slate objects are designed to be serialised, so
  missing keys are deliberately normalised to undefined.
 */

var isDeepEqual = (node, another) => {
  for (var key in node) {
    var a = node[key];
    var b = another[key];

    if (isPlainObject(a) && isPlainObject(b)) {
      if (!isDeepEqual(a, b)) return false;
    } else if (Array.isArray(a) && Array.isArray(b)) {
      if (a.length !== b.length) return false;

      for (var i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) return false;
      }
    } else if (a !== b) {
      return false;
    }
  }
  /*
    Deep object equality is only necessary in one direction; in the reverse direction
    we are only looking for keys that are missing.
    As above, undefined keys are normalised to missing.
  */


  for (var _key in another) {
    if (node[_key] === undefined && another[_key] !== undefined) {
      return false;
    }
  }

  return true;
};

var _excluded$1$1 = ["text"],
    _excluded2$1 = ["anchor", "focus"];

function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var Text$1 = {
  /**
   * Check if two text nodes are equal.
   *
   * When loose is set, the text is not compared. This is
   * used to check whether sibling text nodes can be merged.
   */
  equals(text, another) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      loose = false
    } = options;

    function omitText(obj) {
      var rest = _objectWithoutProperties$1(obj, _excluded$1$1);

      return rest;
    }

    return isDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);
  },

  /**
   * Check if a value implements the `Text` interface.
   */
  isText(value) {
    return isPlainObject(value) && typeof value.text === 'string';
  },

  /**
   * Check if a value is a list of `Text` objects.
   */
  isTextList(value) {
    return Array.isArray(value) && value.every(val => Text$1.isText(val));
  },

  /**
   * Check if some props are a partial of Text.
   */
  isTextProps(props) {
    return props.text !== undefined;
  },

  /**
   * Check if an text matches set of properties.
   *
   * Note: this is for matching custom properties, and it does not ensure that
   * the `text` property are two nodes equal.
   */
  matches(text, props) {
    for (var key in props) {
      if (key === 'text') {
        continue;
      }

      if (!text.hasOwnProperty(key) || text[key] !== props[key]) {
        return false;
      }
    }

    return true;
  },

  /**
   * Get the leaves for a text node given decorations.
   */
  decorations(node, decorations) {
    var leaves = [_objectSpread$4({}, node)];

    for (var dec of decorations) {
      var rest = _objectWithoutProperties$1(dec, _excluded2$1);

      var [start, end] = Range.edges(dec);
      var next = [];
      var o = 0;

      for (var leaf of leaves) {
        var {
          length
        } = leaf.text;
        var offset = o;
        o += length; // If the range encompases the entire leaf, add the range.

        if (start.offset <= offset && end.offset >= o) {
          Object.assign(leaf, rest);
          next.push(leaf);
          continue;
        } // If the range expanded and match the leaf, or starts after, or ends before it, continue.


        if (start.offset !== end.offset && (start.offset === o || end.offset === offset) || start.offset > o || end.offset < offset || end.offset === offset && offset !== 0) {
          next.push(leaf);
          continue;
        } // Otherwise we need to split the leaf, at the start, end, or both,
        // and add the range to the middle intersecting section. Do the end
        // split first since we don't need to update the offset that way.


        var middle = leaf;
        var before = void 0;
        var after = void 0;

        if (end.offset < o) {
          var off = end.offset - offset;
          after = _objectSpread$4(_objectSpread$4({}, middle), {}, {
            text: middle.text.slice(off)
          });
          middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {
            text: middle.text.slice(0, off)
          });
        }

        if (start.offset > offset) {
          var _off = start.offset - offset;

          before = _objectSpread$4(_objectSpread$4({}, middle), {}, {
            text: middle.text.slice(0, _off)
          });
          middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {
            text: middle.text.slice(_off)
          });
        }

        Object.assign(middle, rest);

        if (before) {
          next.push(before);
        }

        next.push(middle);

        if (after) {
          next.push(after);
        }
      }

      leaves = next;
    }

    return leaves;
  }

};

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var applyToDraft = (editor, selection, op) => {
  switch (op.type) {
    case 'insert_node':
      {
        var {
          path,
          node
        } = op;
        var parent = Node.parent(editor, path);
        var index = path[path.length - 1];

        if (index > parent.children.length) {
          throw new Error("Cannot apply an \"insert_node\" operation at path [".concat(path, "] because the destination is past the end of the node."));
        }

        parent.children.splice(index, 0, node);

        if (selection) {
          for (var [point, key] of Range.points(selection)) {
            selection[key] = Point.transform(point, op);
          }
        }

        break;
      }

    case 'insert_text':
      {
        var {
          path: _path,
          offset,
          text
        } = op;
        if (text.length === 0) break;

        var _node = Node.leaf(editor, _path);

        var before = _node.text.slice(0, offset);

        var after = _node.text.slice(offset);

        _node.text = before + text + after;

        if (selection) {
          for (var [_point, _key] of Range.points(selection)) {
            selection[_key] = Point.transform(_point, op);
          }
        }

        break;
      }

    case 'merge_node':
      {
        var {
          path: _path2
        } = op;

        var _node2 = Node.get(editor, _path2);

        var prevPath = Path.previous(_path2);
        var prev = Node.get(editor, prevPath);

        var _parent = Node.parent(editor, _path2);

        var _index = _path2[_path2.length - 1];

        if (Text$1.isText(_node2) && Text$1.isText(prev)) {
          prev.text += _node2.text;
        } else if (!Text$1.isText(_node2) && !Text$1.isText(prev)) {
          prev.children.push(..._node2.children);
        } else {
          throw new Error("Cannot apply a \"merge_node\" operation at path [".concat(_path2, "] to nodes of different interfaces: ").concat(_node2, " ").concat(prev));
        }

        _parent.children.splice(_index, 1);

        if (selection) {
          for (var [_point2, _key2] of Range.points(selection)) {
            selection[_key2] = Point.transform(_point2, op);
          }
        }

        break;
      }

    case 'move_node':
      {
        var {
          path: _path3,
          newPath
        } = op;

        if (Path.isAncestor(_path3, newPath)) {
          throw new Error("Cannot move a path [".concat(_path3, "] to new path [").concat(newPath, "] because the destination is inside itself."));
        }

        var _node3 = Node.get(editor, _path3);

        var _parent2 = Node.parent(editor, _path3);

        var _index2 = _path3[_path3.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to
        // the same snapshot in time, there's a mismatch. After either
        // removing the original position, the second step's path can be out
        // of date. So instead of using the `op.newPath` directly, we
        // transform `op.path` to ascertain what the `newPath` would be after
        // the operation was applied.

        _parent2.children.splice(_index2, 1);

        var truePath = Path.transform(_path3, op);
        var newParent = Node.get(editor, Path.parent(truePath));
        var newIndex = truePath[truePath.length - 1];
        newParent.children.splice(newIndex, 0, _node3);

        if (selection) {
          for (var [_point3, _key3] of Range.points(selection)) {
            selection[_key3] = Point.transform(_point3, op);
          }
        }

        break;
      }

    case 'remove_node':
      {
        var {
          path: _path4
        } = op;
        var _index3 = _path4[_path4.length - 1];

        var _parent3 = Node.parent(editor, _path4);

        _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the
        // node that was removed we need to update the range or remove it.


        if (selection) {
          for (var [_point4, _key4] of Range.points(selection)) {
            var result = Point.transform(_point4, op);

            if (selection != null && result != null) {
              selection[_key4] = result;
            } else {
              var _prev = void 0;

              var next = void 0;

              for (var [n, p] of Node.texts(editor)) {
                if (Path.compare(p, _path4) === -1) {
                  _prev = [n, p];
                } else {
                  next = [n, p];
                  break;
                }
              }

              var preferNext = false;

              if (_prev && next) {
                if (Path.equals(next[1], _path4)) {
                  preferNext = !Path.hasPrevious(next[1]);
                } else {
                  preferNext = Path.common(_prev[1], _path4).length < Path.common(next[1], _path4).length;
                }
              }

              if (_prev && !preferNext) {
                _point4.path = _prev[1];
                _point4.offset = _prev[0].text.length;
              } else if (next) {
                _point4.path = next[1];
                _point4.offset = 0;
              } else {
                selection = null;
              }
            }
          }
        }

        break;
      }

    case 'remove_text':
      {
        var {
          path: _path5,
          offset: _offset,
          text: _text
        } = op;
        if (_text.length === 0) break;

        var _node4 = Node.leaf(editor, _path5);

        var _before = _node4.text.slice(0, _offset);

        var _after = _node4.text.slice(_offset + _text.length);

        _node4.text = _before + _after;

        if (selection) {
          for (var [_point5, _key5] of Range.points(selection)) {
            selection[_key5] = Point.transform(_point5, op);
          }
        }

        break;
      }

    case 'set_node':
      {
        var {
          path: _path6,
          properties,
          newProperties
        } = op;

        if (_path6.length === 0) {
          throw new Error("Cannot set properties on the root node!");
        }

        var _node5 = Node.get(editor, _path6);

        for (var _key6 in newProperties) {
          if (_key6 === 'children' || _key6 === 'text') {
            throw new Error("Cannot set the \"".concat(_key6, "\" property of nodes!"));
          }

          var value = newProperties[_key6];

          if (value == null) {
            delete _node5[_key6];
          } else {
            _node5[_key6] = value;
          }
        } // properties that were previously defined, but are now missing, must be deleted


        for (var _key7 in properties) {
          if (!newProperties.hasOwnProperty(_key7)) {
            delete _node5[_key7];
          }
        }

        break;
      }

    case 'set_selection':
      {
        var {
          newProperties: _newProperties
        } = op;

        if (_newProperties == null) {
          selection = _newProperties;
        } else {
          if (selection == null) {
            if (!Range.isRange(_newProperties)) {
              throw new Error("Cannot apply an incomplete \"set_selection\" operation properties ".concat(JSON.stringify(_newProperties), " when there is no current selection."));
            }

            selection = _objectSpread$3({}, _newProperties);
          }

          for (var _key8 in _newProperties) {
            var _value = _newProperties[_key8];

            if (_value == null) {
              if (_key8 === 'anchor' || _key8 === 'focus') {
                throw new Error("Cannot remove the \"".concat(_key8, "\" selection property"));
              }

              delete selection[_key8];
            } else {
              selection[_key8] = _value;
            }
          }
        }

        break;
      }

    case 'split_node':
      {
        var {
          path: _path7,
          position,
          properties: _properties
        } = op;

        if (_path7.length === 0) {
          throw new Error("Cannot apply a \"split_node\" operation at path [".concat(_path7, "] because the root node cannot be split."));
        }

        var _node6 = Node.get(editor, _path7);

        var _parent4 = Node.parent(editor, _path7);

        var _index4 = _path7[_path7.length - 1];
        var newNode;

        if (Text$1.isText(_node6)) {
          var _before2 = _node6.text.slice(0, position);

          var _after2 = _node6.text.slice(position);

          _node6.text = _before2;
          newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {
            text: _after2
          });
        } else {
          var _before3 = _node6.children.slice(0, position);

          var _after3 = _node6.children.slice(position);

          _node6.children = _before3;
          newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {
            children: _after3
          });
        }

        _parent4.children.splice(_index4 + 1, 0, newNode);

        if (selection) {
          for (var [_point6, _key9] of Range.points(selection)) {
            selection[_key9] = Point.transform(_point6, op);
          }
        }

        break;
      }
  }

  return selection;
};

var GeneralTransforms = {
  /**
   * Transform the editor by an operation.
   */
  transform(editor, op) {
    editor.children = ln(editor.children);
    var selection = editor.selection && ln(editor.selection);

    try {
      selection = applyToDraft(editor, selection, op);
    } finally {
      editor.children = dn(editor.children);

      if (selection) {
        editor.selection = r$2(selection) ? dn(selection) : selection;
      } else {
        editor.selection = null;
      }
    }
  }

};

var _excluded$5 = ["text"],
    _excluded2$4 = ["children"];

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var NodeTransforms = {
  /**
   * Insert nodes at a specific location in the Editor.
   */
  insertNodes(editor, nodes) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Editor$1.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false,
        mode = 'lowest'
      } = options;
      var {
        at,
        match,
        select
      } = options;

      if (Node.isNode(nodes)) {
        nodes = [nodes];
      }

      if (nodes.length === 0) {
        return;
      }

      var [node] = nodes; // By default, use the selection as the target location. But if there is
      // no selection, insert at the end of the document since that is such a
      // common use case when inserting from a non-selected state.

      if (!at) {
        if (editor.selection) {
          at = editor.selection;
        } else if (editor.children.length > 0) {
          at = Editor$1.end(editor, []);
        } else {
          at = [0];
        }

        select = true;
      }

      if (select == null) {
        select = false;
      }

      if (Range.isRange(at)) {
        if (!hanging) {
          at = Editor$1.unhangRange(editor, at);
        }

        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var [, end] = Range.edges(at);
          var pointRef = Editor$1.pointRef(editor, end);
          Transforms.delete(editor, {
            at
          });
          at = pointRef.unref();
        }
      }

      if (Point.isPoint(at)) {
        if (match == null) {
          if (Text$1.isText(node)) {
            match = n => Text$1.isText(n);
          } else if (editor.isInline(node)) {
            match = n => Text$1.isText(n) || Editor$1.isInline(editor, n);
          } else {
            match = n => Editor$1.isBlock(editor, n);
          }
        }

        var [entry] = Editor$1.nodes(editor, {
          at: at.path,
          match,
          mode,
          voids
        });

        if (entry) {
          var [, _matchPath] = entry;
          var pathRef = Editor$1.pathRef(editor, _matchPath);
          var isAtEnd = Editor$1.isEnd(editor, at, _matchPath);
          Transforms.splitNodes(editor, {
            at,
            match,
            mode,
            voids
          });
          var path = pathRef.unref();
          at = isAtEnd ? Path.next(path) : path;
        } else {
          return;
        }
      }

      var parentPath = Path.parent(at);
      var index = at[at.length - 1];

      if (!voids && Editor$1.void(editor, {
        at: parentPath
      })) {
        return;
      }

      for (var _node of nodes) {
        var _path = parentPath.concat(index);

        index++;
        editor.apply({
          type: 'insert_node',
          path: _path,
          node: _node
        });
        at = Path.next(at);
      }

      at = Path.previous(at);

      if (select) {
        var point = Editor$1.end(editor, at);

        if (point) {
          Transforms.select(editor, point);
        }
      }
    });
  },

  /**
   * Lift nodes at a specific location upwards in the document tree, splitting
   * their parent in two if necessary.
   */
  liftNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor$1.withoutNormalizing(editor, () => {
      var {
        at = editor.selection,
        mode = 'lowest',
        voids = false
      } = options;
      var {
        match
      } = options;

      if (match == null) {
        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor$1.isBlock(editor, n);
      }

      if (!at) {
        return;
      }

      var matches = Editor$1.nodes(editor, {
        at,
        match,
        mode,
        voids
      });
      var pathRefs = Array.from(matches, _ref => {
        var [, p] = _ref;
        return Editor$1.pathRef(editor, p);
      });

      for (var pathRef of pathRefs) {
        var path = pathRef.unref();

        if (path.length < 2) {
          throw new Error("Cannot lift node at a path [".concat(path, "] because it has a depth of less than `2`."));
        }

        var parentNodeEntry = Editor$1.node(editor, Path.parent(path));
        var [parent, parentPath] = parentNodeEntry;
        var index = path[path.length - 1];
        var {
          length
        } = parent.children;

        if (length === 1) {
          var toPath = Path.next(parentPath);
          Transforms.moveNodes(editor, {
            at: path,
            to: toPath,
            voids
          });
          Transforms.removeNodes(editor, {
            at: parentPath,
            voids
          });
        } else if (index === 0) {
          Transforms.moveNodes(editor, {
            at: path,
            to: parentPath,
            voids
          });
        } else if (index === length - 1) {
          var _toPath = Path.next(parentPath);

          Transforms.moveNodes(editor, {
            at: path,
            to: _toPath,
            voids
          });
        } else {
          var splitPath = Path.next(path);

          var _toPath2 = Path.next(parentPath);

          Transforms.splitNodes(editor, {
            at: splitPath,
            voids
          });
          Transforms.moveNodes(editor, {
            at: path,
            to: _toPath2,
            voids
          });
        }
      }
    });
  },

  /**
   * Merge a node at a location with the previous node of the same depth,
   * removing any empty containing nodes after the merge if necessary.
   */
  mergeNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor$1.withoutNormalizing(editor, () => {
      var {
        match,
        at = editor.selection
      } = options;
      var {
        hanging = false,
        voids = false,
        mode = 'lowest'
      } = options;

      if (!at) {
        return;
      }

      if (match == null) {
        if (Path.isPath(at)) {
          var [parent] = Editor$1.parent(editor, at);

          match = n => parent.children.includes(n);
        } else {
          match = n => Editor$1.isBlock(editor, n);
        }
      }

      if (!hanging && Range.isRange(at)) {
        at = Editor$1.unhangRange(editor, at);
      }

      if (Range.isRange(at)) {
        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var [, end] = Range.edges(at);
          var pointRef = Editor$1.pointRef(editor, end);
          Transforms.delete(editor, {
            at
          });
          at = pointRef.unref();

          if (options.at == null) {
            Transforms.select(editor, at);
          }
        }
      }

      var [current] = Editor$1.nodes(editor, {
        at,
        match,
        voids,
        mode
      });
      var prev = Editor$1.previous(editor, {
        at,
        match,
        voids,
        mode
      });

      if (!current || !prev) {
        return;
      }

      var [node, path] = current;
      var [prevNode, prevPath] = prev;

      if (path.length === 0 || prevPath.length === 0) {
        return;
      }

      var newPath = Path.next(prevPath);
      var commonPath = Path.common(path, prevPath);
      var isPreviousSibling = Path.isSibling(path, prevPath);
      var levels = Array.from(Editor$1.levels(editor, {
        at: path
      }), _ref2 => {
        var [n] = _ref2;
        return n;
      }).slice(commonPath.length).slice(0, -1); // Determine if the merge will leave an ancestor of the path empty as a
      // result, in which case we'll want to remove it after merging.

      var emptyAncestor = Editor$1.above(editor, {
        at: path,
        mode: 'highest',
        match: n => levels.includes(n) && hasSingleChildNest(editor, n)
      });
      var emptyRef = emptyAncestor && Editor$1.pathRef(editor, emptyAncestor[1]);
      var properties;
      var position; // Ensure that the nodes are equivalent, and figure out what the position
      // and extra properties of the merge will be.

      if (Text$1.isText(node) && Text$1.isText(prevNode)) {
        var rest = _objectWithoutProperties$1(node, _excluded$5);

        position = prevNode.text.length;
        properties = rest;
      } else if (Element$1.isElement(node) && Element$1.isElement(prevNode)) {
        var rest = _objectWithoutProperties$1(node, _excluded2$4);

        position = prevNode.children.length;
        properties = rest;
      } else {
        throw new Error("Cannot merge the node at path [".concat(path, "] with the previous sibling because it is not the same kind: ").concat(JSON.stringify(node), " ").concat(JSON.stringify(prevNode)));
      } // If the node isn't already the next sibling of the previous node, move
      // it so that it is before merging.


      if (!isPreviousSibling) {
        Transforms.moveNodes(editor, {
          at: path,
          to: newPath,
          voids
        });
      } // If there was going to be an empty ancestor of the node that was merged,
      // we remove it from the tree.


      if (emptyRef) {
        Transforms.removeNodes(editor, {
          at: emptyRef.current,
          voids
        });
      } // If the target node that we're merging with is empty, remove it instead
      // of merging the two. This is a common rich text editor behavior to
      // prevent losing formatting when deleting entire nodes when you have a
      // hanging selection.
      // if prevNode is first child in parent,don't remove it.


      if (Element$1.isElement(prevNode) && Editor$1.isEmpty(editor, prevNode) || Text$1.isText(prevNode) && prevNode.text === '' && prevPath[prevPath.length - 1] !== 0) {
        Transforms.removeNodes(editor, {
          at: prevPath,
          voids
        });
      } else {
        editor.apply({
          type: 'merge_node',
          path: newPath,
          position,
          properties
        });
      }

      if (emptyRef) {
        emptyRef.unref();
      }
    });
  },

  /**
   * Move the nodes at a location to a new location.
   */
  moveNodes(editor, options) {
    Editor$1.withoutNormalizing(editor, () => {
      var {
        to,
        at = editor.selection,
        mode = 'lowest',
        voids = false
      } = options;
      var {
        match
      } = options;

      if (!at) {
        return;
      }

      if (match == null) {
        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor$1.isBlock(editor, n);
      }

      var toRef = Editor$1.pathRef(editor, to);
      var targets = Editor$1.nodes(editor, {
        at,
        match,
        mode,
        voids
      });
      var pathRefs = Array.from(targets, _ref3 => {
        var [, p] = _ref3;
        return Editor$1.pathRef(editor, p);
      });

      for (var pathRef of pathRefs) {
        var path = pathRef.unref();
        var newPath = toRef.current;

        if (path.length !== 0) {
          editor.apply({
            type: 'move_node',
            path,
            newPath
          });
        }

        if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {
          // When performing a sibling move to a later index, the path at the destination is shifted
          // to before the insertion point instead of after. To ensure our group of nodes are inserted
          // in the correct order we increment toRef to account for that
          toRef.current = Path.next(toRef.current);
        }
      }

      toRef.unref();
    });
  },

  /**
   * Remove the nodes at a specific location in the document.
   */
  removeNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor$1.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false,
        mode = 'lowest'
      } = options;
      var {
        at = editor.selection,
        match
      } = options;

      if (!at) {
        return;
      }

      if (match == null) {
        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor$1.isBlock(editor, n);
      }

      if (!hanging && Range.isRange(at)) {
        at = Editor$1.unhangRange(editor, at);
      }

      var depths = Editor$1.nodes(editor, {
        at,
        match,
        mode,
        voids
      });
      var pathRefs = Array.from(depths, _ref4 => {
        var [, p] = _ref4;
        return Editor$1.pathRef(editor, p);
      });

      for (var pathRef of pathRefs) {
        var path = pathRef.unref();

        if (path) {
          var [node] = Editor$1.node(editor, path);
          editor.apply({
            type: 'remove_node',
            path,
            node
          });
        }
      }
    });
  },

  /**
   * Set new properties on the nodes at a location.
   */
  setNodes(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Editor$1.withoutNormalizing(editor, () => {
      var {
        match,
        at = editor.selection,
        compare,
        merge
      } = options;
      var {
        hanging = false,
        mode = 'lowest',
        split = false,
        voids = false
      } = options;

      if (!at) {
        return;
      }

      if (match == null) {
        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor$1.isBlock(editor, n);
      }

      if (!hanging && Range.isRange(at)) {
        at = Editor$1.unhangRange(editor, at);
      }

      if (split && Range.isRange(at)) {
        if (Range.isCollapsed(at) && Editor$1.leaf(editor, at.anchor)[0].text.length > 0) {
          // If the range is collapsed in a non-empty node and 'split' is true, there's nothing to
          // set that won't get normalized away
          return;
        }

        var rangeRef = Editor$1.rangeRef(editor, at, {
          affinity: 'inward'
        });
        var [start, end] = Range.edges(at);
        var splitMode = mode === 'lowest' ? 'lowest' : 'highest';
        var endAtEndOfNode = Editor$1.isEnd(editor, end, end.path);
        Transforms.splitNodes(editor, {
          at: end,
          match,
          mode: splitMode,
          voids,
          always: !endAtEndOfNode
        });
        var startAtStartOfNode = Editor$1.isStart(editor, start, start.path);
        Transforms.splitNodes(editor, {
          at: start,
          match,
          mode: splitMode,
          voids,
          always: !startAtStartOfNode
        });
        at = rangeRef.unref();

        if (options.at == null) {
          Transforms.select(editor, at);
        }
      }

      if (!compare) {
        compare = (prop, nodeProp) => prop !== nodeProp;
      }

      for (var [node, path] of Editor$1.nodes(editor, {
        at,
        match,
        mode,
        voids
      })) {
        var properties = {};
        var newProperties = {}; // You can't set properties on the editor node.

        if (path.length === 0) {
          continue;
        }

        var hasChanges = false;

        for (var k in props) {
          if (k === 'children' || k === 'text') {
            continue;
          }

          if (compare(props[k], node[k])) {
            hasChanges = true; // Omit new properties from the old properties list

            if (node.hasOwnProperty(k)) properties[k] = node[k]; // Omit properties that have been removed from the new properties list

            if (merge) {
              if (props[k] != null) newProperties[k] = merge(node[k], props[k]);
            } else {
              if (props[k] != null) newProperties[k] = props[k];
            }
          }
        }

        if (hasChanges) {
          editor.apply({
            type: 'set_node',
            path,
            properties,
            newProperties
          });
        }
      }
    });
  },

  /**
   * Split the nodes at a specific location.
   */
  splitNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor$1.withoutNormalizing(editor, () => {
      var {
        mode = 'lowest',
        voids = false
      } = options;
      var {
        match,
        at = editor.selection,
        height = 0,
        always = false
      } = options;

      if (match == null) {
        match = n => Editor$1.isBlock(editor, n);
      }

      if (Range.isRange(at)) {
        at = deleteRange(editor, at);
      } // If the target is a path, the default height-skipping and position
      // counters need to account for us potentially splitting at a non-leaf.


      if (Path.isPath(at)) {
        var path = at;
        var point = Editor$1.point(editor, path);
        var [parent] = Editor$1.parent(editor, path);

        match = n => n === parent;

        height = point.path.length - path.length + 1;
        at = point;
        always = true;
      }

      if (!at) {
        return;
      }

      var beforeRef = Editor$1.pointRef(editor, at, {
        affinity: 'backward'
      });
      var afterRef;

      try {
        var [highest] = Editor$1.nodes(editor, {
          at,
          match,
          mode,
          voids
        });

        if (!highest) {
          return;
        }

        var voidMatch = Editor$1.void(editor, {
          at,
          mode: 'highest'
        });
        var nudge = 0;

        if (!voids && voidMatch) {
          var [voidNode, voidPath] = voidMatch;

          if (Element$1.isElement(voidNode) && editor.isInline(voidNode)) {
            var after = Editor$1.after(editor, voidPath);

            if (!after) {
              var text = {
                text: ''
              };
              var afterPath = Path.next(voidPath);
              Transforms.insertNodes(editor, text, {
                at: afterPath,
                voids
              });
              after = Editor$1.point(editor, afterPath);
            }

            at = after;
            always = true;
          }

          var siblingHeight = at.path.length - voidPath.length;
          height = siblingHeight + 1;
          always = true;
        }

        afterRef = Editor$1.pointRef(editor, at);
        var depth = at.path.length - height;
        var [, highestPath] = highest;
        var lowestPath = at.path.slice(0, depth);
        var position = height === 0 ? at.offset : at.path[depth] + nudge;

        for (var [node, _path2] of Editor$1.levels(editor, {
          at: lowestPath,
          reverse: true,
          voids
        })) {
          var split = false;

          if (_path2.length < highestPath.length || _path2.length === 0 || !voids && Editor$1.isVoid(editor, node)) {
            break;
          }

          var _point = beforeRef.current;
          var isEnd = Editor$1.isEnd(editor, _point, _path2);

          if (always || !beforeRef || !Editor$1.isEdge(editor, _point, _path2)) {
            split = true;
            var properties = Node.extractProps(node);
            editor.apply({
              type: 'split_node',
              path: _path2,
              position,
              properties
            });
          }

          position = _path2[_path2.length - 1] + (split || isEnd ? 1 : 0);
        }

        if (options.at == null) {
          var _point2 = afterRef.current || Editor$1.end(editor, []);

          Transforms.select(editor, _point2);
        }
      } finally {
        var _afterRef;

        beforeRef.unref();
        (_afterRef = afterRef) === null || _afterRef === void 0 ? void 0 : _afterRef.unref();
      }
    });
  },

  /**
   * Unset properties on the nodes at a location.
   */
  unsetNodes(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (!Array.isArray(props)) {
      props = [props];
    }

    var obj = {};

    for (var key of props) {
      obj[key] = null;
    }

    Transforms.setNodes(editor, obj, options);
  },

  /**
   * Unwrap the nodes at a location from a parent node, splitting the parent if
   * necessary to ensure that only the content in the range is unwrapped.
   */
  unwrapNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor$1.withoutNormalizing(editor, () => {
      var {
        mode = 'lowest',
        split = false,
        voids = false
      } = options;
      var {
        at = editor.selection,
        match
      } = options;

      if (!at) {
        return;
      }

      if (match == null) {
        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor$1.isBlock(editor, n);
      }

      if (Path.isPath(at)) {
        at = Editor$1.range(editor, at);
      }

      var rangeRef = Range.isRange(at) ? Editor$1.rangeRef(editor, at) : null;
      var matches = Editor$1.nodes(editor, {
        at,
        match,
        mode,
        voids
      });
      var pathRefs = Array.from(matches, _ref5 => {
        var [, p] = _ref5;
        return Editor$1.pathRef(editor, p);
      } // unwrapNode will call liftNode which does not support splitting the node when nested.
      // If we do not reverse the order and call it from top to the bottom, it will remove all blocks
      // that wrap target node. So we reverse the order.
      ).reverse();

      var _loop = function _loop(pathRef) {
        var path = pathRef.unref();
        var [node] = Editor$1.node(editor, path);
        var range = Editor$1.range(editor, path);

        if (split && rangeRef) {
          range = Range.intersection(rangeRef.current, range);
        }

        Transforms.liftNodes(editor, {
          at: range,
          match: n => Element$1.isAncestor(node) && node.children.includes(n),
          voids
        });
      };

      for (var pathRef of pathRefs) {
        _loop(pathRef);
      }

      if (rangeRef) {
        rangeRef.unref();
      }
    });
  },

  /**
   * Wrap the nodes at a location in a new container node, splitting the edges
   * of the range first to ensure that only the content in the range is wrapped.
   */
  wrapNodes(editor, element) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Editor$1.withoutNormalizing(editor, () => {
      var {
        mode = 'lowest',
        split = false,
        voids = false
      } = options;
      var {
        match,
        at = editor.selection
      } = options;

      if (!at) {
        return;
      }

      if (match == null) {
        if (Path.isPath(at)) {
          match = matchPath(editor, at);
        } else if (editor.isInline(element)) {
          match = n => Editor$1.isInline(editor, n) || Text$1.isText(n);
        } else {
          match = n => Editor$1.isBlock(editor, n);
        }
      }

      if (split && Range.isRange(at)) {
        var [start, end] = Range.edges(at);
        var rangeRef = Editor$1.rangeRef(editor, at, {
          affinity: 'inward'
        });
        Transforms.splitNodes(editor, {
          at: end,
          match,
          voids
        });
        Transforms.splitNodes(editor, {
          at: start,
          match,
          voids
        });
        at = rangeRef.unref();

        if (options.at == null) {
          Transforms.select(editor, at);
        }
      }

      var roots = Array.from(Editor$1.nodes(editor, {
        at,
        match: editor.isInline(element) ? n => Editor$1.isBlock(editor, n) : n => Editor$1.isEditor(n),
        mode: 'lowest',
        voids
      }));

      for (var [, rootPath] of roots) {
        var a = Range.isRange(at) ? Range.intersection(at, Editor$1.range(editor, rootPath)) : at;

        if (!a) {
          continue;
        }

        var matches = Array.from(Editor$1.nodes(editor, {
          at: a,
          match,
          mode,
          voids
        }));

        if (matches.length > 0) {
          var _ret = function () {
            var [first] = matches;
            var last = matches[matches.length - 1];
            var [, firstPath] = first;
            var [, lastPath] = last;

            if (firstPath.length === 0 && lastPath.length === 0) {
              // if there's no matching parent - usually means the node is an editor - don't do anything
              return "continue";
            }

            var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);
            var range = Editor$1.range(editor, firstPath, lastPath);
            var commonNodeEntry = Editor$1.node(editor, commonPath);
            var [commonNode] = commonNodeEntry;
            var depth = commonPath.length + 1;
            var wrapperPath = Path.next(lastPath.slice(0, depth));

            var wrapper = _objectSpread$2(_objectSpread$2({}, element), {}, {
              children: []
            });

            Transforms.insertNodes(editor, wrapper, {
              at: wrapperPath,
              voids
            });
            Transforms.moveNodes(editor, {
              at: range,
              match: n => Element$1.isAncestor(commonNode) && commonNode.children.includes(n),
              to: wrapperPath.concat(0),
              voids
            });
          }();

          if (_ret === "continue") continue;
        }
      }
    });
  }

};

var hasSingleChildNest = (editor, node) => {
  if (Element$1.isElement(node)) {
    var element = node;

    if (Editor$1.isVoid(editor, node)) {
      return true;
    } else if (element.children.length === 1) {
      return hasSingleChildNest(editor, element.children[0]);
    } else {
      return false;
    }
  } else if (Editor$1.isEditor(node)) {
    return false;
  } else {
    return true;
  }
};
/**
 * Convert a range into a point by deleting it's content.
 */


var deleteRange = (editor, range) => {
  if (Range.isCollapsed(range)) {
    return range.anchor;
  } else {
    var [, end] = Range.edges(range);
    var pointRef = Editor$1.pointRef(editor, end);
    Transforms.delete(editor, {
      at: range
    });
    return pointRef.unref();
  }
};

var matchPath = (editor, path) => {
  var [node] = Editor$1.node(editor, path);
  return n => n === node;
};

function ownKeys$1$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1$1(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var SelectionTransforms = {
  /**
   * Collapse the selection.
   */
  collapse(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      edge = 'anchor'
    } = options;
    var {
      selection
    } = editor;

    if (!selection) {
      return;
    } else if (edge === 'anchor') {
      Transforms.select(editor, selection.anchor);
    } else if (edge === 'focus') {
      Transforms.select(editor, selection.focus);
    } else if (edge === 'start') {
      var [start] = Range.edges(selection);
      Transforms.select(editor, start);
    } else if (edge === 'end') {
      var [, end] = Range.edges(selection);
      Transforms.select(editor, end);
    }
  },

  /**
   * Unset the selection.
   */
  deselect(editor) {
    var {
      selection
    } = editor;

    if (selection) {
      editor.apply({
        type: 'set_selection',
        properties: selection,
        newProperties: null
      });
    }
  },

  /**
   * Move the selection's point forward or backward.
   */
  move(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      selection
    } = editor;
    var {
      distance = 1,
      unit = 'character',
      reverse = false
    } = options;
    var {
      edge = null
    } = options;

    if (!selection) {
      return;
    }

    if (edge === 'start') {
      edge = Range.isBackward(selection) ? 'focus' : 'anchor';
    }

    if (edge === 'end') {
      edge = Range.isBackward(selection) ? 'anchor' : 'focus';
    }

    var {
      anchor,
      focus
    } = selection;
    var opts = {
      distance,
      unit
    };
    var props = {};

    if (edge == null || edge === 'anchor') {
      var point = reverse ? Editor$1.before(editor, anchor, opts) : Editor$1.after(editor, anchor, opts);

      if (point) {
        props.anchor = point;
      }
    }

    if (edge == null || edge === 'focus') {
      var _point = reverse ? Editor$1.before(editor, focus, opts) : Editor$1.after(editor, focus, opts);

      if (_point) {
        props.focus = _point;
      }
    }

    Transforms.setSelection(editor, props);
  },

  /**
   * Set the selection to a new value.
   */
  select(editor, target) {
    var {
      selection
    } = editor;
    target = Editor$1.range(editor, target);

    if (selection) {
      Transforms.setSelection(editor, target);
      return;
    }

    if (!Range.isRange(target)) {
      throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(JSON.stringify(target)));
    }

    editor.apply({
      type: 'set_selection',
      properties: selection,
      newProperties: target
    });
  },

  /**
   * Set new properties on one of the selection's points.
   */
  setPoint(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      selection
    } = editor;
    var {
      edge = 'both'
    } = options;

    if (!selection) {
      return;
    }

    if (edge === 'start') {
      edge = Range.isBackward(selection) ? 'focus' : 'anchor';
    }

    if (edge === 'end') {
      edge = Range.isBackward(selection) ? 'anchor' : 'focus';
    }

    var {
      anchor,
      focus
    } = selection;
    var point = edge === 'anchor' ? anchor : focus;
    Transforms.setSelection(editor, {
      [edge === 'anchor' ? 'anchor' : 'focus']: _objectSpread$1$1(_objectSpread$1$1({}, point), props)
    });
  },

  /**
   * Set new properties on the selection.
   */
  setSelection(editor, props) {
    var {
      selection
    } = editor;
    var oldProps = {};
    var newProps = {};

    if (!selection) {
      return;
    }

    for (var k in props) {
      if (k === 'anchor' && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === 'focus' && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== 'anchor' && k !== 'focus' && props[k] !== selection[k]) {
        oldProps[k] = selection[k];
        newProps[k] = props[k];
      }
    }

    if (Object.keys(oldProps).length > 0) {
      editor.apply({
        type: 'set_selection',
        properties: oldProps,
        newProperties: newProps
      });
    }
  }

};

var TextTransforms = {
  /**
   * Delete content in the editor.
   */
  delete(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor$1.withoutNormalizing(editor, () => {
      var {
        reverse = false,
        unit = 'character',
        distance = 1,
        voids = false
      } = options;
      var {
        at = editor.selection,
        hanging = false
      } = options;

      if (!at) {
        return;
      }

      if (Range.isRange(at) && Range.isCollapsed(at)) {
        at = at.anchor;
      }

      if (Point.isPoint(at)) {
        var furthestVoid = Editor$1.void(editor, {
          at,
          mode: 'highest'
        });

        if (!voids && furthestVoid) {
          var [, voidPath] = furthestVoid;
          at = voidPath;
        } else {
          var opts = {
            unit,
            distance
          };
          var target = reverse ? Editor$1.before(editor, at, opts) || Editor$1.start(editor, []) : Editor$1.after(editor, at, opts) || Editor$1.end(editor, []);
          at = {
            anchor: at,
            focus: target
          };
          hanging = true;
        }
      }

      if (Path.isPath(at)) {
        Transforms.removeNodes(editor, {
          at,
          voids
        });
        return;
      }

      if (Range.isCollapsed(at)) {
        return;
      }

      if (!hanging) {
        var [, _end] = Range.edges(at);
        var endOfDoc = Editor$1.end(editor, []);

        if (!Point.equals(_end, endOfDoc)) {
          at = Editor$1.unhangRange(editor, at, {
            voids
          });
        }
      }

      var [start, end] = Range.edges(at);
      var startBlock = Editor$1.above(editor, {
        match: n => Editor$1.isBlock(editor, n),
        at: start,
        voids
      });
      var endBlock = Editor$1.above(editor, {
        match: n => Editor$1.isBlock(editor, n),
        at: end,
        voids
      });
      var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);
      var isSingleText = Path.equals(start.path, end.path);
      var startVoid = voids ? null : Editor$1.void(editor, {
        at: start,
        mode: 'highest'
      });
      var endVoid = voids ? null : Editor$1.void(editor, {
        at: end,
        mode: 'highest'
      }); // If the start or end points are inside an inline void, nudge them out.

      if (startVoid) {
        var before = Editor$1.before(editor, start);

        if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {
          start = before;
        }
      }

      if (endVoid) {
        var after = Editor$1.after(editor, end);

        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {
          end = after;
        }
      } // Get the highest nodes that are completely inside the range, as well as
      // the start and end nodes.


      var matches = [];
      var lastPath;

      for (var entry of Editor$1.nodes(editor, {
        at,
        voids
      })) {
        var [node, path] = entry;

        if (lastPath && Path.compare(path, lastPath) === 0) {
          continue;
        }

        if (!voids && Editor$1.isVoid(editor, node) || !Path.isCommon(path, start.path) && !Path.isCommon(path, end.path)) {
          matches.push(entry);
          lastPath = path;
        }
      }

      var pathRefs = Array.from(matches, _ref => {
        var [, p] = _ref;
        return Editor$1.pathRef(editor, p);
      });
      var startRef = Editor$1.pointRef(editor, start);
      var endRef = Editor$1.pointRef(editor, end);

      if (!isSingleText && !startVoid) {
        var _point = startRef.current;
        var [_node] = Editor$1.leaf(editor, _point);
        var {
          path: _path
        } = _point;
        var {
          offset
        } = start;

        var text = _node.text.slice(offset);

        if (text.length > 0) editor.apply({
          type: 'remove_text',
          path: _path,
          offset,
          text
        });
      }

      for (var pathRef of pathRefs) {
        var _path2 = pathRef.unref();

        Transforms.removeNodes(editor, {
          at: _path2,
          voids
        });
      }

      if (!endVoid) {
        var _point2 = endRef.current;
        var [_node2] = Editor$1.leaf(editor, _point2);
        var {
          path: _path3
        } = _point2;

        var _offset = isSingleText ? start.offset : 0;

        var _text = _node2.text.slice(_offset, end.offset);

        if (_text.length > 0) editor.apply({
          type: 'remove_text',
          path: _path3,
          offset: _offset,
          text: _text
        });
      }

      if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {
        Transforms.mergeNodes(editor, {
          at: endRef.current,
          hanging: true,
          voids
        });
      }

      var startUnref = startRef.unref();
      var endUnref = endRef.unref();
      var point = reverse ? startUnref || endUnref : endUnref || startUnref;

      if (options.at == null && point) {
        Transforms.select(editor, point);
      }
    });
  },

  /**
   * Insert a fragment at a specific location in the editor.
   */
  insertFragment(editor, fragment) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Editor$1.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false
      } = options;
      var {
        at = editor.selection
      } = options;

      if (!fragment.length) {
        return;
      }

      if (!at) {
        return;
      } else if (Range.isRange(at)) {
        if (!hanging) {
          at = Editor$1.unhangRange(editor, at);
        }

        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var [, end] = Range.edges(at);

          if (!voids && Editor$1.void(editor, {
            at: end
          })) {
            return;
          }

          var pointRef = Editor$1.pointRef(editor, end);
          Transforms.delete(editor, {
            at
          });
          at = pointRef.unref();
        }
      } else if (Path.isPath(at)) {
        at = Editor$1.start(editor, at);
      }

      if (!voids && Editor$1.void(editor, {
        at
      })) {
        return;
      } // If the insert point is at the edge of an inline node, move it outside
      // instead since it will need to be split otherwise.


      var inlineElementMatch = Editor$1.above(editor, {
        at,
        match: n => Editor$1.isInline(editor, n),
        mode: 'highest',
        voids
      });

      if (inlineElementMatch) {
        var [, _inlinePath] = inlineElementMatch;

        if (Editor$1.isEnd(editor, at, _inlinePath)) {
          var after = Editor$1.after(editor, _inlinePath);
          at = after;
        } else if (Editor$1.isStart(editor, at, _inlinePath)) {
          var before = Editor$1.before(editor, _inlinePath);
          at = before;
        }
      }

      var blockMatch = Editor$1.above(editor, {
        match: n => Editor$1.isBlock(editor, n),
        at,
        voids
      });
      var [, blockPath] = blockMatch;
      var isBlockStart = Editor$1.isStart(editor, at, blockPath);
      var isBlockEnd = Editor$1.isEnd(editor, at, blockPath);
      var isBlockEmpty = isBlockStart && isBlockEnd;
      var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;
      var mergeEnd = !isBlockEnd;
      var [, firstPath] = Node.first({
        children: fragment
      }, []);
      var [, lastPath] = Node.last({
        children: fragment
      }, []);
      var matches = [];

      var matcher = _ref2 => {
        var [n, p] = _ref2;
        var isRoot = p.length === 0;

        if (isRoot) {
          return false;
        }

        if (isBlockEmpty) {
          return true;
        }

        if (mergeStart && Path.isAncestor(p, firstPath) && Element$1.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {
          return false;
        }

        if (mergeEnd && Path.isAncestor(p, lastPath) && Element$1.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {
          return false;
        }

        return true;
      };

      for (var entry of Node.nodes({
        children: fragment
      }, {
        pass: matcher
      })) {
        if (matcher(entry)) {
          matches.push(entry);
        }
      }

      var starts = [];
      var middles = [];
      var ends = [];
      var starting = true;
      var hasBlocks = false;

      for (var [node] of matches) {
        if (Element$1.isElement(node) && !editor.isInline(node)) {
          starting = false;
          hasBlocks = true;
          middles.push(node);
        } else if (starting) {
          starts.push(node);
        } else {
          ends.push(node);
        }
      }

      var [inlineMatch] = Editor$1.nodes(editor, {
        at,
        match: n => Text$1.isText(n) || Editor$1.isInline(editor, n),
        mode: 'highest',
        voids
      });
      var [, inlinePath] = inlineMatch;
      var isInlineStart = Editor$1.isStart(editor, at, inlinePath);
      var isInlineEnd = Editor$1.isEnd(editor, at, inlinePath);
      var middleRef = Editor$1.pathRef(editor, isBlockEnd ? Path.next(blockPath) : blockPath);
      var endRef = Editor$1.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);
      var blockPathRef = Editor$1.pathRef(editor, blockPath);
      Transforms.splitNodes(editor, {
        at,
        match: n => hasBlocks ? Editor$1.isBlock(editor, n) : Text$1.isText(n) || Editor$1.isInline(editor, n),
        mode: hasBlocks ? 'lowest' : 'highest',
        voids
      });
      var startRef = Editor$1.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);
      Transforms.insertNodes(editor, starts, {
        at: startRef.current,
        match: n => Text$1.isText(n) || Editor$1.isInline(editor, n),
        mode: 'highest',
        voids
      });

      if (isBlockEmpty && middles.length) {
        Transforms.delete(editor, {
          at: blockPathRef.unref(),
          voids
        });
      }

      Transforms.insertNodes(editor, middles, {
        at: middleRef.current,
        match: n => Editor$1.isBlock(editor, n),
        mode: 'lowest',
        voids
      });
      Transforms.insertNodes(editor, ends, {
        at: endRef.current,
        match: n => Text$1.isText(n) || Editor$1.isInline(editor, n),
        mode: 'highest',
        voids
      });

      if (!options.at) {
        var path;

        if (ends.length > 0) {
          path = Path.previous(endRef.current);
        } else if (middles.length > 0) {
          path = Path.previous(middleRef.current);
        } else {
          path = Path.previous(startRef.current);
        }

        var _end2 = Editor$1.end(editor, path);

        Transforms.select(editor, _end2);
      }

      startRef.unref();
      middleRef.unref();
      endRef.unref();
    });
  },

  /**
   * Insert a string of text in the Editor.
   */
  insertText(editor, text) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Editor$1.withoutNormalizing(editor, () => {
      var {
        voids = false
      } = options;
      var {
        at = editor.selection
      } = options;

      if (!at) {
        return;
      }

      if (Path.isPath(at)) {
        at = Editor$1.range(editor, at);
      }

      if (Range.isRange(at)) {
        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var end = Range.end(at);

          if (!voids && Editor$1.void(editor, {
            at: end
          })) {
            return;
          }

          var pointRef = Editor$1.pointRef(editor, end);
          Transforms.delete(editor, {
            at,
            voids
          });
          at = pointRef.unref();
          Transforms.setSelection(editor, {
            anchor: at,
            focus: at
          });
        }
      }

      if (!voids && Editor$1.void(editor, {
        at
      })) {
        return;
      }

      var {
        path,
        offset
      } = at;
      if (text.length > 0) editor.apply({
        type: 'insert_text',
        path,
        offset,
        text
      });
    });
  }

};

function ownKeys$a(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$a(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$a(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$a(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var Transforms = _objectSpread$a(_objectSpread$a(_objectSpread$a(_objectSpread$a({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);

var direction_1 = direction;

var RTL = '\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC';
var LTR =
  'A-Za-z\u00C0-\u00D6\u00D8-\u00F6' +
  '\u00F8-\u02B8\u0300-\u0590\u0800-\u1FFF\u200E\u2C00-\uFB1C' +
  '\uFE00-\uFE6F\uFEFD-\uFFFF';

var rtl = new RegExp('^[^' + LTR + ']*[' + RTL + ']');
var ltr = new RegExp('^[^' + RTL + ']*[' + LTR + ']');

function direction(value) {
  value = String(value || '');

  if (rtl.test(value)) {
    return 'rtl'
  }

  if (ltr.test(value)) {
    return 'ltr'
  }

  return 'neutral'
}

function t$1(t){return "object"==typeof t&&null!=t&&1===t.nodeType}function e(t,e){return (!e||"hidden"!==t)&&"visible"!==t&&"clip"!==t}function n$2(t,n){if(t.clientHeight<t.scrollHeight||t.clientWidth<t.scrollWidth){var r=getComputedStyle(t,null);return e(r.overflowY,n)||e(r.overflowX,n)||function(t){var e=function(t){if(!t.ownerDocument||!t.ownerDocument.defaultView)return null;try{return t.ownerDocument.defaultView.frameElement}catch(t){return null}}(t);return !!e&&(e.clientHeight<t.scrollHeight||e.clientWidth<t.scrollWidth)}(t)}return !1}function r$1(t,e,n,r,i,o,l,d){return o<t&&l>e||o>t&&l<e?0:o<=t&&d<=n||l>=e&&d>=n?o-t-r:l>e&&d<n||o<t&&d>n?l-e+i:0}var i$1=function(e,i){var o=window,l=i.scrollMode,d=i.block,f=i.inline,h=i.boundary,u=i.skipOverflowHiddenElements,s="function"==typeof h?h:function(t){return t!==h};if(!t$1(e))throw new TypeError("Invalid target");for(var a,c,g=document.scrollingElement||document.documentElement,p=[],m=e;t$1(m)&&s(m);){if((m=null==(c=(a=m).parentElement)?a.getRootNode().host||null:c)===g){p.push(m);break}null!=m&&m===document.body&&n$2(m)&&!n$2(document.documentElement)||null!=m&&n$2(m,u)&&p.push(m);}for(var w=o.visualViewport?o.visualViewport.width:innerWidth,v=o.visualViewport?o.visualViewport.height:innerHeight,W=window.scrollX||pageXOffset,H=window.scrollY||pageYOffset,b=e.getBoundingClientRect(),y=b.height,E=b.width,M=b.top,V=b.right,x=b.bottom,I=b.left,C="start"===d||"nearest"===d?M:"end"===d?x:M+y/2,R="center"===f?I+E/2:"end"===f?V:I,T=[],k=0;k<p.length;k++){var B=p[k],D=B.getBoundingClientRect(),O=D.height,X=D.width,Y=D.top,L=D.right,S=D.bottom,j=D.left;if("if-needed"===l&&M>=0&&I>=0&&x<=v&&V<=w&&M>=Y&&x<=S&&I>=j&&V<=L)return T;var N=getComputedStyle(B),q=parseInt(N.borderLeftWidth,10),z=parseInt(N.borderTopWidth,10),A=parseInt(N.borderRightWidth,10),F=parseInt(N.borderBottomWidth,10),G=0,J=0,K="offsetWidth"in B?B.offsetWidth-B.clientWidth-q-A:0,P="offsetHeight"in B?B.offsetHeight-B.clientHeight-z-F:0,Q="offsetWidth"in B?0===B.offsetWidth?0:X/B.offsetWidth:0,U="offsetHeight"in B?0===B.offsetHeight?0:O/B.offsetHeight:0;if(g===B)G="start"===d?C:"end"===d?C-v:"nearest"===d?r$1(H,H+v,v,z,F,H+C,H+C+y,y):C-v/2,J="start"===f?R:"center"===f?R-w/2:"end"===f?R-w:r$1(W,W+w,w,q,A,W+R,W+R+E,E),G=Math.max(0,G+H),J=Math.max(0,J+W);else {G="start"===d?C-Y-z:"end"===d?C-S+F+P:"nearest"===d?r$1(Y,S,O,z,F+P,C,C+y,y):C-(Y+O/2)+P/2,J="start"===f?R-j-q:"center"===f?R-(j+X/2)+K/2:"end"===f?R-L+A+K:r$1(j,L,X,q,A+K,R,R+E,E);var Z=B.scrollLeft,$=B.scrollTop;C+=$-(G=Math.max(0,Math.min($+G/U,B.scrollHeight-O/U+P))),R+=Z-(J=Math.max(0,Math.min(Z+J/Q,B.scrollWidth-X/Q+K)));}T.push({el:B,top:G,left:J});}return T};

function isOptionsObject(options) {
  return options === Object(options) && Object.keys(options).length !== 0;
}
function defaultBehavior(actions, behavior) {
  if (behavior === void 0) {
    behavior = 'auto';
  }
  var canSmoothScroll = ('scrollBehavior' in document.body.style);
  actions.forEach(function (_ref) {
    var el = _ref.el,
      top = _ref.top,
      left = _ref.left;
    if (el.scroll && canSmoothScroll) {
      el.scroll({
        top: top,
        left: left,
        behavior: behavior
      });
    } else {
      el.scrollTop = top;
      el.scrollLeft = left;
    }
  });
}
function getOptions(options) {
  if (options === false) {
    return {
      block: 'end',
      inline: 'nearest'
    };
  }
  if (isOptionsObject(options)) {
    return options;
  }
  return {
    block: 'start',
    inline: 'nearest'
  };
}
function scrollIntoView(target, options) {
  var isTargetAttached = target.isConnected || target.ownerDocument.documentElement.contains(target);
  if (isOptionsObject(options) && typeof options.behavior === 'function') {
    return options.behavior(isTargetAttached ? i$1(target, options) : []);
  }
  if (!isTargetAttached) {
    return;
  }
  var computeOptions = getOptions(options);
  return defaultBehavior(i$1(target, computeOptions), computeOptions.behavior);
}

var lib$1 = {};

Object.defineProperty(lib$1, "__esModule", {
  value: true
});

/**
 * Constants.
 */

var IS_MAC = typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);

var MODIFIERS = {
  alt: 'altKey',
  control: 'ctrlKey',
  meta: 'metaKey',
  shift: 'shiftKey'
};

var ALIASES = {
  add: '+',
  break: 'pause',
  cmd: 'meta',
  command: 'meta',
  ctl: 'control',
  ctrl: 'control',
  del: 'delete',
  down: 'arrowdown',
  esc: 'escape',
  ins: 'insert',
  left: 'arrowleft',
  mod: IS_MAC ? 'meta' : 'control',
  opt: 'alt',
  option: 'alt',
  return: 'enter',
  right: 'arrowright',
  space: ' ',
  spacebar: ' ',
  up: 'arrowup',
  win: 'meta',
  windows: 'meta'
};

var CODES = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  ' ': 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ';': 186,
  '=': 187,
  ',': 188,
  '-': 189,
  '.': 190,
  '/': 191,
  '`': 192,
  '[': 219,
  '\\': 220,
  ']': 221,
  '\'': 222
};

for (var f$1 = 1; f$1 < 20; f$1++) {
  CODES['f' + f$1] = 111 + f$1;
}

/**
 * Is hotkey?
 */

function isHotkey(hotkey, options, event) {
  if (options && !('byKey' in options)) {
    event = options;
    options = null;
  }

  if (!Array.isArray(hotkey)) {
    hotkey = [hotkey];
  }

  var array = hotkey.map(function (string) {
    return parseHotkey(string, options);
  });
  var check = function check(e) {
    return array.some(function (object) {
      return compareHotkey(object, e);
    });
  };
  var ret = event == null ? check : check(event);
  return ret;
}

function isCodeHotkey(hotkey, event) {
  return isHotkey(hotkey, event);
}

function isKeyHotkey(hotkey, event) {
  return isHotkey(hotkey, { byKey: true }, event);
}

/**
 * Parse.
 */

function parseHotkey(hotkey, options) {
  var byKey = options && options.byKey;
  var ret = {};

  // Special case to handle the `+` key since we use it as a separator.
  hotkey = hotkey.replace('++', '+add');
  var values = hotkey.split('+');
  var length = values.length;

  // Ensure that all the modifiers are set to false unless the hotkey has them.

  for (var k in MODIFIERS) {
    ret[MODIFIERS[k]] = false;
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var value = _step.value;

      var optional = value.endsWith('?') && value.length > 1;

      if (optional) {
        value = value.slice(0, -1);
      }

      var name = toKeyName(value);
      var modifier = MODIFIERS[name];

      if (length === 1 || !modifier) {
        if (byKey) {
          ret.key = name;
        } else {
          ret.which = toKeyCode(value);
        }
      }

      if (modifier) {
        ret[modifier] = optional ? null : true;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return ret;
}

/**
 * Compare.
 */

function compareHotkey(object, event) {
  for (var key in object) {
    var expected = object[key];
    var actual = void 0;

    if (expected == null) {
      continue;
    }

    if (key === 'key' && event.key != null) {
      actual = event.key.toLowerCase();
    } else if (key === 'which') {
      actual = expected === 91 && event.which === 93 ? 91 : event.which;
    } else {
      actual = event[key];
    }

    if (actual == null && expected === false) {
      continue;
    }

    if (actual !== expected) {
      return false;
    }
  }

  return true;
}

/**
 * Utils.
 */

function toKeyCode(name) {
  name = toKeyName(name);
  var code = CODES[name] || name.toUpperCase().charCodeAt(0);
  return code;
}

function toKeyName(name) {
  name = name.toLowerCase();
  name = ALIASES[name] || name;
  return name;
}

/**
 * Export.
 */

lib$1.default = isHotkey;
lib$1.isHotkey = isHotkey;
lib$1.isCodeHotkey = isCodeHotkey;
var isKeyHotkey_1 = lib$1.isKeyHotkey = isKeyHotkey;
lib$1.parseHotkey = parseHotkey;
lib$1.compareHotkey = compareHotkey;
lib$1.toKeyCode = toKeyCode;
lib$1.toKeyName = toKeyName;

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var IS_REACT_VERSION_17_OR_ABOVE = parseInt(React__default.version.split('.')[0], 10) >= 17;
var IS_IOS = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var IS_APPLE = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent);
var IS_ANDROID = typeof navigator !== 'undefined' && /Android/.test(navigator.userAgent);
var IS_FIREFOX = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
var IS_SAFARI = typeof navigator !== 'undefined' && /Version\/[\d\.]+.*Safari/.test(navigator.userAgent); // "modern" Edge was released at 79.x

var IS_EDGE_LEGACY = typeof navigator !== 'undefined' && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent);
var IS_CHROME = typeof navigator !== 'undefined' && /Chrome/i.test(navigator.userAgent); // Native `beforeInput` events don't work well with react on Chrome 75
// and older, Chrome 76+ can use `beforeInput` though.

var IS_CHROME_LEGACY = typeof navigator !== 'undefined' && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent); // Firefox did not support `beforeInput` until `v87`.

var IS_FIREFOX_LEGACY = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent); // qq browser

var IS_QQBROWSER = typeof navigator !== 'undefined' && /.*QQBrowser/.test(navigator.userAgent); // UC mobile browser

var IS_UC_MOBILE = typeof navigator !== 'undefined' && /.*UCBrowser/.test(navigator.userAgent); // Wechat browser

var IS_WECHATBROWSER = typeof navigator !== 'undefined' && /.*Wechat/.test(navigator.userAgent); // Check if DOM is available as React does internally.
// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js

var CAN_USE_DOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined'); // COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event
// Chrome Legacy doesn't support `beforeinput` correctly

var HAS_BEFORE_INPUT_SUPPORT = !IS_CHROME_LEGACY && !IS_EDGE_LEGACY && // globalThis is undefined in older browsers
typeof globalThis !== 'undefined' && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.
typeof globalThis.InputEvent.prototype.getTargetRanges === 'function';

/**
 * Prevent warning on SSR by falling back to useEffect when DOM isn't available
 */

var useIsomorphicLayoutEffect = CAN_USE_DOM ? useLayoutEffect : useEffect;

/**
 * Leaf content strings.
 */

var String$1 = props => {
  var {
    isLast,
    leaf,
    parent,
    text
  } = props;
  var editor = useSlateStatic();
  var path = ReactEditor.findPath(editor, text);
  var parentPath = Path.parent(path); // COMPAT: Render text inside void nodes with a zero-width space.
  // So the node can contain selection but the text is not visible.

  if (editor.isVoid(parent)) {
    return /*#__PURE__*/React__default.createElement(ZeroWidthString, {
      length: Node.string(parent).length
    });
  } // COMPAT: If this is the last text node in an empty block, render a zero-
  // width space that will convert into a line break when copying and pasting
  // to support expected plain text.


  if (leaf.text === '' && parent.children[parent.children.length - 1] === text && !editor.isInline(parent) && Editor$1.string(editor, parentPath) === '') {
    return /*#__PURE__*/React__default.createElement(ZeroWidthString, {
      isLineBreak: true
    });
  } // COMPAT: If the text is empty, it's because it's on the edge of an inline
  // node, so we render a zero-width space so that the selection can be
  // inserted next to it still.


  if (leaf.text === '') {
    return /*#__PURE__*/React__default.createElement(ZeroWidthString, null);
  } // COMPAT: Browsers will collapse trailing new lines at the end of blocks,
  // so we need to add an extra trailing new lines to prevent that.


  if (isLast && leaf.text.slice(-1) === '\n') {
    return /*#__PURE__*/React__default.createElement(TextString, {
      isTrailing: true,
      text: leaf.text
    });
  }

  return /*#__PURE__*/React__default.createElement(TextString, {
    text: leaf.text
  });
};
/**
 * Leaf strings with text in them.
 */


var TextString = props => {
  var {
    text,
    isTrailing = false
  } = props;
  var ref = useRef(null);

  var getTextContent = () => {
    return "".concat(text !== null && text !== void 0 ? text : '').concat(isTrailing ? '\n' : '');
  }; // This is the actual text rendering boundary where we interface with the DOM
  // The text is not rendered as part of the virtual DOM, as since we handle basic character insertions natively,
  // updating the DOM is not a one way dataflow anymore. What we need here is not reconciliation and diffing
  // with previous version of the virtual DOM, but rather diffing with the actual DOM element, and replace the DOM <span> content
  // exactly if and only if its current content does not match our current virtual DOM.
  // Otherwise the DOM TextNode would always be replaced by React as the user types, which interferes with native text features,
  // eg makes native spellcheck opt out from checking the text node.
  // useLayoutEffect: updating our span before browser paint


  useIsomorphicLayoutEffect(() => {
    // null coalescing text to make sure we're not outputing "null" as a string in the extreme case it is nullish at runtime
    var textWithTrailing = getTextContent();

    if (ref.current && ref.current.textContent !== textWithTrailing) {
      ref.current.textContent = textWithTrailing;
    } // intentionally not specifying dependencies, so that this effect runs on every render
    // as this effectively replaces "specifying the text in the virtual DOM under the <span> below" on each render

  }); // Render text content immediately if it's the first-time render
  // Ensure that text content is rendered on server-side rendering

  if (!ref.current) {
    return /*#__PURE__*/React__default.createElement("span", {
      "data-slate-string": true,
      ref: ref
    }, getTextContent());
  } // the span is intentionally same on every render in virtual DOM, actual rendering happens in the layout effect above


  return /*#__PURE__*/React__default.createElement("span", {
    "data-slate-string": true,
    ref: ref
  });
};
/**
 * Leaf strings without text, render as zero-width strings.
 */


var ZeroWidthString = props => {
  var {
    length = 0,
    isLineBreak = false
  } = props;
  return /*#__PURE__*/React__default.createElement("span", {
    "data-slate-zero-width": isLineBreak ? 'n' : 'z',
    "data-slate-length": length
  }, '\uFEFF', isLineBreak ? /*#__PURE__*/React__default.createElement("br", null) : null);
};

/**
 * Two weak maps that allow us rebuild a path given a node. They are populated
 * at render time such that after a render occurs we can always backtrack.
 */
var NODE_TO_INDEX = new WeakMap();
var NODE_TO_PARENT = new WeakMap();
/**
 * Weak maps that allow us to go between Slate nodes and DOM nodes. These
 * are used to resolve DOM event-related logic into Slate actions.
 */

var EDITOR_TO_WINDOW = new WeakMap();
var EDITOR_TO_ELEMENT = new WeakMap();
var ELEMENT_TO_NODE = new WeakMap();
var NODE_TO_ELEMENT = new WeakMap();
var NODE_TO_KEY = new WeakMap();
var EDITOR_TO_KEY_TO_ELEMENT = new WeakMap();
/**
 * Weak maps for storing editor-related state.
 */

var IS_READ_ONLY = new WeakMap();
var IS_FOCUSED = new WeakMap();
var IS_COMPOSING = new WeakMap();
var IS_ON_COMPOSITION_END = new WeakMap();
var EDITOR_TO_USER_SELECTION = new WeakMap();
/**
 * Weak maps for saving text on composition stage.
 */

var EDITOR_ON_COMPOSITION_TEXT = new WeakMap();
/**
 * Weak map for associating the context `onChange` context with the plugin.
 */

var EDITOR_TO_ON_CHANGE = new WeakMap();
var NODE_TO_RESTORE_DOM = new WeakMap();
/**
 * Symbols.
 */

var PLACEHOLDER_SYMBOL = Symbol('placeholder');

/**
 * Individual leaves in a text node with unique formatting.
 */

var Leaf = props => {
  var {
    leaf,
    isLast,
    text,
    parent,
    renderPlaceholder,
    renderLeaf = props => /*#__PURE__*/React__default.createElement(DefaultLeaf, Object.assign({}, props))
  } = props;
  var placeholderRef = useRef(null);
  useEffect(() => {
    var placeholderEl = placeholderRef === null || placeholderRef === void 0 ? void 0 : placeholderRef.current;
    var editorEl = document.querySelector('[data-slate-editor="true"]');

    if (!placeholderEl || !editorEl) {
      return;
    }

    editorEl.style.minHeight = "".concat(placeholderEl.clientHeight, "px");
    return () => {
      editorEl.style.minHeight = 'auto';
    };
  }, [placeholderRef, leaf]);
  var children = /*#__PURE__*/React__default.createElement(String$1, {
    isLast: isLast,
    leaf: leaf,
    parent: parent,
    text: text
  });

  if (leaf[PLACEHOLDER_SYMBOL]) {
    var placeholderProps = {
      children: leaf.placeholder,
      attributes: {
        'data-slate-placeholder': true,
        style: {
          position: 'absolute',
          pointerEvents: 'none',
          width: '100%',
          maxWidth: '100%',
          display: 'block',
          opacity: '0.333',
          userSelect: 'none',
          textDecoration: 'none'
        },
        contentEditable: false,
        ref: placeholderRef
      }
    };
    children = /*#__PURE__*/React__default.createElement(React__default.Fragment, null, renderPlaceholder(placeholderProps), children);
  } // COMPAT: Having the `data-` attributes on these leaf elements ensures that
  // in certain misbehaving browsers they aren't weirdly cloned/destroyed by
  // contenteditable behaviors. (2019/05/08)


  var attributes = {
    'data-slate-leaf': true
  };
  return renderLeaf({
    attributes,
    children,
    leaf,
    text
  });
};

var MemoizedLeaf = /*#__PURE__*/React__default.memo(Leaf, (prev, next) => {
  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && Text$1.equals(next.leaf, prev.leaf) && next.leaf[PLACEHOLDER_SYMBOL] === prev.leaf[PLACEHOLDER_SYMBOL];
});
var DefaultLeaf = props => {
  var {
    attributes,
    children
  } = props;
  return /*#__PURE__*/React__default.createElement("span", Object.assign({}, attributes), children);
};

var _excluded$3 = ["anchor", "focus"],
    _excluded2 = ["anchor", "focus"];
var shallowCompare = (obj1, obj2) => Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every(key => obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);
/**
 * Check if a list of decorator ranges are equal to another.
 *
 * PERF: this requires the two lists to also have the ranges inside them in the
 * same order, but this is an okay constraint for us since decorations are
 * kept in order, and the odd case where they aren't is okay to re-render for.
 */

var isDecoratorRangeListEqual = (list, another) => {
  if (list.length !== another.length) {
    return false;
  }

  for (var i = 0; i < list.length; i++) {
    var range = list[i];
    var other = another[i];

    var rangeOwnProps = _objectWithoutProperties(range, _excluded$3);

    var otherOwnProps = _objectWithoutProperties(other, _excluded2);

    if (!Range.equals(range, other) || range[PLACEHOLDER_SYMBOL] !== other[PLACEHOLDER_SYMBOL] || !shallowCompare(rangeOwnProps, otherOwnProps)) {
      return false;
    }
  }

  return true;
};

function useContentKey(node) {
  var contentKeyRef = useRef(0);
  var updateAnimationFrameRef = useRef(null);
  var [, setForceRerenderCounter] = useState(0);
  useEffect(() => {
    NODE_TO_RESTORE_DOM.set(node, () => {
      // Update is already queued and node hasn't re-render yet
      if (updateAnimationFrameRef.current) {
        return;
      }

      updateAnimationFrameRef.current = requestAnimationFrame(() => {
        setForceRerenderCounter(state => state + 1);
        updateAnimationFrameRef.current = null;
      });
      contentKeyRef.current++;
    });
    return () => {
      NODE_TO_RESTORE_DOM.delete(node);
    };
  }, [node]); // Node was restored => clear scheduled update

  if (updateAnimationFrameRef.current) {
    cancelAnimationFrame(updateAnimationFrameRef.current);
    updateAnimationFrameRef.current = null;
  }

  return contentKeyRef.current;
}

/**
 * Text.
 */

var Text = props => {
  var {
    decorations,
    isLast,
    parent,
    renderPlaceholder,
    renderLeaf,
    text
  } = props;
  var editor = useSlateStatic();
  var ref = useRef(null);
  var leaves = Text$1.decorations(text, decorations);
  var key = ReactEditor.findKey(editor, text);
  var children = [];

  for (var i = 0; i < leaves.length; i++) {
    var leaf = leaves[i];
    children.push( /*#__PURE__*/React__default.createElement(MemoizedLeaf, {
      isLast: isLast && i === leaves.length - 1,
      key: "".concat(key.id, "-").concat(i),
      renderPlaceholder: renderPlaceholder,
      leaf: leaf,
      text: text,
      parent: parent,
      renderLeaf: renderLeaf
    }));
  } // Update element-related weak maps with the DOM element ref.


  useIsomorphicLayoutEffect(() => {
    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);

    if (ref.current) {
      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, ref.current);
      NODE_TO_ELEMENT.set(text, ref.current);
      ELEMENT_TO_NODE.set(ref.current, text);
    } else {
      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);
      NODE_TO_ELEMENT.delete(text);
    }
  });
  var contentKey = IS_ANDROID ? useContentKey(text) : undefined;
  return /*#__PURE__*/React__default.createElement("span", {
    "data-slate-node": "text",
    ref: ref,
    key: contentKey
  }, children);
};

var MemoizedText = /*#__PURE__*/React__default.memo(Text, (prev, next) => {
  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.text === prev.text && isDecoratorRangeListEqual(next.decorations, prev.decorations);
});

/**
 * Element.
 */

var Element = props => {
  var {
    decorations,
    element,
    renderElement = p => /*#__PURE__*/React__default.createElement(DefaultElement, Object.assign({}, p)),
    renderPlaceholder,
    renderLeaf,
    selection
  } = props;
  var ref = useRef(null);
  var editor = useSlateStatic();
  var readOnly = useReadOnly();
  var isInline = editor.isInline(element);
  var key = ReactEditor.findKey(editor, element);
  var children = useChildren({
    decorations,
    node: element,
    renderElement,
    renderPlaceholder,
    renderLeaf,
    selection
  }); // Attributes that the developer must mix into the element in their
  // custom node renderer component.

  var attributes = {
    'data-slate-node': 'element',
    ref
  };

  if (isInline) {
    attributes['data-slate-inline'] = true;
  } // If it's a block node with inline children, add the proper `dir` attribute
  // for text direction.


  if (!isInline && Editor$1.hasInlines(editor, element)) {
    var text = Node.string(element);
    var dir = direction_1(text);

    if (dir === 'rtl') {
      attributes.dir = dir;
    }
  } // If it's a void node, wrap the children in extra void-specific elements.


  if (Editor$1.isVoid(editor, element)) {
    attributes['data-slate-void'] = true;

    if (!readOnly && isInline) {
      attributes.contentEditable = false;
    }

    var Tag = isInline ? 'span' : 'div';
    var [[_text]] = Node.texts(element);
    children = /*#__PURE__*/React__default.createElement(Tag, {
      "data-slate-spacer": true,
      style: {
        height: '0',
        color: 'transparent',
        outline: 'none',
        position: 'absolute'
      }
    }, /*#__PURE__*/React__default.createElement(MemoizedText, {
      renderPlaceholder: renderPlaceholder,
      decorations: [],
      isLast: false,
      parent: element,
      text: _text
    }));
    NODE_TO_INDEX.set(_text, 0);
    NODE_TO_PARENT.set(_text, element);
  } // Update element-related weak maps with the DOM element ref.


  useIsomorphicLayoutEffect(() => {
    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);

    if (ref.current) {
      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, ref.current);
      NODE_TO_ELEMENT.set(element, ref.current);
      ELEMENT_TO_NODE.set(ref.current, element);
    } else {
      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);
      NODE_TO_ELEMENT.delete(element);
    }
  });
  var content = renderElement({
    attributes,
    children,
    element
  });

  if (IS_ANDROID) {
    var contentKey = useContentKey(element);
    return /*#__PURE__*/React__default.createElement(Fragment, {
      key: contentKey
    }, content);
  }

  return content;
};

var MemoizedElement = /*#__PURE__*/React__default.memo(Element, (prev, next) => {
  return prev.element === next.element && prev.renderElement === next.renderElement && prev.renderLeaf === next.renderLeaf && isDecoratorRangeListEqual(prev.decorations, next.decorations) && (prev.selection === next.selection || !!prev.selection && !!next.selection && Range.equals(prev.selection, next.selection));
});
/**
 * The default element renderer.
 */

var DefaultElement = props => {
  var {
    attributes,
    children,
    element
  } = props;
  var editor = useSlateStatic();
  var Tag = editor.isInline(element) ? 'span' : 'div';
  return /*#__PURE__*/React__default.createElement(Tag, Object.assign({}, attributes, {
    style: {
      position: 'relative'
    }
  }), children);
};

/**
 * A React context for sharing the editor object.
 */

var EditorContext = /*#__PURE__*/createContext(null);
/**
 * Get the current editor object from the React context.
 */

var useSlateStatic = () => {
  var editor = useContext(EditorContext);

  if (!editor) {
    throw new Error("The `useSlateStatic` hook must be used inside the <Slate> component's context.");
  }

  return editor;
};

/**
 * A React context for sharing the `selected` state of an element.
 */

var SelectedContext = /*#__PURE__*/createContext(false);

/**
 * Children.
 */

var useChildren = props => {
  var {
    decorations,
    node,
    renderElement,
    renderPlaceholder,
    renderLeaf,
    selection
  } = props;
  var editor = useSlateStatic();
  var path = ReactEditor.findPath(editor, node);
  var children = [];
  var isLeafBlock = Element$1.isElement(node) && !editor.isInline(node) && Editor$1.hasInlines(editor, node);

  var _loop = function _loop(i) {
    var p = path.concat(i);
    var n = node.children[i];
    var key = ReactEditor.findKey(editor, n);
    var range = Editor$1.range(editor, p);
    var sel = selection && Range.intersection(range, selection);
    var ds = decorations.reduce((acc, dec) => {
      var intersection = Range.intersection(dec, range);
      if (intersection) acc.push(intersection);
      return acc;
    }, []);

    if (Element$1.isElement(n)) {
      children.push( /*#__PURE__*/React__default.createElement(SelectedContext.Provider, {
        key: "provider-".concat(key.id),
        value: !!sel
      }, /*#__PURE__*/React__default.createElement(MemoizedElement, {
        decorations: ds,
        element: n,
        key: key.id,
        renderElement: renderElement,
        renderPlaceholder: renderPlaceholder,
        renderLeaf: renderLeaf,
        selection: sel
      })));
    } else {
      children.push( /*#__PURE__*/React__default.createElement(MemoizedText, {
        decorations: ds,
        key: key.id,
        isLast: isLeafBlock && i === node.children.length - 1,
        parent: node,
        renderPlaceholder: renderPlaceholder,
        renderLeaf: renderLeaf,
        text: n
      }));
    }

    NODE_TO_INDEX.set(n, i);
    NODE_TO_PARENT.set(n, node);
  };

  for (var i = 0; i < node.children.length; i++) {
    _loop(i);
  }

  return children;
};

/**
 * Hotkey mappings for each platform.
 */

var HOTKEYS = {
  bold: 'mod+b',
  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],
  moveBackward: 'left',
  moveForward: 'right',
  moveWordBackward: 'ctrl+left',
  moveWordForward: 'ctrl+right',
  deleteBackward: 'shift?+backspace',
  deleteForward: 'shift?+delete',
  extendBackward: 'shift+left',
  extendForward: 'shift+right',
  italic: 'mod+i',
  insertSoftBreak: 'shift+enter',
  splitBlock: 'enter',
  undo: 'mod+z'
};
var APPLE_HOTKEYS = {
  moveLineBackward: 'opt+up',
  moveLineForward: 'opt+down',
  moveWordBackward: 'opt+left',
  moveWordForward: 'opt+right',
  deleteBackward: ['ctrl+backspace', 'ctrl+h'],
  deleteForward: ['ctrl+delete', 'ctrl+d'],
  deleteLineBackward: 'cmd+shift?+backspace',
  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],
  deleteWordBackward: 'opt+shift?+backspace',
  deleteWordForward: 'opt+shift?+delete',
  extendLineBackward: 'opt+shift+up',
  extendLineForward: 'opt+shift+down',
  redo: 'cmd+shift+z',
  transposeCharacter: 'ctrl+t'
};
var WINDOWS_HOTKEYS = {
  deleteWordBackward: 'ctrl+shift?+backspace',
  deleteWordForward: 'ctrl+shift?+delete',
  redo: ['ctrl+y', 'ctrl+shift+z']
};
/**
 * Create a platform-aware hotkey checker.
 */

var create = key => {
  var generic = HOTKEYS[key];
  var apple = APPLE_HOTKEYS[key];
  var windows = WINDOWS_HOTKEYS[key];
  var isGeneric = generic && isKeyHotkey_1(generic);
  var isApple = apple && isKeyHotkey_1(apple);
  var isWindows = windows && isKeyHotkey_1(windows);
  return event => {
    if (isGeneric && isGeneric(event)) return true;
    if (IS_APPLE && isApple && isApple(event)) return true;
    if (!IS_APPLE && isWindows && isWindows(event)) return true;
    return false;
  };
};
/**
 * Hotkeys.
 */


var Hotkeys = {
  isBold: create('bold'),
  isCompose: create('compose'),
  isMoveBackward: create('moveBackward'),
  isMoveForward: create('moveForward'),
  isDeleteBackward: create('deleteBackward'),
  isDeleteForward: create('deleteForward'),
  isDeleteLineBackward: create('deleteLineBackward'),
  isDeleteLineForward: create('deleteLineForward'),
  isDeleteWordBackward: create('deleteWordBackward'),
  isDeleteWordForward: create('deleteWordForward'),
  isExtendBackward: create('extendBackward'),
  isExtendForward: create('extendForward'),
  isExtendLineBackward: create('extendLineBackward'),
  isExtendLineForward: create('extendLineForward'),
  isItalic: create('italic'),
  isMoveLineBackward: create('moveLineBackward'),
  isMoveLineForward: create('moveLineForward'),
  isMoveWordBackward: create('moveWordBackward'),
  isMoveWordForward: create('moveWordForward'),
  isRedo: create('redo'),
  isSoftBreak: create('insertSoftBreak'),
  isSplitBlock: create('splitBlock'),
  isTransposeCharacter: create('transposeCharacter'),
  isUndo: create('undo')
};

/**
 * A React context for sharing the `readOnly` state of the editor.
 */

var ReadOnlyContext = /*#__PURE__*/createContext(false);
/**
 * Get the current `readOnly` state of the editor.
 */

var useReadOnly = () => {
  return useContext(ReadOnlyContext);
};

/**
 * A React context for sharing the editor object, in a way that re-renders the
 * context whenever changes occur.
 */

var SlateContext = /*#__PURE__*/createContext(null);
/**
 * Get the current editor object from the React context.
 */

var useSlate = () => {
  var context = useContext(SlateContext);

  if (!context) {
    throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
  }

  var [editor] = context;
  return editor;
};

/**
 * A React context for sharing the `decorate` prop of the editable.
 */

var DecorateContext = /*#__PURE__*/createContext(() => []);

/**
 * Types.
 */
/**
 * Returns the host window of a DOM node
 */

var getDefaultView = value => {
  return value && value.ownerDocument && value.ownerDocument.defaultView || null;
};
/**
 * Check if a DOM node is a comment node.
 */

var isDOMComment = value => {
  return isDOMNode(value) && value.nodeType === 8;
};
/**
 * Check if a DOM node is an element node.
 */

var isDOMElement = value => {
  return isDOMNode(value) && value.nodeType === 1;
};
/**
 * Check if a value is a DOM node.
 */

var isDOMNode = value => {
  var window = getDefaultView(value);
  return !!window && value instanceof window.Node;
};
/**
 * Check if a value is a DOM selection.
 */

var isDOMSelection = value => {
  var window = value && value.anchorNode && getDefaultView(value.anchorNode);
  return !!window && value instanceof window.Selection;
};
/**
 * Check if a DOM node is an element node.
 */

var isDOMText = value => {
  return isDOMNode(value) && value.nodeType === 3;
};
/**
 * Checks whether a paste event is a plaintext-only event.
 */

var isPlainTextOnlyPaste = event => {
  return event.clipboardData && event.clipboardData.getData('text/plain') !== '' && event.clipboardData.types.length === 1;
};
/**
 * Normalize a DOM point so that it always refers to a text node.
 */

var normalizeDOMPoint = domPoint => {
  var [node, offset] = domPoint; // If it's an element node, its offset refers to the index of its children
  // including comment nodes, so try to find the right text child node.

  if (isDOMElement(node) && node.childNodes.length) {
    var isLast = offset === node.childNodes.length;
    var index = isLast ? offset - 1 : offset;
    [node, index] = getEditableChildAndIndex(node, index, isLast ? 'backward' : 'forward'); // If the editable child found is in front of input offset, we instead seek to its end

    isLast = index < offset; // If the node has children, traverse until we have a leaf node. Leaf nodes
    // can be either text nodes, or other void DOM nodes.

    while (isDOMElement(node) && node.childNodes.length) {
      var i = isLast ? node.childNodes.length - 1 : 0;
      node = getEditableChild(node, i, isLast ? 'backward' : 'forward');
    } // Determine the new offset inside the text node.


    offset = isLast && node.textContent != null ? node.textContent.length : 0;
  } // Return the node and offset.


  return [node, offset];
};
/**
 * Determines wether the active element is nested within a shadowRoot
 */

var hasShadowRoot = () => {
  return !!(window.document.activeElement && window.document.activeElement.shadowRoot);
};
/**
 * Get the nearest editable child and index at `index` in a `parent`, preferring
 * `direction`.
 */

var getEditableChildAndIndex = (parent, index, direction) => {
  var {
    childNodes
  } = parent;
  var child = childNodes[index];
  var i = index;
  var triedForward = false;
  var triedBackward = false; // While the child is a comment node, or an element node with no children,
  // keep iterating to find a sibling non-void, non-comment node.

  while (isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute('contenteditable') === 'false') {
    if (triedForward && triedBackward) {
      break;
    }

    if (i >= childNodes.length) {
      triedForward = true;
      i = index - 1;
      direction = 'backward';
      continue;
    }

    if (i < 0) {
      triedBackward = true;
      i = index + 1;
      direction = 'forward';
      continue;
    }

    child = childNodes[i];
    index = i;
    i += direction === 'forward' ? 1 : -1;
  }

  return [child, index];
};
/**
 * Get the nearest editable child at `index` in a `parent`, preferring
 * `direction`.
 */

var getEditableChild = (parent, index, direction) => {
  var [child] = getEditableChildAndIndex(parent, index, direction);
  return child;
};
/**
 * Get a plaintext representation of the content of a node, accounting for block
 * elements which get a newline appended.
 *
 * The domNode must be attached to the DOM.
 */

var getPlainText = domNode => {
  var text = '';

  if (isDOMText(domNode) && domNode.nodeValue) {
    return domNode.nodeValue;
  }

  if (isDOMElement(domNode)) {
    for (var childNode of Array.from(domNode.childNodes)) {
      text += getPlainText(childNode);
    }

    var display = getComputedStyle(domNode).getPropertyValue('display');

    if (display === 'block' || display === 'list' || domNode.tagName === 'BR') {
      text += '\n';
    }
  }

  return text;
};
/**
 * Get x-slate-fragment attribute from data-slate-fragment
 */

var catchSlateFragment = /data-slate-fragment="(.+?)"/m;
var getSlateFragmentAttribute = dataTransfer => {
  var htmlData = dataTransfer.getData('text/html');
  var [, fragment] = htmlData.match(catchSlateFragment) || [];
  return fragment;
};
/**
 * Get the x-slate-fragment attribute that exist in text/html data
 * and append it to the DataTransfer object
 */

var getClipboardData = dataTransfer => {
  if (!dataTransfer.getData('application/x-slate-fragment')) {
    var fragment = getSlateFragmentAttribute(dataTransfer);

    if (fragment) {
      var clipboardData = new DataTransfer();
      dataTransfer.types.forEach(type => {
        clipboardData.setData(type, dataTransfer.getData(type));
      });
      clipboardData.setData('application/x-slate-fragment', fragment);
      return clipboardData;
    }
  }

  return dataTransfer;
};

var TRIPLE_CLICK = 3;

var _excluded$2 = ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "renderPlaceholder", "scrollSelectionIntoView", "style", "as"];

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var Children = props => /*#__PURE__*/React__default.createElement(React__default.Fragment, null, useChildren(props));
/**
 * Editable.
 */


var Editable$1 = props => {
  var {
    autoFocus,
    decorate = defaultDecorate,
    onDOMBeforeInput: propsOnDOMBeforeInput,
    placeholder,
    readOnly = false,
    renderElement,
    renderLeaf,
    renderPlaceholder = props => /*#__PURE__*/React__default.createElement(DefaultPlaceholder, Object.assign({}, props)),
    scrollSelectionIntoView = defaultScrollSelectionIntoView,
    style = {},
    as: Component = 'div'
  } = props,
      attributes = _objectWithoutProperties(props, _excluded$2);

  var editor = useSlate(); // Rerender editor when composition status changed

  var [isComposing, setIsComposing] = useState(false);
  var ref = useRef(null);
  var deferredOperations = useRef([]); // Update internal state on each render.

  IS_READ_ONLY.set(editor, readOnly); // Keep track of some state for the event handler logic.

  var state = useMemo(() => ({
    isComposing: false,
    hasInsertPrefixInCompositon: false,
    isDraggingInternally: false,
    isUpdatingSelection: false,
    latestElement: null
  }), []); // Whenever the editor updates...

  useIsomorphicLayoutEffect(() => {
    // Update element-related weak maps with the DOM element ref.
    var window;

    if (ref.current && (window = getDefaultView(ref.current))) {
      EDITOR_TO_WINDOW.set(editor, window);
      EDITOR_TO_ELEMENT.set(editor, ref.current);
      NODE_TO_ELEMENT.set(editor, ref.current);
      ELEMENT_TO_NODE.set(ref.current, editor);
    } else {
      NODE_TO_ELEMENT.delete(editor);
    } // Make sure the DOM selection state is in sync.


    var {
      selection
    } = editor;
    var root = ReactEditor.findDocumentOrShadowRoot(editor);
    var domSelection = root.getSelection();

    if (state.isComposing || !domSelection || !ReactEditor.isFocused(editor)) {
      return;
    }

    var hasDomSelection = domSelection.type !== 'None'; // If the DOM selection is properly unset, we're done.

    if (!selection && !hasDomSelection) {
      return;
    } // verify that the dom selection is in the editor


    var editorElement = EDITOR_TO_ELEMENT.get(editor);
    var hasDomSelectionInEditor = false;

    if (editorElement.contains(domSelection.anchorNode) && editorElement.contains(domSelection.focusNode)) {
      hasDomSelectionInEditor = true;
    } // If the DOM selection is in the editor and the editor selection is already correct, we're done.


    if (hasDomSelection && hasDomSelectionInEditor && selection) {
      var slateRange = ReactEditor.toSlateRange(editor, domSelection, {
        exactMatch: true,
        // domSelection is not necessarily a valid Slate range
        // (e.g. when clicking on contentEditable:false element)
        suppressThrow: true
      });

      if (slateRange && Range.equals(slateRange, selection)) {
        return;
      }
    } // when <Editable/> is being controlled through external value
    // then its children might just change - DOM responds to it on its own
    // but Slate's value is not being updated through any operation
    // and thus it doesn't transform selection on its own


    if (selection && !ReactEditor.hasRange(editor, selection)) {
      editor.selection = ReactEditor.toSlateRange(editor, domSelection, {
        exactMatch: false,
        suppressThrow: false
      });
      return;
    } // Otherwise the DOM selection is out of sync, so update it.


    state.isUpdatingSelection = true;
    var newDomRange = selection && ReactEditor.toDOMRange(editor, selection);

    if (newDomRange) {
      if (Range.isBackward(selection)) {
        domSelection.setBaseAndExtent(newDomRange.endContainer, newDomRange.endOffset, newDomRange.startContainer, newDomRange.startOffset);
      } else {
        domSelection.setBaseAndExtent(newDomRange.startContainer, newDomRange.startOffset, newDomRange.endContainer, newDomRange.endOffset);
      }

      scrollSelectionIntoView(editor, newDomRange);
    } else {
      domSelection.removeAllRanges();
    }

    setTimeout(() => {
      // COMPAT: In Firefox, it's not enough to create a range, you also need
      // to focus the contenteditable element too. (2016/11/16)
      if (newDomRange && IS_FIREFOX) {
        var el = ReactEditor.toDOMNode(editor, editor);
        el.focus();
      }

      state.isUpdatingSelection = false;
    });
  }); // The autoFocus TextareaHTMLAttribute doesn't do anything on a div, so it
  // needs to be manually focused.

  useEffect(() => {
    if (ref.current && autoFocus) {
      ref.current.focus();
    }
  }, [autoFocus]); // Listen on the native `selectionchange` event to be able to update any time
  // the selection changes. This is required because React's `onSelect` is leaky
  // and non-standard so it doesn't fire until after a selection has been
  // released. This causes issues in situations where another change happens
  // while a selection is being dragged.

  var onDOMSelectionChange = useCallback(throttle(() => {
    if (!state.isComposing && !state.isUpdatingSelection && !state.isDraggingInternally) {
      var root = ReactEditor.findDocumentOrShadowRoot(editor);
      var {
        activeElement
      } = root;
      var el = ReactEditor.toDOMNode(editor, editor);
      var domSelection = root.getSelection();

      if (activeElement === el) {
        state.latestElement = activeElement;
        IS_FOCUSED.set(editor, true);
      } else {
        IS_FOCUSED.delete(editor);
      }

      if (!domSelection) {
        return Transforms.deselect(editor);
      }

      var {
        anchorNode,
        focusNode
      } = domSelection;
      var anchorNodeSelectable = hasEditableTarget(editor, anchorNode) || isTargetInsideNonReadonlyVoid(editor, anchorNode);
      var focusNodeSelectable = hasEditableTarget(editor, focusNode) || isTargetInsideNonReadonlyVoid(editor, focusNode);

      if (anchorNodeSelectable && focusNodeSelectable) {
        var range = ReactEditor.toSlateRange(editor, domSelection, {
          exactMatch: false,
          suppressThrow: false
        });
        Transforms.select(editor, range);
      }
    }
  }, 100), [readOnly]);
  var scheduleOnDOMSelectionChange = useMemo(() => debounce(onDOMSelectionChange, 0), [onDOMSelectionChange]); // Listen on the native `beforeinput` event to get real "Level 2" events. This
  // is required because React's `beforeinput` is fake and never really attaches
  // to the real event sadly. (2019/11/01)
  // https://github.com/facebook/react/issues/11211

  var onDOMBeforeInput = useCallback(event => {
    if (!readOnly && hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {
      var _EDITOR_TO_USER_SELEC;

      // Some IMEs/Chrome extensions like e.g. Grammarly set the selection immediately before
      // triggering a `beforeinput` expecting the change to be applied to the immediately before
      // set selection.
      scheduleOnDOMSelectionChange.flush();
      onDOMSelectionChange.flush();
      var {
        selection
      } = editor;
      var {
        inputType: type
      } = event;
      var data = event.dataTransfer || event.data || undefined; // These two types occur while a user is composing text and can't be
      // cancelled. Let them through and wait for the composition to end.

      if (type === 'insertCompositionText' || type === 'deleteCompositionText') {
        return;
      }

      var native = false;

      if (type === 'insertText' && selection && Range.isCollapsed(selection) && // Only use native character insertion for single characters a-z or space for now.
      // Long-press events (hold a + press 4 = ä) to choose a special character otherwise
      // causes duplicate inserts.
      event.data && event.data.length === 1 && /[a-z ]/i.test(event.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405
      // When there is an inline element, e.g. a link, and you select
      // right after it (the start of the next node).
      selection.anchor.offset !== 0) {
        var _node$parentElement;

        native = true; // Skip native if there are marks, as
        // `insertText` will insert a node, not just text.

        if (editor.marks) {
          native = false;
        } // Chrome also has issues correctly editing the end of anchor elements: https://bugs.chromium.org/p/chromium/issues/detail?id=1259100
        // Therefore we don't allow native events to insert text at the end of anchor nodes.


        var {
          anchor
        } = selection;
        var [node, offset] = ReactEditor.toDOMPoint(editor, anchor);
        var anchorNode = (_node$parentElement = node.parentElement) === null || _node$parentElement === void 0 ? void 0 : _node$parentElement.closest('a');

        if (anchorNode && ReactEditor.hasDOMNode(editor, anchorNode)) {
          var _lastText$textContent;

          var {
            document
          } = ReactEditor.getWindow(editor); // Find the last text node inside the anchor.

          var lastText = document.createTreeWalker(anchorNode, NodeFilter.SHOW_TEXT).lastChild();

          if (lastText === node && ((_lastText$textContent = lastText.textContent) === null || _lastText$textContent === void 0 ? void 0 : _lastText$textContent.length) === offset) {
            native = false;
          }
        }
      }

      if (!native) {
        event.preventDefault();
      } // COMPAT: For the deleting forward/backward input types we don't want
      // to change the selection because it is the range that will be deleted,
      // and those commands determine that for themselves.


      if (!type.startsWith('delete') || type.startsWith('deleteBy')) {
        var [targetRange] = event.getTargetRanges();

        if (targetRange) {
          var range = ReactEditor.toSlateRange(editor, targetRange, {
            exactMatch: false,
            suppressThrow: false
          });

          if (!selection || !Range.equals(selection, range)) {
            var selectionRef = editor.selection && Editor$1.rangeRef(editor, editor.selection);
            Transforms.select(editor, range);

            if (selectionRef) {
              EDITOR_TO_USER_SELECTION.set(editor, selectionRef);
            }
          }
        }
      } // COMPAT: If the selection is expanded, even if the command seems like
      // a delete forward/backward command it should delete the selection.


      if (selection && Range.isExpanded(selection) && type.startsWith('delete')) {
        var direction = type.endsWith('Backward') ? 'backward' : 'forward';
        Editor$1.deleteFragment(editor, {
          direction
        });
        return;
      }

      switch (type) {
        case 'deleteByComposition':
        case 'deleteByCut':
        case 'deleteByDrag':
          {
            Editor$1.deleteFragment(editor);
            break;
          }

        case 'deleteContent':
        case 'deleteContentForward':
          {
            Editor$1.deleteForward(editor);
            break;
          }

        case 'deleteContentBackward':
          {
            Editor$1.deleteBackward(editor);
            break;
          }

        case 'deleteEntireSoftLine':
          {
            Editor$1.deleteBackward(editor, {
              unit: 'line'
            });
            Editor$1.deleteForward(editor, {
              unit: 'line'
            });
            break;
          }

        case 'deleteHardLineBackward':
          {
            Editor$1.deleteBackward(editor, {
              unit: 'block'
            });
            break;
          }

        case 'deleteSoftLineBackward':
          {
            Editor$1.deleteBackward(editor, {
              unit: 'line'
            });
            break;
          }

        case 'deleteHardLineForward':
          {
            Editor$1.deleteForward(editor, {
              unit: 'block'
            });
            break;
          }

        case 'deleteSoftLineForward':
          {
            Editor$1.deleteForward(editor, {
              unit: 'line'
            });
            break;
          }

        case 'deleteWordBackward':
          {
            Editor$1.deleteBackward(editor, {
              unit: 'word'
            });
            break;
          }

        case 'deleteWordForward':
          {
            Editor$1.deleteForward(editor, {
              unit: 'word'
            });
            break;
          }

        case 'insertLineBreak':
          Editor$1.insertSoftBreak(editor);
          break;

        case 'insertParagraph':
          {
            Editor$1.insertBreak(editor);
            break;
          }

        case 'insertFromComposition':
        case 'insertFromDrop':
        case 'insertFromPaste':
        case 'insertFromYank':
        case 'insertReplacementText':
        case 'insertText':
          {
            var {
              selection: _selection
            } = editor;

            if (_selection) {
              if (Range.isExpanded(_selection)) {
                Editor$1.deleteFragment(editor);
              }
            }

            if (type === 'insertFromComposition') {
              // COMPAT: in Safari, `compositionend` is dispatched after the
              // `beforeinput` for "insertFromComposition". But if we wait for it
              // then we will abort because we're still composing and the selection
              // won't be updated properly.
              // https://www.w3.org/TR/input-events-2/
              state.isComposing && setIsComposing(false);
              state.isComposing = false;
            } // use a weak comparison instead of 'instanceof' to allow
            // programmatic access of paste events coming from external windows
            // like cypress where cy.window does not work realibly


            if ((data === null || data === void 0 ? void 0 : data.constructor.name) === 'DataTransfer') {
              ReactEditor.insertData(editor, data);
            } else if (typeof data === 'string') {
              // Only insertText operations use the native functionality, for now.
              // Potentially expand to single character deletes, as well.
              if (native) {
                deferredOperations.current.push(() => Editor$1.insertText(editor, data));
              } else {
                Editor$1.insertText(editor, data);
              }
            }

            break;
          }
      } // Restore the actual user section if nothing manually set it.


      var toRestore = (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(editor)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();
      EDITOR_TO_USER_SELECTION.delete(editor);

      if (toRestore && (!editor.selection || !Range.equals(editor.selection, toRestore))) {
        Transforms.select(editor, toRestore);
      }
    }
  }, [readOnly, propsOnDOMBeforeInput]); // Attach a native DOM event handler for `beforeinput` events, because React's
  // built-in `onBeforeInput` is actually a leaky polyfill that doesn't expose
  // real `beforeinput` events sadly... (2019/11/04)
  // https://github.com/facebook/react/issues/11211

  useIsomorphicLayoutEffect(() => {
    if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {
      // @ts-ignore The `beforeinput` event isn't recognized.
      ref.current.addEventListener('beforeinput', onDOMBeforeInput);
    }

    return () => {
      if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {
        // @ts-ignore The `beforeinput` event isn't recognized.
        ref.current.removeEventListener('beforeinput', onDOMBeforeInput);
      }
    };
  }, [onDOMBeforeInput]); // Attach a native DOM event handler for `selectionchange`, because React's
  // built-in `onSelect` handler doesn't fire for all selection changes. It's a
  // leaky polyfill that only fires on keypresses or clicks. Instead, we want to
  // fire for any change to the selection inside the editor. (2019/11/04)
  // https://github.com/facebook/react/issues/5785

  useIsomorphicLayoutEffect(() => {
    var window = ReactEditor.getWindow(editor);
    window.document.addEventListener('selectionchange', scheduleOnDOMSelectionChange);
    return () => {
      window.document.removeEventListener('selectionchange', scheduleOnDOMSelectionChange);
    };
  }, [scheduleOnDOMSelectionChange]);
  var decorations = [...Node.nodes(editor)].flatMap(_ref => {
    var [n, p] = _ref;
    return decorate([n, p]);
  });

  if (placeholder && editor.children.length === 1 && Array.from(Node.texts(editor)).length === 1 && Node.string(editor) === '' && !isComposing) {
    var start = Editor$1.start(editor, []);
    decorations.push({
      [PLACEHOLDER_SYMBOL]: true,
      placeholder,
      anchor: start,
      focus: start
    });
  }

  return /*#__PURE__*/React__default.createElement(ReadOnlyContext.Provider, {
    value: readOnly
  }, /*#__PURE__*/React__default.createElement(DecorateContext.Provider, {
    value: decorate
  }, /*#__PURE__*/React__default.createElement(Component, Object.assign({
    role: readOnly ? undefined : 'textbox'
  }, attributes, {
    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
    // have to use hacks to make these replacement-based features work.
    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop
    // mismatch warning app moves to browser. Pass-through consumer props when
    // not CAN_USE_DOM (SSR) and default to falsy value
    spellCheck: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.spellCheck : false,
    autoCorrect: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCorrect : 'false',
    autoCapitalize: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCapitalize : 'false',
    "data-slate-editor": true,
    "data-slate-node": "value",
    // explicitly set this
    contentEditable: !readOnly,
    // in some cases, a decoration needs access to the range / selection to decorate a text node,
    // then you will select the whole text node when you select part the of text
    // this magic zIndex="-1" will fix it
    zindex: -1,
    suppressContentEditableWarning: true,
    ref: ref,
    style: _objectSpread$1({
      // Allow positioning relative to the editable element.
      position: 'relative',
      // Prevent the default outline styles.
      outline: 'none',
      // Preserve adjacent whitespace and new lines.
      whiteSpace: 'pre-wrap',
      // Allow words to break if they are too long.
      wordWrap: 'break-word'
    }, style),
    onBeforeInput: useCallback(event => {
      // COMPAT: Certain browsers don't support the `beforeinput` event, so we
      // fall back to React's leaky polyfill instead just for it. It
      // only works for the `insertText` input type.
      if (!HAS_BEFORE_INPUT_SUPPORT && !readOnly && !isEventHandled(event, attributes.onBeforeInput) && hasEditableTarget(editor, event.target)) {
        event.preventDefault();

        if (!state.isComposing) {
          var text = event.data;
          Editor$1.insertText(editor, text);
        }
      }
    }, [readOnly]),
    onInput: useCallback(event => {
      // Flush native operations, as native events will have propogated
      // and we can correctly compare DOM text values in components
      // to stop rendering, so that browser functions like autocorrect
      // and spellcheck work as expected.
      for (var op of deferredOperations.current) {
        op();
      }

      deferredOperations.current = [];
    }, []),
    onBlur: useCallback(event => {
      if (readOnly || state.isUpdatingSelection || !hasEditableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {
        return;
      } // COMPAT: If the current `activeElement` is still the previous
      // one, this is due to the window being blurred when the tab
      // itself becomes unfocused, so we want to abort early to allow to
      // editor to stay focused when the tab becomes focused again.


      var root = ReactEditor.findDocumentOrShadowRoot(editor);

      if (state.latestElement === root.activeElement) {
        return;
      }

      var {
        relatedTarget
      } = event;
      var el = ReactEditor.toDOMNode(editor, editor); // COMPAT: The event should be ignored if the focus is returning
      // to the editor from an embedded editable element (eg. an <input>
      // element inside a void node).

      if (relatedTarget === el) {
        return;
      } // COMPAT: The event should be ignored if the focus is moving from
      // the editor to inside a void node's spacer element.


      if (isDOMElement(relatedTarget) && relatedTarget.hasAttribute('data-slate-spacer')) {
        return;
      } // COMPAT: The event should be ignored if the focus is moving to a
      // non- editable section of an element that isn't a void node (eg.
      // a list item of the check list example).


      if (relatedTarget != null && isDOMNode(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {
        var node = ReactEditor.toSlateNode(editor, relatedTarget);

        if (Element$1.isElement(node) && !editor.isVoid(node)) {
          return;
        }
      } // COMPAT: Safari doesn't always remove the selection even if the content-
      // editable element no longer has focus. Refer to:
      // https://stackoverflow.com/questions/12353247/force-contenteditable-div-to-stop-accepting-input-after-it-loses-focus-under-web


      if (IS_SAFARI) {
        var domSelection = root.getSelection();
        domSelection === null || domSelection === void 0 ? void 0 : domSelection.removeAllRanges();
      }

      IS_FOCUSED.delete(editor);
    }, [readOnly, attributes.onBlur]),
    onClick: useCallback(event => {
      if (hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && isDOMNode(event.target)) {
        var node = ReactEditor.toSlateNode(editor, event.target);
        var path = ReactEditor.findPath(editor, node); // At this time, the Slate document may be arbitrarily different,
        // because onClick handlers can change the document before we get here.
        // Therefore we must check that this path actually exists,
        // and that it still refers to the same node.

        if (!Editor$1.hasPath(editor, path) || Node.get(editor, path) !== node) {
          return;
        }

        if (event.detail === TRIPLE_CLICK && path.length >= 1) {
          var _start2 = Editor$1.start(editor, [path[0]]);

          var _end = Editor$1.end(editor, [path[0]]);

          var range = Editor$1.range(editor, _start2, _end);
          Transforms.select(editor, range);
          return;
        }

        if (readOnly) {
          return;
        }

        var _start = Editor$1.start(editor, path);

        var end = Editor$1.end(editor, path);
        var startVoid = Editor$1.void(editor, {
          at: _start
        });
        var endVoid = Editor$1.void(editor, {
          at: end
        });

        if (startVoid && endVoid && Path.equals(startVoid[1], endVoid[1])) {
          var _range = Editor$1.range(editor, _start);

          Transforms.select(editor, _range);
        }
      }
    }, [readOnly, attributes.onClick]),
    onCompositionEnd: useCallback(event => {
      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionEnd)) {
        state.isComposing && setIsComposing(false);
        state.isComposing = false; // COMPAT: In Chrome, `beforeinput` events for compositions
        // aren't correct and never fire the "insertFromComposition"
        // type that we need. So instead, insert whenever a composition
        // ends since it will already have been committed to the DOM.

        if (!IS_SAFARI && !IS_FIREFOX_LEGACY && !IS_IOS && !IS_QQBROWSER && !IS_WECHATBROWSER && !IS_UC_MOBILE && event.data) {
          Editor$1.insertText(editor, event.data);
        }

        if (editor.selection && Range.isCollapsed(editor.selection)) {
          var leafPath = editor.selection.anchor.path;
          var currentTextNode = Node.leaf(editor, leafPath);

          if (state.hasInsertPrefixInCompositon) {
            state.hasInsertPrefixInCompositon = false;
            Editor$1.withoutNormalizing(editor, () => {
              // remove Unicode BOM prefix added in `onCompositionStart`
              var text = currentTextNode.text.replace(/^\uFEFF/, '');
              Transforms.delete(editor, {
                distance: currentTextNode.text.length,
                reverse: true
              });
              Editor$1.insertText(editor, text);
            });
          }
        }
      }
    }, [attributes.onCompositionEnd]),
    onCompositionUpdate: useCallback(event => {
      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionUpdate)) {
        !state.isComposing && setIsComposing(true);
        state.isComposing = true;
      }
    }, [attributes.onCompositionUpdate]),
    onCompositionStart: useCallback(event => {
      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionStart)) {
        var {
          selection,
          marks
        } = editor;

        if (selection) {
          if (Range.isExpanded(selection)) {
            Editor$1.deleteFragment(editor);
            return;
          }

          var inline = Editor$1.above(editor, {
            match: n => Editor$1.isInline(editor, n),
            mode: 'highest'
          });

          if (inline) {
            var [, inlinePath] = inline;

            if (Editor$1.isEnd(editor, selection.anchor, inlinePath)) {
              var point = Editor$1.after(editor, inlinePath);
              Transforms.setSelection(editor, {
                anchor: point,
                focus: point
              });
            }
          } // insert new node in advance to ensure composition text will insert
          // along with final input text
          // add Unicode BOM prefix to avoid normalize removing this node


          if (marks) {
            state.hasInsertPrefixInCompositon = true;
            Transforms.insertNodes(editor, _objectSpread$1({
              text: '\uFEFF'
            }, marks), {
              select: true
            });
          }
        }
      }
    }, [attributes.onCompositionStart]),
    onCopy: useCallback(event => {
      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy)) {
        event.preventDefault();
        ReactEditor.setFragmentData(editor, event.clipboardData, 'copy');
      }
    }, [attributes.onCopy]),
    onCut: useCallback(event => {
      if (!readOnly && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut)) {
        event.preventDefault();
        ReactEditor.setFragmentData(editor, event.clipboardData, 'cut');
        var {
          selection
        } = editor;

        if (selection) {
          if (Range.isExpanded(selection)) {
            Editor$1.deleteFragment(editor);
          } else {
            var node = Node.parent(editor, selection.anchor.path);

            if (Editor$1.isVoid(editor, node)) {
              Transforms.delete(editor);
            }
          }
        }
      }
    }, [readOnly, attributes.onCut]),
    onDragOver: useCallback(event => {
      if (hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {
        // Only when the target is void, call `preventDefault` to signal
        // that drops are allowed. Editable content is droppable by
        // default, and calling `preventDefault` hides the cursor.
        var node = ReactEditor.toSlateNode(editor, event.target);

        if (Editor$1.isVoid(editor, node)) {
          event.preventDefault();
        }
      }
    }, [attributes.onDragOver]),
    onDragStart: useCallback(event => {
      if (!readOnly && hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {
        var node = ReactEditor.toSlateNode(editor, event.target);
        var path = ReactEditor.findPath(editor, node);
        var voidMatch = Editor$1.isVoid(editor, node) || Editor$1.void(editor, {
          at: path,
          voids: true
        }); // If starting a drag on a void node, make sure it is selected
        // so that it shows up in the selection's fragment.

        if (voidMatch) {
          var range = Editor$1.range(editor, path);
          Transforms.select(editor, range);
        }

        state.isDraggingInternally = true;
        ReactEditor.setFragmentData(editor, event.dataTransfer, 'drag');
      }
    }, [readOnly, attributes.onDragStart]),
    onDrop: useCallback(event => {
      if (!readOnly && hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDrop)) {
        event.preventDefault(); // Keep a reference to the dragged range before updating selection

        var draggedRange = editor.selection; // Find the range where the drop happened

        var range = ReactEditor.findEventRange(editor, event);
        var data = event.dataTransfer;
        Transforms.select(editor, range);

        if (state.isDraggingInternally) {
          if (draggedRange && !Range.equals(draggedRange, range) && !Editor$1.void(editor, {
            at: range,
            voids: true
          })) {
            Transforms.delete(editor, {
              at: draggedRange
            });
          }
        }

        ReactEditor.insertData(editor, data); // When dragging from another source into the editor, it's possible
        // that the current editor does not have focus.

        if (!ReactEditor.isFocused(editor)) {
          ReactEditor.focus(editor);
        }
      }

      state.isDraggingInternally = false;
    }, [readOnly, attributes.onDrop]),
    onDragEnd: useCallback(event => {
      if (!readOnly && state.isDraggingInternally && attributes.onDragEnd && hasTarget(editor, event.target)) {
        attributes.onDragEnd(event);
      } // When dropping on a different droppable element than the current editor,
      // `onDrop` is not called. So we need to clean up in `onDragEnd` instead.
      // Note: `onDragEnd` is only called when `onDrop` is not called


      state.isDraggingInternally = false;
    }, [readOnly, attributes.onDragEnd]),
    onFocus: useCallback(event => {
      if (!readOnly && !state.isUpdatingSelection && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {
        var el = ReactEditor.toDOMNode(editor, editor);
        var root = ReactEditor.findDocumentOrShadowRoot(editor);
        state.latestElement = root.activeElement; // COMPAT: If the editor has nested editable elements, the focus
        // can go to them. In Firefox, this must be prevented because it
        // results in issues with keyboard navigation. (2017/03/30)

        if (IS_FIREFOX && event.target !== el) {
          el.focus();
          return;
        }

        IS_FOCUSED.set(editor, true);
      }
    }, [readOnly, attributes.onFocus]),
    onKeyDown: useCallback(event => {
      if (!readOnly && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onKeyDown) && !state.isComposing) {
        var {
          nativeEvent
        } = event;
        var {
          selection
        } = editor;
        var element = editor.children[selection !== null ? selection.focus.path[0] : 0];
        var isRTL = direction_1(Node.string(element)) === 'rtl'; // COMPAT: Since we prevent the default behavior on
        // `beforeinput` events, the browser doesn't think there's ever
        // any history stack to undo or redo, so we have to manage these
        // hotkeys ourselves. (2019/11/06)

        if (Hotkeys.isRedo(nativeEvent)) {
          event.preventDefault();
          var maybeHistoryEditor = editor;

          if (typeof maybeHistoryEditor.redo === 'function') {
            maybeHistoryEditor.redo();
          }

          return;
        }

        if (Hotkeys.isUndo(nativeEvent)) {
          event.preventDefault();
          var _maybeHistoryEditor = editor;

          if (typeof _maybeHistoryEditor.undo === 'function') {
            _maybeHistoryEditor.undo();
          }

          return;
        } // COMPAT: Certain browsers don't handle the selection updates
        // properly. In Chrome, the selection isn't properly extended.
        // And in Firefox, the selection isn't properly collapsed.
        // (2017/10/17)


        if (Hotkeys.isMoveLineBackward(nativeEvent)) {
          event.preventDefault();
          Transforms.move(editor, {
            unit: 'line',
            reverse: true
          });
          return;
        }

        if (Hotkeys.isMoveLineForward(nativeEvent)) {
          event.preventDefault();
          Transforms.move(editor, {
            unit: 'line'
          });
          return;
        }

        if (Hotkeys.isExtendLineBackward(nativeEvent)) {
          event.preventDefault();
          Transforms.move(editor, {
            unit: 'line',
            edge: 'focus',
            reverse: true
          });
          return;
        }

        if (Hotkeys.isExtendLineForward(nativeEvent)) {
          event.preventDefault();
          Transforms.move(editor, {
            unit: 'line',
            edge: 'focus'
          });
          return;
        } // COMPAT: If a void node is selected, or a zero-width text node
        // adjacent to an inline is selected, we need to handle these
        // hotkeys manually because browsers won't be able to skip over
        // the void node with the zero-width space not being an empty
        // string.


        if (Hotkeys.isMoveBackward(nativeEvent)) {
          event.preventDefault();

          if (selection && Range.isCollapsed(selection)) {
            Transforms.move(editor, {
              reverse: !isRTL
            });
          } else {
            Transforms.collapse(editor, {
              edge: 'start'
            });
          }

          return;
        }

        if (Hotkeys.isMoveForward(nativeEvent)) {
          event.preventDefault();

          if (selection && Range.isCollapsed(selection)) {
            Transforms.move(editor, {
              reverse: isRTL
            });
          } else {
            Transforms.collapse(editor, {
              edge: 'end'
            });
          }

          return;
        }

        if (Hotkeys.isMoveWordBackward(nativeEvent)) {
          event.preventDefault();

          if (selection && Range.isExpanded(selection)) {
            Transforms.collapse(editor, {
              edge: 'focus'
            });
          }

          Transforms.move(editor, {
            unit: 'word',
            reverse: !isRTL
          });
          return;
        }

        if (Hotkeys.isMoveWordForward(nativeEvent)) {
          event.preventDefault();

          if (selection && Range.isExpanded(selection)) {
            Transforms.collapse(editor, {
              edge: 'focus'
            });
          }

          Transforms.move(editor, {
            unit: 'word',
            reverse: isRTL
          });
          return;
        } // COMPAT: Certain browsers don't support the `beforeinput` event, so we
        // fall back to guessing at the input intention for hotkeys.
        // COMPAT: In iOS, some of these hotkeys are handled in the


        if (!HAS_BEFORE_INPUT_SUPPORT) {
          // We don't have a core behavior for these, but they change the
          // DOM if we don't prevent them, so we have to.
          if (Hotkeys.isBold(nativeEvent) || Hotkeys.isItalic(nativeEvent) || Hotkeys.isTransposeCharacter(nativeEvent)) {
            event.preventDefault();
            return;
          }

          if (Hotkeys.isSoftBreak(nativeEvent)) {
            event.preventDefault();
            Editor$1.insertSoftBreak(editor);
            return;
          }

          if (Hotkeys.isSplitBlock(nativeEvent)) {
            event.preventDefault();
            Editor$1.insertBreak(editor);
            return;
          }

          if (Hotkeys.isDeleteBackward(nativeEvent)) {
            event.preventDefault();

            if (selection && Range.isExpanded(selection)) {
              Editor$1.deleteFragment(editor, {
                direction: 'backward'
              });
            } else {
              Editor$1.deleteBackward(editor);
            }

            return;
          }

          if (Hotkeys.isDeleteForward(nativeEvent)) {
            event.preventDefault();

            if (selection && Range.isExpanded(selection)) {
              Editor$1.deleteFragment(editor, {
                direction: 'forward'
              });
            } else {
              Editor$1.deleteForward(editor);
            }

            return;
          }

          if (Hotkeys.isDeleteLineBackward(nativeEvent)) {
            event.preventDefault();

            if (selection && Range.isExpanded(selection)) {
              Editor$1.deleteFragment(editor, {
                direction: 'backward'
              });
            } else {
              Editor$1.deleteBackward(editor, {
                unit: 'line'
              });
            }

            return;
          }

          if (Hotkeys.isDeleteLineForward(nativeEvent)) {
            event.preventDefault();

            if (selection && Range.isExpanded(selection)) {
              Editor$1.deleteFragment(editor, {
                direction: 'forward'
              });
            } else {
              Editor$1.deleteForward(editor, {
                unit: 'line'
              });
            }

            return;
          }

          if (Hotkeys.isDeleteWordBackward(nativeEvent)) {
            event.preventDefault();

            if (selection && Range.isExpanded(selection)) {
              Editor$1.deleteFragment(editor, {
                direction: 'backward'
              });
            } else {
              Editor$1.deleteBackward(editor, {
                unit: 'word'
              });
            }

            return;
          }

          if (Hotkeys.isDeleteWordForward(nativeEvent)) {
            event.preventDefault();

            if (selection && Range.isExpanded(selection)) {
              Editor$1.deleteFragment(editor, {
                direction: 'forward'
              });
            } else {
              Editor$1.deleteForward(editor, {
                unit: 'word'
              });
            }

            return;
          }
        } else {
          if (IS_CHROME || IS_SAFARI) {
            // COMPAT: Chrome and Safari support `beforeinput` event but do not fire
            // an event when deleting backwards in a selected void inline node
            if (selection && (Hotkeys.isDeleteBackward(nativeEvent) || Hotkeys.isDeleteForward(nativeEvent)) && Range.isCollapsed(selection)) {
              var currentNode = Node.parent(editor, selection.anchor.path);

              if (Element$1.isElement(currentNode) && Editor$1.isVoid(editor, currentNode) && Editor$1.isInline(editor, currentNode)) {
                event.preventDefault();
                Editor$1.deleteBackward(editor, {
                  unit: 'block'
                });
                return;
              }
            }
          }
        }
      }
    }, [readOnly, attributes.onKeyDown]),
    onPaste: useCallback(event => {
      if (!readOnly && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste)) {
        // COMPAT: Certain browsers don't support the `beforeinput` event, so we
        // fall back to React's `onPaste` here instead.
        // COMPAT: Firefox, Chrome and Safari don't emit `beforeinput` events
        // when "paste without formatting" is used, so fallback. (2020/02/20)
        if (!HAS_BEFORE_INPUT_SUPPORT || isPlainTextOnlyPaste(event.nativeEvent)) {
          event.preventDefault();
          ReactEditor.insertData(editor, event.clipboardData);
        }
      }
    }, [readOnly, attributes.onPaste])
  }), /*#__PURE__*/React__default.createElement(Children, {
    decorations: decorations,
    node: editor,
    renderElement: renderElement,
    renderPlaceholder: renderPlaceholder,
    renderLeaf: renderLeaf,
    selection: editor.selection
  }))));
};
/**
 * The default placeholder element
 */

var DefaultPlaceholder = _ref2 => {
  var {
    attributes,
    children
  } = _ref2;
  return /*#__PURE__*/React__default.createElement("span", Object.assign({}, attributes), children);
};
/**
 * A default memoized decorate function.
 */

var defaultDecorate = () => [];
/**
 * A default implement to scroll dom range into view.
 */

var defaultScrollSelectionIntoView = (editor, domRange) => {
  // This was affecting the selection of multiple blocks and dragging behavior,
  // so enabled only if the selection has been collapsed.
  if (!editor.selection || editor.selection && Range.isCollapsed(editor.selection)) {
    var leafEl = domRange.startContainer.parentElement;
    leafEl.getBoundingClientRect = domRange.getBoundingClientRect.bind(domRange);
    scrollIntoView(leafEl, {
      scrollMode: 'if-needed'
    });
    delete leafEl.getBoundingClientRect;
  }
};
/**
 * Check if the target is in the editor.
 */


var hasTarget = (editor, target) => {
  return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target);
};
/**
 * Check if the target is editable and in the editor.
 */

var hasEditableTarget = (editor, target) => {
  return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target, {
    editable: true
  });
};
/**
 * Check if the target is inside void and in an non-readonly editor.
 */

var isTargetInsideNonReadonlyVoid = (editor, target) => {
  if (IS_READ_ONLY.get(editor)) return false;
  var slateNode = hasTarget(editor, target) && ReactEditor.toSlateNode(editor, target);
  return Editor$1.isVoid(editor, slateNode);
};
/**
 * Check if an event is overrided by a handler.
 */

var isEventHandled = (event, handler) => {
  if (!handler) {
    return false;
  } // The custom event handler may return a boolean to specify whether the event
  // shall be treated as being handled or not.


  var shouldTreatEventAsHandled = handler(event);

  if (shouldTreatEventAsHandled != null) {
    return shouldTreatEventAsHandled;
  }

  return event.isDefaultPrevented() || event.isPropagationStopped();
};
/**
 * Check if a DOM event is overrided by a handler.
 */

var isDOMEventHandled = (event, handler) => {
  if (!handler) {
    return false;
  } // The custom event handler may return a boolean to specify whether the event
  // shall be treated as being handled or not.


  var shouldTreatEventAsHandled = handler(event);

  if (shouldTreatEventAsHandled != null) {
    return shouldTreatEventAsHandled;
  }

  return event.defaultPrevented;
};

/**
 * Returns the number of characters that are the same at the beginning of the
 * String.
 *
 * @param prev  the previous text
 * @param next  the next text
 * @returns the offset of the start of the difference; null if there is no difference
 */

function getDiffStart(prev, next) {
  var length = Math.min(prev.length, next.length);

  for (var i = 0; i < length; i++) {
    if (prev.charAt(i) !== next.charAt(i)) return i;
  }

  if (prev.length !== next.length) return length;
  return null;
}
/**
 * Returns the number of characters that are the same at the end of the String
 * up to `max`. Max prevents double-counting characters when there are
 * multiple duplicate characters around the diff area.
 *
 * @param prev  the previous text
 * @param next  the next text
 * @param max  the max length to test.
 * @returns number of characters that are the same at the end of the string
 */


function getDiffEnd(prev, next, max) {
  var prevLength = prev.length;
  var nextLength = next.length;
  var length = Math.min(prevLength, nextLength, max);

  for (var i = 0; i < length; i++) {
    var prevChar = prev.charAt(prevLength - i - 1);
    var nextChar = next.charAt(nextLength - i - 1);
    if (prevChar !== nextChar) return i;
  }

  if (prev.length !== next.length) return length;
  return null;
}
/**
 * Takes two strings and returns an object representing two offsets. The
 * first, `start` represents the number of characters that are the same at
 * the front of the String. The `end` represents the number of characters
 * that are the same at the end of the String.
 *
 * Returns null if they are identical.
 *
 * @param prev  the previous text
 * @param next  the next text
 * @returns the difference text range; null if there are no differences.
 */


function getDiffOffsets(prev, next) {
  if (prev === next) return null;
  var start = getDiffStart(prev, next);
  if (start === null) return null;
  var maxEnd = Math.min(prev.length - start, next.length - start);
  var end = getDiffEnd(prev, next, maxEnd);
  if (end === null) return null;
  return {
    start,
    end
  };
}
/**
 * Takes a text string and returns a slice from the string at the given text range
 *
 * @param text  the text
 * @param offsets  the text range
 * @returns the text slice at text range
 */


function sliceText(text, offsets) {
  return text.slice(offsets.start, text.length - offsets.end);
}
/**
 * Takes two strings and returns a smart diff that can be used to describe the
 * change in a way that can be used as operations like inserting, removing or
 * replacing text.
 *
 * @param prev the previous text
 * @param next the next text
 * @returns the text difference
 */


function diffText(prev, next) {
  if (prev === undefined || next === undefined) return null;
  var offsets = getDiffOffsets(prev, next);
  if (offsets == null) return null;
  var insertText = sliceText(next, offsets);
  var removeText = sliceText(prev, offsets);
  return {
    start: offsets.start,
    end: prev.length - offsets.end,
    insertText,
    removeText
  };
}
function combineInsertedText(insertedText) {
  return insertedText.reduce((acc, _ref) => {
    var {
      text
    } = _ref;
    return "".concat(acc).concat(text.insertText);
  }, '');
}
function getTextInsertion(editor, domNode) {
  var node = ReactEditor.toSlateNode(editor, domNode);

  if (!Text$1.isText(node)) {
    return undefined;
  }

  var prevText = node.text;
  var nextText = domNode.textContent; // textContent will pad an extra \n when the textContent ends with an \n

  if (nextText.endsWith('\n')) {
    nextText = nextText.slice(0, nextText.length - 1);
  } // If the text is no different, there is no diff.


  if (nextText !== prevText) {
    var textDiff = diffText(prevText, nextText);

    if (textDiff !== null) {
      var textPath = ReactEditor.findPath(editor, node);
      return {
        text: textDiff,
        path: textPath
      };
    }
  }

  return undefined;
}
function normalizeTextInsertionRange(editor, range, _ref2) {
  var {
    path,
    text
  } = _ref2;
  var insertionRange = {
    anchor: {
      path,
      offset: text.start
    },
    focus: {
      path,
      offset: text.end
    }
  };

  if (!range || !Range.isCollapsed(range)) {
    return insertionRange;
  }

  var {
    insertText,
    removeText
  } = text;
  var isSingleCharacterInsertion = insertText.length === 1 || removeText.length === 1;
  /**
   * This code handles edge cases that arise from text diffing when the
   * inserted or removed character is a single character, and the character
   * right before or after the anchor is the same as the one being inserted or
   * removed.
   *
   * Take this example: hello|o
   *
   * If another `o` is inserted at the selection's anchor in the example above,
   * it should be inserted at the anchor, but using text diffing, we actually
   * detect that the character was inserted after the second `o`:
   *
   * helloo[o]|
   *
   * Instead, in these very specific edge cases, we assume that the character
   * needs to be inserted after the anchor rather than where the diff was found:
   *
   * hello[o]|o
   */

  if (isSingleCharacterInsertion && Path.equals(range.anchor.path, path)) {
    var [_text] = Array.from(Editor$1.nodes(editor, {
      at: range,
      match: Text$1.isText
    }));

    if (_text) {
      var [node] = _text;
      var {
        anchor
      } = range;
      var characterBeforeAnchor = node.text[anchor.offset - 1];
      var characterAfterAnchor = node.text[anchor.offset];

      if (insertText.length === 1 && insertText === characterAfterAnchor) {
        // Assume text should be inserted at the anchor
        return range;
      }

      if (removeText.length === 1 && removeText === characterBeforeAnchor) {
        // Assume text should be removed right before the anchor
        return {
          anchor: {
            path,
            offset: anchor.offset - 1
          },
          focus: {
            path,
            offset: anchor.offset
          }
        };
      }
    }
  }

  return insertionRange;
}

/**
 * An auto-incrementing identifier for keys.
 */
var n$1 = 0;
/**
 * A class that keeps track of a key string. We use a full class here because we
 * want to be able to use them as keys in `WeakMap` objects.
 */

class Key {
  constructor() {
    this.id = "".concat(n$1++);
  }

}

var ReactEditor = {
  /**
   * Return the host window of the current editor.
   */
  getWindow(editor) {
    var window = EDITOR_TO_WINDOW.get(editor);

    if (!window) {
      throw new Error('Unable to find a host window element for this editor');
    }

    return window;
  },

  /**
   * Find a key for a Slate node.
   */
  findKey(editor, node) {
    var key = NODE_TO_KEY.get(node);

    if (!key) {
      key = new Key();
      NODE_TO_KEY.set(node, key);
    }

    return key;
  },

  /**
   * Find the path of Slate node.
   */
  findPath(editor, node) {
    var path = [];
    var child = node;

    while (true) {
      var parent = NODE_TO_PARENT.get(child);

      if (parent == null) {
        if (Editor$1.isEditor(child)) {
          return path;
        } else {
          break;
        }
      }

      var i = NODE_TO_INDEX.get(child);

      if (i == null) {
        break;
      }

      path.unshift(i);
      child = parent;
    }

    throw new Error("Unable to find the path for Slate node: ".concat(JSON.stringify(node)));
  },

  /**
   * Find the DOM node that implements DocumentOrShadowRoot for the editor.
   */
  findDocumentOrShadowRoot(editor) {
    var el = ReactEditor.toDOMNode(editor, editor);
    var root = el.getRootNode();

    if ((root instanceof Document || root instanceof ShadowRoot) && root.getSelection != null) {
      return root;
    }

    return el.ownerDocument;
  },

  /**
   * Check if the editor is focused.
   */
  isFocused(editor) {
    return !!IS_FOCUSED.get(editor);
  },

  /**
   * Check if the editor is in read-only mode.
   */
  isReadOnly(editor) {
    return !!IS_READ_ONLY.get(editor);
  },

  /**
   * Blur the editor.
   */
  blur(editor) {
    var el = ReactEditor.toDOMNode(editor, editor);
    var root = ReactEditor.findDocumentOrShadowRoot(editor);
    IS_FOCUSED.set(editor, false);

    if (root.activeElement === el) {
      el.blur();
    }
  },

  /**
   * Focus the editor.
   */
  focus(editor) {
    var el = ReactEditor.toDOMNode(editor, editor);
    var root = ReactEditor.findDocumentOrShadowRoot(editor);
    IS_FOCUSED.set(editor, true);

    if (root.activeElement !== el) {
      el.focus({
        preventScroll: true
      });
    }
  },

  /**
   * Deselect the editor.
   */
  deselect(editor) {
    ReactEditor.toDOMNode(editor, editor);
    var {
      selection
    } = editor;
    var root = ReactEditor.findDocumentOrShadowRoot(editor);
    var domSelection = root.getSelection();

    if (domSelection && domSelection.rangeCount > 0) {
      domSelection.removeAllRanges();
    }

    if (selection) {
      Transforms.deselect(editor);
    }
  },

  /**
   * Check if a DOM node is within the editor.
   */
  hasDOMNode(editor, target) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      editable = false
    } = options;
    var editorEl = ReactEditor.toDOMNode(editor, editor);
    var targetEl; // COMPAT: In Firefox, reading `target.nodeType` will throw an error if
    // target is originating from an internal "restricted" element (e.g. a
    // stepper arrow on a number input). (2018/05/04)
    // https://github.com/ianstormtaylor/slate/issues/1819

    try {
      targetEl = isDOMElement(target) ? target : target.parentElement;
    } catch (err) {
      if (!err.message.includes('Permission denied to access property "nodeType"')) {
        throw err;
      }
    }

    if (!targetEl) {
      return false;
    }

    return targetEl.closest("[data-slate-editor]") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === 'boolean' && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    targetEl.closest('[contenteditable="false"]') === editorEl || !!targetEl.getAttribute('data-slate-zero-width'));
  },

  /**
   * Insert data from a `DataTransfer` into the editor.
   */
  insertData(editor, data) {
    editor.insertData(data);
  },

  /**
   * Insert fragment data from a `DataTransfer` into the editor.
   */
  insertFragmentData(editor, data) {
    return editor.insertFragmentData(data);
  },

  /**
   * Insert text data from a `DataTransfer` into the editor.
   */
  insertTextData(editor, data) {
    return editor.insertTextData(data);
  },

  /**
   * Sets data from the currently selected fragment on a `DataTransfer`.
   */
  setFragmentData(editor, data, originEvent) {
    editor.setFragmentData(data, originEvent);
  },

  /**
   * Find the native DOM element from a Slate node.
   */
  toDOMNode(editor, node) {
    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);
    var domNode = Editor$1.isEditor(node) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(ReactEditor.findKey(editor, node));

    if (!domNode) {
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(JSON.stringify(node)));
    }

    return domNode;
  },

  /**
   * Find a native DOM selection point from a Slate point.
   */
  toDOMPoint(editor, point) {
    var [node] = Editor$1.node(editor, point.path);
    var el = ReactEditor.toDOMNode(editor, node);
    var domPoint; // If we're inside a void node, force the offset to 0, otherwise the zero
    // width spacing character will result in an incorrect offset of 1

    if (Editor$1.void(editor, {
      at: point
    })) {
      point = {
        path: point.path,
        offset: 0
      };
    } // For each leaf, we need to isolate its content, which means filtering
    // to its direct text and zero-width spans. (We have to filter out any
    // other siblings that may have been rendered alongside them.)


    var selector = "[data-slate-string], [data-slate-zero-width]";
    var texts = Array.from(el.querySelectorAll(selector));
    var start = 0;

    for (var text of texts) {
      var domNode = text.childNodes[0];

      if (domNode == null || domNode.textContent == null) {
        continue;
      }

      var {
        length
      } = domNode.textContent;
      var attr = text.getAttribute('data-slate-length');
      var trueLength = attr == null ? length : parseInt(attr, 10);
      var end = start + trueLength;

      if (point.offset <= end) {
        var offset = Math.min(length, Math.max(0, point.offset - start));
        domPoint = [domNode, offset];
        break;
      }

      start = end;
    }

    if (!domPoint) {
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(JSON.stringify(point)));
    }

    return domPoint;
  },

  /**
   * Find a native DOM range from a Slate `range`.
   *
   * Notice: the returned range will always be ordinal regardless of the direction of Slate `range` due to DOM API limit.
   *
   * there is no way to create a reverse DOM Range using Range.setStart/setEnd
   * according to https://dom.spec.whatwg.org/#concept-range-bp-set.
   */
  toDOMRange(editor, range) {
    var {
      anchor,
      focus
    } = range;
    var isBackward = Range.isBackward(range);
    var domAnchor = ReactEditor.toDOMPoint(editor, anchor);
    var domFocus = Range.isCollapsed(range) ? domAnchor : ReactEditor.toDOMPoint(editor, focus);
    var window = ReactEditor.getWindow(editor);
    var domRange = window.document.createRange();
    var [startNode, startOffset] = isBackward ? domFocus : domAnchor;
    var [endNode, endOffset] = isBackward ? domAnchor : domFocus; // A slate Point at zero-width Leaf always has an offset of 0 but a native DOM selection at
    // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and
    // adjust the offset accordingly.

    var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;
    var isStartAtZeroWidth = !!startEl.getAttribute('data-slate-zero-width');
    var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;
    var isEndAtZeroWidth = !!endEl.getAttribute('data-slate-zero-width');
    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);
    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);
    return domRange;
  },

  /**
   * Find a Slate node from a native DOM `element`.
   */
  toSlateNode(editor, domNode) {
    var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;

    if (domEl && !domEl.hasAttribute('data-slate-node')) {
      domEl = domEl.closest("[data-slate-node]");
    }

    var node = domEl ? ELEMENT_TO_NODE.get(domEl) : null;

    if (!node) {
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(domEl));
    }

    return node;
  },

  /**
   * Get the target range from a DOM `event`.
   */
  findEventRange(editor, event) {
    if ('nativeEvent' in event) {
      event = event.nativeEvent;
    }

    var {
      clientX: x,
      clientY: y,
      target
    } = event;

    if (x == null || y == null) {
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(event));
    }

    var node = ReactEditor.toSlateNode(editor, event.target);
    var path = ReactEditor.findPath(editor, node); // If the drop target is inside a void node, move it into either the
    // next or previous node, depending on which side the `x` and `y`
    // coordinates are closest to.

    if (Editor$1.isVoid(editor, node)) {
      var rect = target.getBoundingClientRect();
      var isPrev = editor.isInline(node) ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;
      var edge = Editor$1.point(editor, path, {
        edge: isPrev ? 'start' : 'end'
      });
      var point = isPrev ? Editor$1.before(editor, edge) : Editor$1.after(editor, edge);

      if (point) {
        var _range = Editor$1.range(editor, point);

        return _range;
      }
    } // Else resolve a range from the caret position where the drop occured.


    var domRange;
    var {
      document
    } = ReactEditor.getWindow(editor); // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)

    if (document.caretRangeFromPoint) {
      domRange = document.caretRangeFromPoint(x, y);
    } else {
      var position = document.caretPositionFromPoint(x, y);

      if (position) {
        domRange = document.createRange();
        domRange.setStart(position.offsetNode, position.offset);
        domRange.setEnd(position.offsetNode, position.offset);
      }
    }

    if (!domRange) {
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(event));
    } // Resolve a Slate range from the DOM range.


    var range = ReactEditor.toSlateRange(editor, domRange, {
      exactMatch: false,
      suppressThrow: false
    });
    return range;
  },

  /**
   * Find a Slate point from a DOM selection's `domNode` and `domOffset`.
   */
  toSlatePoint(editor, domPoint, options) {
    var {
      exactMatch,
      suppressThrow
    } = options;
    var [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint);
    var parentNode = nearestNode.parentNode;
    var textNode = null;
    var offset = 0;

    if (parentNode) {
      var _domNode$textContent;

      var editorEl = ReactEditor.toDOMNode(editor, editor);
      var potentialVoidNode = parentNode.closest('[data-slate-void="true"]'); // Need to ensure that the closest void node is actually a void node
      // within this editor, and not a void node within some parent editor. This can happen
      // if this editor is within a void node of another editor ("nested editors", like in
      // the "Editable Voids" example on the docs site).

      var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;
      var leafNode = parentNode.closest('[data-slate-leaf]');
      var domNode = null; // Calculate how far into the text node the `nearestNode` is, so that we
      // can determine what the offset relative to the text node is.

      if (leafNode) {
        textNode = leafNode.closest('[data-slate-node="text"]');

        if (textNode) {
          var window = ReactEditor.getWindow(editor);
          var range = window.document.createRange();
          range.setStart(textNode, 0);
          range.setEnd(nearestNode, nearestOffset);
          var contents = range.cloneContents();
          var removals = [...Array.prototype.slice.call(contents.querySelectorAll('[data-slate-zero-width]')), ...Array.prototype.slice.call(contents.querySelectorAll('[contenteditable=false]'))];
          removals.forEach(el => {
            el.parentNode.removeChild(el);
          }); // COMPAT: Edge has a bug where Range.prototype.toString() will
          // convert \n into \r\n. The bug causes a loop when slate-react
          // attempts to reposition its cursor to match the native position. Use
          // textContent.length instead.
          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/

          offset = contents.textContent.length;
          domNode = textNode;
        }
      } else if (voidNode) {
        // For void nodes, the element with the offset key will be a cousin, not an
        // ancestor, so find it by going down from the nearest void parent.
        leafNode = voidNode.querySelector('[data-slate-leaf]'); // COMPAT: In read-only editors the leaf is not rendered.

        if (!leafNode) {
          offset = 1;
        } else {
          textNode = leafNode.closest('[data-slate-node="text"]');
          domNode = leafNode;
          offset = domNode.textContent.length;
          domNode.querySelectorAll('[data-slate-zero-width]').forEach(el => {
            offset -= el.textContent.length;
          });
        }
      }

      if (domNode && offset === domNode.textContent.length && (parentNode.hasAttribute('data-slate-zero-width') || IS_FIREFOX && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.endsWith('\n\n'))) {
        offset--;
      }
    }

    if (!textNode) {
      if (suppressThrow) {
        return null;
      }

      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(domPoint));
    } // COMPAT: If someone is clicking from one Slate editor into another,
    // the select event fires twice, once for the old editor's `element`
    // first, and then afterwards for the correct `element`. (2017/03/03)


    var slateNode = ReactEditor.toSlateNode(editor, textNode);
    var path = ReactEditor.findPath(editor, slateNode);
    return {
      path,
      offset
    };
  },

  /**
   * Find a Slate range from a DOM range or selection.
   */
  toSlateRange(editor, domRange, options) {
    var {
      exactMatch,
      suppressThrow
    } = options;
    var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;
    var anchorNode;
    var anchorOffset;
    var focusNode;
    var focusOffset;
    var isCollapsed;

    if (el) {
      if (isDOMSelection(domRange)) {
        anchorNode = domRange.anchorNode;
        anchorOffset = domRange.anchorOffset;
        focusNode = domRange.focusNode;
        focusOffset = domRange.focusOffset; // COMPAT: There's a bug in chrome that always returns `true` for
        // `isCollapsed` for a Selection that comes from a ShadowRoot.
        // (2020/08/08)
        // https://bugs.chromium.org/p/chromium/issues/detail?id=447523

        if (IS_CHROME && hasShadowRoot()) {
          isCollapsed = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;
        } else {
          isCollapsed = domRange.isCollapsed;
        }
      } else {
        anchorNode = domRange.startContainer;
        anchorOffset = domRange.startOffset;
        focusNode = domRange.endContainer;
        focusOffset = domRange.endOffset;
        isCollapsed = domRange.collapsed;
      }
    }

    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(domRange));
    }

    var anchor = ReactEditor.toSlatePoint(editor, [anchorNode, anchorOffset], {
      exactMatch,
      suppressThrow
    });

    if (!anchor) {
      return null;
    }

    var focus = isCollapsed ? anchor : ReactEditor.toSlatePoint(editor, [focusNode, focusOffset], {
      exactMatch,
      suppressThrow
    });

    if (!focus) {
      return null;
    }

    var range = {
      anchor: anchor,
      focus: focus
    }; // if the selection is a hanging range that ends in a void
    // and the DOM focus is an Element
    // (meaning that the selection ends before the element)
    // unhang the range to avoid mistakenly including the void

    if (Range.isExpanded(range) && Range.isForward(range) && isDOMElement(focusNode) && Editor$1.void(editor, {
      at: range.focus,
      mode: 'highest'
    })) {
      range = Editor$1.unhangRange(editor, range, {
        voids: true
      });
    }

    return range;
  },

  hasRange(editor, range) {
    var {
      anchor,
      focus
    } = range;
    return Editor$1.hasPath(editor, anchor.path) && Editor$1.hasPath(editor, focus.path);
  }

};

function gatherMutationData(editor, mutations) {
  var addedNodes = [];
  var removedNodes = [];
  var insertedText = [];
  var characterDataMutations = [];
  mutations.forEach(mutation => {
    switch (mutation.type) {
      case 'childList':
        {
          if (mutation.addedNodes.length) {
            mutation.addedNodes.forEach(addedNode => {
              addedNodes.push(addedNode);
            });
          }

          mutation.removedNodes.forEach(removedNode => {
            removedNodes.push(removedNode);
          });
          break;
        }

      case 'characterData':
        {
          characterDataMutations.push(mutation); // Changes to text nodes should consider the parent element

          var {
            parentNode
          } = mutation.target;

          if (!parentNode) {
            return;
          }

          var textInsertion = getTextInsertion(editor, parentNode);

          if (!textInsertion) {
            return;
          } // If we've already detected a diff at that path, we can return early


          if (insertedText.some(_ref => {
            var {
              path
            } = _ref;
            return Path.equals(path, textInsertion.path);
          })) {
            return;
          } // Add the text diff to the array of detected text insertions that need to be reconciled


          insertedText.push(textInsertion);
        }
    }
  });
  return {
    addedNodes,
    removedNodes,
    insertedText,
    characterDataMutations
  };
}
/**
 * In general, when a line break occurs, there will be more `addedNodes` than `removedNodes`.
 *
 * This isn't always the case however. In some cases, there will be more `removedNodes` than
 * `addedNodes`.
 *
 * To account for these edge cases, the most reliable strategy to detect line break mutations
 * is to check whether a new block was inserted of the same type as the current block.
 */

var isLineBreak = (editor, _ref2) => {
  var {
    addedNodes
  } = _ref2;
  var {
    selection
  } = editor;
  var parentNode = selection ? Node.parent(editor, selection.anchor.path) : null;
  var parentDOMNode = parentNode ? ReactEditor.toDOMNode(editor, parentNode) : null;

  if (!parentDOMNode) {
    return false;
  }

  return addedNodes.some(addedNode => addedNode instanceof HTMLElement && addedNode.tagName === (parentDOMNode === null || parentDOMNode === void 0 ? void 0 : parentDOMNode.tagName));
};
/**
 * So long as we check for line break mutations before deletion mutations,
 * we can safely assume that a set of mutations was a deletion if there are
 * removed nodes.
 */

var isDeletion = (_, _ref3) => {
  var {
    removedNodes
  } = _ref3;
  return removedNodes.length > 0;
};
/**
 * If the selection was expanded and there are removed nodes,
 * the contents of the selection need to be replaced with the diff
 */

var isReplaceExpandedSelection = (_ref4, _ref5) => {
  var {
    selection
  } = _ref4;
  var {
    removedNodes
  } = _ref5;
  return selection ? Range.isExpanded(selection) && removedNodes.length > 0 : false;
};
/**
 * Plain text insertion
 */

var isTextInsertion = (_, _ref6) => {
  var {
    insertedText
  } = _ref6;
  return insertedText.length > 0;
};
/**
 * Edge case. Detect mutations that remove leaf nodes and also update character data
 */

var isRemoveLeafNodes = (_, _ref7) => {
  var {
    addedNodes,
    characterDataMutations,
    removedNodes
  } = _ref7;
  return removedNodes.length > 0 && addedNodes.length === 0 && characterDataMutations.length > 0;
};

/**
 * Based loosely on:
 *
 * https://github.com/facebook/draft-js/blob/master/src/component/handlers/composition/DOMObserver.js
 * https://github.com/ProseMirror/prosemirror-view/blob/master/src/domobserver.js
 *
 * The input manager attempts to map observed mutations on the document to a
 * set of operations in order to reconcile Slate's internal value with the DOM.
 *
 * Mutations are processed synchronously as they come in. Only mutations that occur
 * during a user input loop are processed, as other mutations can occur within the
 * document that were not initiated by user input.
 *
 * The mutation reconciliation process attempts to match mutations to the following
 * patterns:
 *
 * - Text updates
 * - Deletions
 * - Line breaks
 *
 * @param editor
 * @param restoreDOM
 */


class AndroidInputManager {
  constructor(editor, restoreDOM) {
    this.editor = editor;
    this.restoreDOM = restoreDOM;
    /**
     * Handle MutationObserver flush
     *
     * @param mutations
     */

    this.flush = mutations => {

      try {
        this.reconcileMutations(mutations);
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error(err); // Failed to reconcile mutations, restore DOM to its previous state

        this.restoreDOM();
      }
    };
    /**
     * Reconcile a batch of mutations
     *
     * @param mutations
     */


    this.reconcileMutations = mutations => {
      var mutationData = gatherMutationData(this.editor, mutations);
      var {
        insertedText,
        removedNodes
      } = mutationData;

      if (isReplaceExpandedSelection(this.editor, mutationData)) {
        var text = combineInsertedText(insertedText);
        this.replaceExpandedSelection(text);
      } else if (isLineBreak(this.editor, mutationData)) {
        this.insertBreak();
      } else if (isRemoveLeafNodes(this.editor, mutationData)) {
        this.removeLeafNodes(removedNodes);
      } else if (isDeletion(this.editor, mutationData)) {
        this.deleteBackward();
      } else if (isTextInsertion(this.editor, mutationData)) {
        this.insertText(insertedText);
      }
    };
    /**
     * Apply text diff
     */


    this.insertText = insertedText => {
      var {
        selection
      } = this.editor; // If it is in composing or after `onCompositionend`, set `EDITOR_ON_COMPOSITION_TEXT` and return.
      // Text will be inserted on compositionend event.

      if (IS_COMPOSING.get(this.editor) || IS_ON_COMPOSITION_END.get(this.editor)) {
        EDITOR_ON_COMPOSITION_TEXT.set(this.editor, insertedText);
        IS_ON_COMPOSITION_END.set(this.editor, false);
        return;
      } // Insert the batched text diffs


      insertedText.forEach(insertion => {
        var text = insertion.text.insertText;
        var at = normalizeTextInsertionRange(this.editor, selection, insertion);
        Transforms.setSelection(this.editor, at);
        Editor$1.insertText(this.editor, text);
      });
    };
    /**
     * Handle line breaks
     */


    this.insertBreak = () => {
      var {
        selection
      } = this.editor;
      Editor$1.insertBreak(this.editor);
      this.restoreDOM();

      if (selection) {
        // Compat: Move selection to the newly inserted block if it has not moved
        setTimeout(() => {
          if (this.editor.selection && Range.equals(selection, this.editor.selection)) {
            Transforms.move(this.editor);
          }
        }, 100);
      }
    };
    /**
     * Handle expanded selection being deleted or replaced by text
     */


    this.replaceExpandedSelection = text => {

      Editor$1.deleteFragment(this.editor);

      if (text.length) {
        // Selection was replaced by text, insert the entire text diff
        Editor$1.insertText(this.editor, text);
      }

      this.restoreDOM();
    };
    /**
     * Handle `backspace` that merges blocks
     */


    this.deleteBackward = () => {
      Editor$1.deleteBackward(this.editor);
      ReactEditor.focus(this.editor);
      this.restoreDOM();
    };
    /**
     * Handle mutations that remove specific leaves
     */


    this.removeLeafNodes = nodes => {
      for (var node of nodes) {
        var slateNode = ReactEditor.toSlateNode(this.editor, node);

        if (slateNode) {
          var path = ReactEditor.findPath(this.editor, slateNode);
          Transforms.delete(this.editor, {
            at: path
          });
          this.restoreDOM();
        }
      }
    };

    this.editor = editor;
    this.restoreDOM = restoreDOM;
  }

}

function useMutationObserver(node, callback, options) {
  var [mutationObserver] = useState(() => new MutationObserver(callback));
  useIsomorphicLayoutEffect(() => {
    // Disconnect mutation observer during render phase
    mutationObserver.disconnect();
  });
  useEffect(() => {
    if (!node.current) {
      throw new Error('Failed to attach MutationObserver, `node` is undefined');
    } // Attach mutation observer after render phase has finished


    mutationObserver.observe(node.current, options); // Clean up after effect

    return mutationObserver.disconnect.bind(mutationObserver);
  });
}

var MUTATION_OBSERVER_CONFIG$1 = {
  childList: true,
  characterData: true,
  subtree: true
};

function findClosestKnowSlateNode(domNode) {
  var _domEl;

  var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;

  if (domEl && !domEl.hasAttribute('data-slate-node')) {
    domEl = domEl.closest("[data-slate-node]");
  }

  var slateNode = domEl && ELEMENT_TO_NODE.get(domEl);

  if (slateNode) {
    return slateNode;
  } // Unknown dom element with a slate-slate-node attribute => the IME
  // most likely duplicated the node so we have to restore the parent


  return (_domEl = domEl) !== null && _domEl !== void 0 && _domEl.parentElement ? findClosestKnowSlateNode(domEl.parentElement) : null;
}

function useRestoreDom(node, receivedUserInput) {
  var editor = useSlateStatic();
  var mutatedNodes = useRef(new Set());
  var handleDOMMutation = useCallback(mutations => {
    if (!receivedUserInput.current) {
      return;
    }

    mutations.forEach(_ref => {
      var {
        target
      } = _ref;
      var slateNode = findClosestKnowSlateNode(target);

      if (!slateNode) {
        return;
      }

      return mutatedNodes.current.add(slateNode);
    });
  }, []);
  useMutationObserver(node, handleDOMMutation, MUTATION_OBSERVER_CONFIG$1); // Clear mutated nodes on every render

  mutatedNodes.current.clear();
  var restore = useCallback(() => {
    var mutated = Array.from(mutatedNodes.current.values()); // Filter out child nodes of nodes that will be restored anyway

    var nodesToRestore = mutated.filter(n => !mutated.some(m => Path.isParent(ReactEditor.findPath(editor, m), ReactEditor.findPath(editor, n))));
    nodesToRestore.forEach(n => {
      var _NODE_TO_RESTORE_DOM$;

      (_NODE_TO_RESTORE_DOM$ = NODE_TO_RESTORE_DOM.get(n)) === null || _NODE_TO_RESTORE_DOM$ === void 0 ? void 0 : _NODE_TO_RESTORE_DOM$();
    });
    mutatedNodes.current.clear();
  }, []);
  return restore;
}

function useTrackUserInput() {
  var editor = useSlateStatic();
  var receivedUserInput = useRef(false);
  var animationFrameRef = useRef(null);
  var onUserInput = useCallback(() => {
    if (receivedUserInput.current === false) {
      var window = ReactEditor.getWindow(editor);
      receivedUserInput.current = true;

      if (animationFrameRef.current) {
        window.cancelAnimationFrame(animationFrameRef.current);
      }

      animationFrameRef.current = window.requestAnimationFrame(() => {
        receivedUserInput.current = false;
        animationFrameRef.current = null;
      });
    }
  }, []);
  useEffect(() => {
    // Reset user input tracking on every render
    if (receivedUserInput.current) {
      receivedUserInput.current = false;
    }
  });
  return {
    receivedUserInput,
    onUserInput
  };
}

var MUTATION_OBSERVER_CONFIG = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  subtree: true
};
function useAndroidInputManager(node) {
  var editor = useSlateStatic();
  var {
    receivedUserInput,
    onUserInput
  } = useTrackUserInput();
  var restoreDom = useRestoreDom(node, receivedUserInput);
  var inputManager = useMemo(() => new AndroidInputManager(editor, restoreDom), [restoreDom, editor]);
  var timeoutId = useRef(null);
  var isReconciling = useRef(false);
  var flush = useCallback(mutations => {
    if (!receivedUserInput.current) {
      return;
    }

    isReconciling.current = true;
    inputManager.flush(mutations);

    if (timeoutId.current) {
      clearTimeout(timeoutId.current);
    }

    timeoutId.current = setTimeout(() => {
      isReconciling.current = false;
      timeoutId.current = null;
    }, 250);
  }, []);
  useMutationObserver(node, flush, MUTATION_OBSERVER_CONFIG);
  return {
    isReconciling,
    onUserInput
  };
}

var _excluded$1 = ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "renderPlaceholder", "style", "as"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * Editable.
 */
// https://github.com/facebook/draft-js/blob/main/src/component/handlers/composition/DraftEditorCompositionHandler.js#L41
// When using keyboard English association function, conpositionEnd triggered too fast, resulting in after `insertText` still maintain association state.

var RESOLVE_DELAY = 20;
var AndroidEditable = props => {
  var {
    autoFocus,
    decorate = defaultDecorate,
    onDOMBeforeInput: propsOnDOMBeforeInput,
    placeholder,
    readOnly = false,
    renderElement,
    renderLeaf,
    renderPlaceholder = props => /*#__PURE__*/React__default.createElement(DefaultPlaceholder, Object.assign({}, props)),
    style = {},
    as: Component = 'div'
  } = props,
      attributes = _objectWithoutProperties(props, _excluded$1);

  var editor = useSlate(); // Rerender editor when composition status changed

  var [isComposing, setIsComposing] = useState(false);
  var ref = useRef(null);
  var inputManager = useAndroidInputManager(ref); // Update internal state on each render.

  IS_READ_ONLY.set(editor, readOnly); // Keep track of some state for the event handler logic.

  var state = useMemo(() => ({
    isComposing: false,
    isUpdatingSelection: false,
    latestElement: null
  }), []);
  var contentKey = useContentKey(editor); // Whenever the editor updates...

  useIsomorphicLayoutEffect(() => {
    // Update element-related weak maps with the DOM element ref.
    var window;

    if (ref.current && (window = getDefaultView(ref.current))) {
      EDITOR_TO_WINDOW.set(editor, window);
      EDITOR_TO_ELEMENT.set(editor, ref.current);
      NODE_TO_ELEMENT.set(editor, ref.current);
      ELEMENT_TO_NODE.set(ref.current, editor);
    } else {
      NODE_TO_ELEMENT.delete(editor);
    }

    try {
      // Make sure the DOM selection state is in sync.
      var {
        selection
      } = editor;
      var root = ReactEditor.findDocumentOrShadowRoot(editor);
      var domSelection = root.getSelection();

      if (state.isComposing || !domSelection || !ReactEditor.isFocused(editor)) {
        return;
      }

      var hasDomSelection = domSelection.type !== 'None'; // If the DOM selection is properly unset, we're done.

      if (!selection && !hasDomSelection) {
        return;
      } // verify that the dom selection is in the editor


      var editorElement = EDITOR_TO_ELEMENT.get(editor);
      var hasDomSelectionInEditor = false;

      if (editorElement.contains(domSelection.anchorNode) && editorElement.contains(domSelection.focusNode)) {
        hasDomSelectionInEditor = true;
      } // If the DOM selection is in the editor and the editor selection is already correct, we're done.


      if (hasDomSelection && hasDomSelectionInEditor && selection) {
        var slateRange = ReactEditor.toSlateRange(editor, domSelection, {
          exactMatch: true,
          suppressThrow: true
        });

        if (slateRange && Range.equals(slateRange, selection)) {
          return;
        }
      } // when <Editable/> is being controlled through external value
      // then its children might just change - DOM responds to it on its own
      // but Slate's value is not being updated through any operation
      // and thus it doesn't transform selection on its own


      if (selection && !ReactEditor.hasRange(editor, selection)) {
        editor.selection = ReactEditor.toSlateRange(editor, domSelection, {
          exactMatch: false,
          suppressThrow: false
        });
        return;
      } // Otherwise the DOM selection is out of sync, so update it.


      var el = ReactEditor.toDOMNode(editor, editor);
      state.isUpdatingSelection = true;
      var newDomRange = selection && ReactEditor.toDOMRange(editor, selection);

      if (newDomRange) {
        if (Range.isBackward(selection)) {
          domSelection.setBaseAndExtent(newDomRange.endContainer, newDomRange.endOffset, newDomRange.startContainer, newDomRange.startOffset);
        } else {
          domSelection.setBaseAndExtent(newDomRange.startContainer, newDomRange.startOffset, newDomRange.endContainer, newDomRange.endOffset);
        }

        var leafEl = newDomRange.startContainer.parentElement;
        leafEl.getBoundingClientRect = newDomRange.getBoundingClientRect.bind(newDomRange);
        scrollIntoView(leafEl, {
          scrollMode: 'if-needed',
          boundary: el
        }); // @ts-ignore

        delete leafEl.getBoundingClientRect;
      } else {
        domSelection.removeAllRanges();
      }

      setTimeout(() => {
        state.isUpdatingSelection = false;
      });
    } catch (_unused) {
      // Failed to update selection, likely due to reconciliation error
      state.isUpdatingSelection = false;
    }
  }); // The autoFocus TextareaHTMLAttribute doesn't do anything on a div, so it
  // needs to be manually focused.

  useEffect(() => {
    if (ref.current && autoFocus) {
      ref.current.focus();
    }
  }, [autoFocus]); // Listen on the native `selectionchange` event to be able to update any time
  // the selection changes. This is required because React's `onSelect` is leaky
  // and non-standard so it doesn't fire until after a selection has been
  // released. This causes issues in situations where another change happens
  // while a selection is being dragged.

  var onDOMSelectionChange = useCallback(throttle(() => {
    try {
      if (!state.isComposing && !state.isUpdatingSelection && !inputManager.isReconciling.current) {
        var root = ReactEditor.findDocumentOrShadowRoot(editor);
        var {
          activeElement
        } = root;
        var el = ReactEditor.toDOMNode(editor, editor);
        var domSelection = root.getSelection();

        if (activeElement === el) {
          state.latestElement = activeElement;
          IS_FOCUSED.set(editor, true);
        } else {
          IS_FOCUSED.delete(editor);
        }

        if (!domSelection) {
          return Transforms.deselect(editor);
        }

        var {
          anchorNode,
          focusNode
        } = domSelection;
        var anchorNodeSelectable = hasEditableTarget(editor, anchorNode) || isTargetInsideNonReadonlyVoid(editor, anchorNode);
        var focusNodeSelectable = hasEditableTarget(editor, focusNode) || isTargetInsideNonReadonlyVoid(editor, focusNode);

        if (anchorNodeSelectable && focusNodeSelectable) {
          var range = ReactEditor.toSlateRange(editor, domSelection, {
            exactMatch: false,
            suppressThrow: false
          });
          Transforms.select(editor, range);
        } else {
          Transforms.deselect(editor);
        }
      }
    } catch (_unused2) {// Failed to update selection, likely due to reconciliation error
    }
  }, 100), [readOnly]);
  var scheduleOnDOMSelectionChange = useMemo(() => debounce(onDOMSelectionChange, 0), [onDOMSelectionChange]); // Listen on the native `beforeinput` event to get real "Level 2" events. This
  // is required because React's `beforeinput` is fake and never really attaches
  // to the real event sadly. (2019/11/01)
  // https://github.com/facebook/react/issues/11211

  var onDOMBeforeInput = useCallback(event => {
    if (!readOnly && hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {
      // Some IMEs/Chrome extensions like e.g. Grammarly set the selection immediately before
      // triggering a `beforeinput` expecting the change to be applied to the immediately before
      // set selection.
      scheduleOnDOMSelectionChange.flush();
      inputManager.onUserInput();
    }
  }, [readOnly, propsOnDOMBeforeInput]); // Attach a native DOM event handler for `beforeinput` events, because React's
  // built-in `onBeforeInput` is actually a leaky polyfill that doesn't expose
  // real `beforeinput` events sadly... (2019/11/04)

  useIsomorphicLayoutEffect(() => {
    var node = ref.current; // @ts-ignore The `beforeinput` event isn't recognized.

    node === null || node === void 0 ? void 0 : node.addEventListener('beforeinput', onDOMBeforeInput); // @ts-ignore The `beforeinput` event isn't recognized.

    return () => node === null || node === void 0 ? void 0 : node.removeEventListener('beforeinput', onDOMBeforeInput);
  }, [contentKey, propsOnDOMBeforeInput]); // Attach a native DOM event handler for `selectionchange`, because React's
  // built-in `onSelect` handler doesn't fire for all selection changes. It's a
  // leaky polyfill that only fires on keypresses or clicks. Instead, we want to
  // fire for any change to the selection inside the editor. (2019/11/04)
  // https://github.com/facebook/react/issues/5785

  useIsomorphicLayoutEffect(() => {
    var window = ReactEditor.getWindow(editor);
    window.document.addEventListener('selectionchange', scheduleOnDOMSelectionChange);
    return () => {
      window.document.removeEventListener('selectionchange', scheduleOnDOMSelectionChange);
    };
  }, [scheduleOnDOMSelectionChange]);
  var decorations = decorate([editor, []]);

  if (placeholder && editor.children.length === 1 && Array.from(Node.texts(editor)).length === 1 && Node.string(editor) === '' && !isComposing) {
    var start = Editor$1.start(editor, []);
    decorations.push({
      [PLACEHOLDER_SYMBOL]: true,
      placeholder,
      anchor: start,
      focus: start
    });
  }

  return /*#__PURE__*/React__default.createElement(ReadOnlyContext.Provider, {
    value: readOnly
  }, /*#__PURE__*/React__default.createElement(DecorateContext.Provider, {
    value: decorate
  }, /*#__PURE__*/React__default.createElement(Component, Object.assign({
    key: contentKey,
    role: readOnly ? undefined : 'textbox'
  }, attributes, {
    spellCheck: attributes.spellCheck,
    autoCorrect: attributes.autoCorrect,
    autoCapitalize: attributes.autoCapitalize,
    "data-slate-editor": true,
    "data-slate-node": "value",
    contentEditable: readOnly ? undefined : true,
    suppressContentEditableWarning: true,
    ref: ref,
    style: _objectSpread({
      // Allow positioning relative to the editable element.
      position: 'relative',
      // Prevent the default outline styles.
      outline: 'none',
      // Preserve adjacent whitespace and new lines.
      whiteSpace: 'pre-wrap',
      // Allow words to break if they are too long.
      wordWrap: 'break-word'
    }, style),
    onCopy: useCallback(event => {
      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy)) {
        event.preventDefault();
        ReactEditor.setFragmentData(editor, event.clipboardData, 'copy');
      }
    }, [attributes.onCopy]),
    onCut: useCallback(event => {
      if (!readOnly && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut)) {
        event.preventDefault();
        ReactEditor.setFragmentData(editor, event.clipboardData, 'cut');
        var {
          selection
        } = editor;

        if (selection) {
          if (Range.isExpanded(selection)) {
            Editor$1.deleteFragment(editor);
          } else {
            var node = Node.parent(editor, selection.anchor.path);

            if (Editor$1.isVoid(editor, node)) {
              Transforms.delete(editor);
            }
          }
        }
      }
    }, [readOnly, attributes.onCut]),
    onFocus: useCallback(event => {
      if (!readOnly && !state.isUpdatingSelection && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {
        var root = ReactEditor.findDocumentOrShadowRoot(editor);
        state.latestElement = root.activeElement;
        IS_FOCUSED.set(editor, true);
      }
    }, [readOnly, attributes.onFocus]),
    onBlur: useCallback(event => {
      if (readOnly || state.isUpdatingSelection || !hasEditableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {
        return;
      } // COMPAT: If the current `activeElement` is still the previous
      // one, this is due to the window being blurred when the tab
      // itself becomes unfocused, so we want to abort early to allow to
      // editor to stay focused when the tab becomes focused again.


      var root = ReactEditor.findDocumentOrShadowRoot(editor);

      if (state.latestElement === root.activeElement) {
        return;
      }

      var {
        relatedTarget
      } = event;
      var el = ReactEditor.toDOMNode(editor, editor); // COMPAT: The event should be ignored if the focus is returning
      // to the editor from an embedded editable element (eg. an <input>
      // element inside a void node).

      if (relatedTarget === el) {
        return;
      } // COMPAT: The event should be ignored if the focus is moving from
      // the editor to inside a void node's spacer element.


      if (isDOMElement(relatedTarget) && relatedTarget.hasAttribute('data-slate-spacer')) {
        return;
      } // COMPAT: The event should be ignored if the focus is moving to a
      // non- editable section of an element that isn't a void node (eg.
      // a list item of the check list example).


      if (relatedTarget != null && isDOMNode(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {
        var node = ReactEditor.toSlateNode(editor, relatedTarget);

        if (Element$1.isElement(node) && !editor.isVoid(node)) {
          return;
        }
      }

      IS_FOCUSED.delete(editor);
    }, [readOnly, attributes.onBlur]),
    onClick: useCallback(event => {
      if (!readOnly && hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && isDOMNode(event.target)) {
        var node = ReactEditor.toSlateNode(editor, event.target);
        var path = ReactEditor.findPath(editor, node); // At this time, the Slate document may be arbitrarily different,
        // because onClick handlers can change the document before we get here.
        // Therefore we must check that this path actually exists,
        // and that it still refers to the same node.

        if (Editor$1.hasPath(editor, path)) {
          var lookupNode = Node.get(editor, path);

          if (lookupNode === node) {
            var _start = Editor$1.start(editor, path);

            var end = Editor$1.end(editor, path);
            var startVoid = Editor$1.void(editor, {
              at: _start
            });
            var endVoid = Editor$1.void(editor, {
              at: end
            });

            if (startVoid && endVoid && Path.equals(startVoid[1], endVoid[1])) {
              var range = Editor$1.range(editor, _start);
              Transforms.select(editor, range);
            }
          }
        }
      }
    }, [readOnly, attributes.onClick]),
    onCompositionEnd: useCallback(event => {
      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionEnd)) {
        scheduleOnDOMSelectionChange.flush();
        setTimeout(() => {
          state.isComposing && setIsComposing(false);
          state.isComposing = false;
          IS_COMPOSING.set(editor, false);
          IS_ON_COMPOSITION_END.set(editor, true);
          var insertedText = EDITOR_ON_COMPOSITION_TEXT.get(editor) || []; // `insertedText` is set in `MutationObserver` constructor.
          // If open phone keyboard association function, `CompositionEvent` will be triggered.

          if (!insertedText.length) {
            return;
          }

          EDITOR_ON_COMPOSITION_TEXT.set(editor, []);
          var {
            selection
          } = editor;
          insertedText.forEach(insertion => {
            var text = insertion.text.insertText;
            var at = normalizeTextInsertionRange(editor, selection, insertion);
            Transforms.setSelection(editor, at);
            Editor$1.insertText(editor, text);
          });
        }, RESOLVE_DELAY);
      }
    }, [attributes.onCompositionEnd]),
    onCompositionUpdate: useCallback(event => {
      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionUpdate)) {
        !state.isComposing && setIsComposing(true);
        state.isComposing = true;
        IS_COMPOSING.set(editor, true);
      }
    }, [attributes.onCompositionUpdate]),
    onCompositionStart: useCallback(event => {
      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionStart)) {
        !state.isComposing && setIsComposing(true);
        state.isComposing = true;
        IS_COMPOSING.set(editor, true);
      }
    }, [attributes.onCompositionStart]),
    onPaste: useCallback(event => {
      // this will make application/x-slate-fragment exist when onPaste attributes is passed
      event.clipboardData = getClipboardData(event.clipboardData); // This unfortunately needs to be handled with paste events instead.

      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste) && !readOnly) {
        event.preventDefault();
        ReactEditor.insertData(editor, event.clipboardData);
      }
    }, [readOnly, attributes.onPaste])
  }), useChildren({
    decorations,
    node: editor,
    renderElement,
    renderPlaceholder,
    renderLeaf,
    selection: editor.selection
  }))));
};

/**
 * A React context for sharing the `focused` state of the editor.
 */

var FocusedContext = /*#__PURE__*/createContext(false);
/**
 * A React context for sharing the editor selector context in a way to control rerenders
 */


var SlateSelectorContext = /*#__PURE__*/createContext({});
/**
 * Create selector context with editor updating on every editor change
 */

function getSelectorContext(editor) {
  var eventListeners = useRef([]).current;
  var slateRef = useRef({
    editor
  }).current;
  var onChange = useCallback(editor => {
    slateRef.editor = editor;
    eventListeners.forEach(listener => listener(editor));
  }, []);
  var selectorContext = useMemo(() => {
    return {
      getSlate: () => slateRef.editor,
      addEventListener: callback => {
        eventListeners.push(callback);
        return () => {
          eventListeners.splice(eventListeners.indexOf(callback), 1);
        };
      }
    };
  }, [eventListeners, slateRef]);
  return {
    selectorContext,
    onChange
  };
}

var _excluded$4 = ["editor", "children", "onChange", "value"];
/**
 * A wrapper around the provider to handle `onChange` events, because the editor
 * is a mutable singleton so it won't ever register as "changed" otherwise.
 */

var Slate = props => {
  var {
    editor,
    children,
    onChange,
    value
  } = props,
      rest = _objectWithoutProperties(props, _excluded$4);

  var unmountRef = useRef(false);
  var [context, setContext] = React__default.useState(() => {
    if (!Node.isNodeList(value)) {
      throw new Error("[Slate] value is invalid! Expected a list of elements" + "but got: ".concat(JSON.stringify(value)));
    }

    if (!Editor$1.isEditor(editor)) {
      throw new Error("[Slate] editor is invalid! you passed:" + "".concat(JSON.stringify(editor)));
    }

    editor.children = value;
    Object.assign(editor, rest);
    return [editor];
  });
  var {
    selectorContext,
    onChange: handleSelectorChange
  } = getSelectorContext(editor);
  var onContextChange = useCallback(() => {
    if (onChange) {
      onChange(editor.children);
    }

    setContext([editor]);
    handleSelectorChange(editor);
  }, [onChange]);
  EDITOR_TO_ON_CHANGE.set(editor, onContextChange);
  useEffect(() => {
    return () => {
      EDITOR_TO_ON_CHANGE.set(editor, () => {});
      unmountRef.current = true;
    };
  }, []);
  var [isFocused, setIsFocused] = useState(ReactEditor.isFocused(editor));
  useEffect(() => {
    setIsFocused(ReactEditor.isFocused(editor));
  });
  useIsomorphicLayoutEffect(() => {
    var fn = () => setIsFocused(ReactEditor.isFocused(editor));

    if (IS_REACT_VERSION_17_OR_ABOVE) {
      // In React >= 17 onFocus and onBlur listen to the focusin and focusout events during the bubbling phase.
      // Therefore in order for <Editable />'s handlers to run first, which is necessary for ReactEditor.isFocused(editor)
      // to return the correct value, we have to listen to the focusin and focusout events without useCapture here.
      document.addEventListener('focusin', fn);
      document.addEventListener('focusout', fn);
      return () => {
        document.removeEventListener('focusin', fn);
        document.removeEventListener('focusout', fn);
      };
    } else {
      document.addEventListener('focus', fn, true);
      document.addEventListener('blur', fn, true);
      return () => {
        document.removeEventListener('focus', fn, true);
        document.removeEventListener('blur', fn, true);
      };
    }
  }, []);
  return /*#__PURE__*/React__default.createElement(SlateSelectorContext.Provider, {
    value: selectorContext
  }, /*#__PURE__*/React__default.createElement(SlateContext.Provider, {
    value: context
  }, /*#__PURE__*/React__default.createElement(EditorContext.Provider, {
    value: editor
  }, /*#__PURE__*/React__default.createElement(FocusedContext.Provider, {
    value: isFocused
  }, children))));
};

/**
 * Utilities for single-line deletion
 */

var doRectsIntersect = (rect, compareRect) => {
  var middle = (compareRect.top + compareRect.bottom) / 2;
  return rect.top <= middle && rect.bottom >= middle;
};

var areRangesSameLine = (editor, range1, range2) => {
  var rect1 = ReactEditor.toDOMRange(editor, range1).getBoundingClientRect();
  var rect2 = ReactEditor.toDOMRange(editor, range2).getBoundingClientRect();
  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);
};
/**
 * A helper utility that returns the end portion of a `Range`
 * which is located on a single line.
 *
 * @param {Editor} editor The editor object to compare against
 * @param {Range} parentRange The parent range to compare against
 * @returns {Range} A valid portion of the parentRange which is one a single line
 */


var findCurrentLineRange = (editor, parentRange) => {
  var parentRangeBoundary = Editor$1.range(editor, Range.end(parentRange));
  var positions = Array.from(Editor$1.positions(editor, {
    at: parentRange
  }));
  var left = 0;
  var right = positions.length;
  var middle = Math.floor(right / 2);

  if (areRangesSameLine(editor, Editor$1.range(editor, positions[left]), parentRangeBoundary)) {
    return Editor$1.range(editor, positions[left], parentRangeBoundary);
  }

  if (positions.length < 2) {
    return Editor$1.range(editor, positions[positions.length - 1], parentRangeBoundary);
  }

  while (middle !== positions.length && middle !== left) {
    if (areRangesSameLine(editor, Editor$1.range(editor, positions[middle]), parentRangeBoundary)) {
      right = middle;
    } else {
      left = middle;
    }

    middle = Math.floor((left + right) / 2);
  }

  return Editor$1.range(editor, positions[right], parentRangeBoundary);
};

/**
 * `withReact` adds React and DOM specific behaviors to the editor.
 *
 * If you are using TypeScript, you must extend Slate's CustomTypes to use
 * this plugin.
 *
 * See https://docs.slatejs.org/concepts/11-typescript to learn how.
 */

var withReact = editor => {
  var e = editor;
  var {
    apply,
    onChange,
    deleteBackward
  } = e; // The WeakMap which maps a key to a specific HTMLElement must be scoped to the editor instance to
  // avoid collisions between editors in the DOM that share the same value.

  EDITOR_TO_KEY_TO_ELEMENT.set(e, new WeakMap());

  e.deleteBackward = unit => {
    if (unit !== 'line') {
      return deleteBackward(unit);
    }

    if (editor.selection && Range.isCollapsed(editor.selection)) {
      var parentBlockEntry = Editor$1.above(editor, {
        match: n => Editor$1.isBlock(editor, n),
        at: editor.selection
      });

      if (parentBlockEntry) {
        var [, parentBlockPath] = parentBlockEntry;
        var parentElementRange = Editor$1.range(editor, parentBlockPath, editor.selection.anchor);
        var currentLineRange = findCurrentLineRange(e, parentElementRange);

        if (!Range.isCollapsed(currentLineRange)) {
          Transforms.delete(editor, {
            at: currentLineRange
          });
        }
      }
    }
  }; // This attempts to reset the NODE_TO_KEY entry to the correct value
  // as apply() changes the object reference and hence invalidates the NODE_TO_KEY entry


  e.apply = op => {
    var matches = [];

    switch (op.type) {
      case 'insert_text':
      case 'remove_text':
      case 'set_node':
      case 'split_node':
        {
          matches.push(...getMatches(e, op.path));
          break;
        }

      case 'set_selection':
        {
          var _EDITOR_TO_USER_SELEC;

          // Selection was manually set, don't restore the user selection after the change.
          (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(editor)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();
          EDITOR_TO_USER_SELECTION.delete(editor);
          break;
        }

      case 'insert_node':
      case 'remove_node':
        {
          matches.push(...getMatches(e, Path.parent(op.path)));
          break;
        }

      case 'merge_node':
        {
          var prevPath = Path.previous(op.path);
          matches.push(...getMatches(e, prevPath));
          break;
        }

      case 'move_node':
        {
          var commonPath = Path.common(Path.parent(op.path), Path.parent(op.newPath));
          matches.push(...getMatches(e, commonPath));
          break;
        }
    }

    apply(op);

    for (var [path, key] of matches) {
      var [node] = Editor$1.node(e, path);
      NODE_TO_KEY.set(node, key);
    }
  };

  e.setFragmentData = data => {
    var {
      selection
    } = e;

    if (!selection) {
      return;
    }

    var [start, end] = Range.edges(selection);
    var startVoid = Editor$1.void(e, {
      at: start.path
    });
    var endVoid = Editor$1.void(e, {
      at: end.path
    });

    if (Range.isCollapsed(selection) && !startVoid) {
      return;
    } // Create a fake selection so that we can add a Base64-encoded copy of the
    // fragment to the HTML, to decode on future pastes.


    var domRange = ReactEditor.toDOMRange(e, selection);
    var contents = domRange.cloneContents();
    var attach = contents.childNodes[0]; // Make sure attach is non-empty, since empty nodes will not get copied.

    contents.childNodes.forEach(node => {
      if (node.textContent && node.textContent.trim() !== '') {
        attach = node;
      }
    }); // COMPAT: If the end node is a void node, we need to move the end of the
    // range from the void node's spacer span, to the end of the void node's
    // content, since the spacer is before void's content in the DOM.

    if (endVoid) {
      var [voidNode] = endVoid;
      var r = domRange.cloneRange();
      var domNode = ReactEditor.toDOMNode(e, voidNode);
      r.setEndAfter(domNode);
      contents = r.cloneContents();
    } // COMPAT: If the start node is a void node, we need to attach the encoded
    // fragment to the void node's content node instead of the spacer, because
    // attaching it to empty `<div>/<span>` nodes will end up having it erased by
    // most browsers. (2018/04/27)


    if (startVoid) {
      attach = contents.querySelector('[data-slate-spacer]');
    } // Remove any zero-width space spans from the cloned DOM so that they don't
    // show up elsewhere when pasted.


    Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(zw => {
      var isNewline = zw.getAttribute('data-slate-zero-width') === 'n';
      zw.textContent = isNewline ? '\n' : '';
    }); // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up
    // in the HTML, and can be used for intra-Slate pasting. If it's a text
    // node, wrap it in a `<span>` so we have something to set an attribute on.

    if (isDOMText(attach)) {
      var span = attach.ownerDocument.createElement('span'); // COMPAT: In Chrome and Safari, if we don't add the `white-space` style
      // then leading and trailing spaces will be ignored. (2017/09/21)

      span.style.whiteSpace = 'pre';
      span.appendChild(attach);
      contents.appendChild(span);
      attach = span;
    }

    var fragment = e.getFragment();
    var string = JSON.stringify(fragment);
    var encoded = window.btoa(encodeURIComponent(string));
    attach.setAttribute('data-slate-fragment', encoded);
    data.setData('application/x-slate-fragment', encoded); // Add the content to a <div> so that we can get its inner HTML.

    var div = contents.ownerDocument.createElement('div');
    div.appendChild(contents);
    div.setAttribute('hidden', 'true');
    contents.ownerDocument.body.appendChild(div);
    data.setData('text/html', div.innerHTML);
    data.setData('text/plain', getPlainText(div));
    contents.ownerDocument.body.removeChild(div);
    return data;
  };

  e.insertData = data => {
    if (!e.insertFragmentData(data)) {
      e.insertTextData(data);
    }
  };

  e.insertFragmentData = data => {
    /**
     * Checking copied fragment from application/x-slate-fragment or data-slate-fragment
     */
    var fragment = data.getData('application/x-slate-fragment') || getSlateFragmentAttribute(data);

    if (fragment) {
      var decoded = decodeURIComponent(window.atob(fragment));
      var parsed = JSON.parse(decoded);
      e.insertFragment(parsed);
      return true;
    }

    return false;
  };

  e.insertTextData = data => {
    var text = data.getData('text/plain');

    if (text) {
      var lines = text.split(/\r\n|\r|\n/);
      var split = false;

      for (var line of lines) {
        if (split) {
          Transforms.splitNodes(e, {
            always: true
          });
        }

        e.insertText(line);
        split = true;
      }

      return true;
    }

    return false;
  };

  e.onChange = () => {
    // COMPAT: React doesn't batch `setState` hook calls, which means that the
    // children and selection can get out of sync for one render pass. So we
    // have to use this unstable API to ensure it batches them. (2019/12/03)
    // https://github.com/facebook/react/issues/14259#issuecomment-439702367
    ReactDOM.unstable_batchedUpdates(() => {
      var onContextChange = EDITOR_TO_ON_CHANGE.get(e);

      if (onContextChange) {
        onContextChange();
      }

      onChange();
    });
  };

  return e;
};

var getMatches = (e, path) => {
  var matches = [];

  for (var [n, p] of Editor$1.levels(e, {
    at: path
  })) {
    var key = ReactEditor.findKey(e, n);
    matches.push([p, key]);
  }

  return matches;
};

// Components
var Editable = IS_ANDROID ? AndroidEditable : Editable$1;

/* with love from shopstory */

const boxStyles = {
  boxSizing: "border-box",
  minWidth: "0px",
  margin: 0,
  padding: 0,
  border: 0,
  listStyle: "none"
};
const Box = /*#__PURE__*/React__default.forwardRef((props, ref) => {
  /**
   * passedProps - the props given in component code like <MyBox data-id="abc" /> (data-id is in passedProps)
   * restProps - the props given by Shopstory (like from actionWrapper)
   *
   * They are merged into "realProps".
   *
   * I know those names sucks, this needs to be cleaned up.
   */

  const {
    __compiled,
    __name,
    passedProps,
    devices,
    stitches,
    ...restProps
  } = props;
  const {
    __as,
    ...styles
  } = __compiled;
  const realProps = {
    ...restProps,
    ...passedProps
  };
  const {
    as,
    itemWrappers,
    className,
    ...restPassedProps
  } = realProps;
  const {
    boxClassName,
    componentClassName
  } = useMemo(() => {
    /**
     * Why parse+stringify?
     *
     * Because if we remove them some nested objects in styles (like media queries etc) don't work (although they exist in the object).
     * Why? My bet is this: Stitches uses CSSOM to inject styles. Maybe (for some weird reason, maybe even browser bug) if some part of the object is not in iframe scope but in parent window scope then it's somehow ignored? Absolutely no idea right now, happy this works.
     */
    const correctedStyles = getBoxStyles(JSON.parse(JSON.stringify(styles)), devices);
    const generateBoxClass = stitches.css(boxStyles);
    const generateClassName = stitches.css(correctedStyles);
    return {
      boxClassName: generateBoxClass(),
      componentClassName: generateClassName()
    };
  }, [styles.__hash]);
  return /*#__PURE__*/React__default.createElement(as || __as || "div", {
    ref,
    ...restPassedProps,
    className: [boxClassName, componentClassName, className].filter(Boolean).join(" "),
    "data-testid": __name
  }, props.children);
});

/* with love from shopstory */
// eslint-disable-next-line @typescript-eslint/ban-types
function toArray$1(scalarOrCollection) {
  if (Array.isArray(scalarOrCollection)) {
    return scalarOrCollection;
  }
  return [scalarOrCollection];
}

/* with love from shopstory */

function allDefs(context) {
  return context?.definitions.components || [];
}

/**
 * Versions with context and custom components sweep
 */

function findComponentDefinition(config, context) {
  return $findComponentDefinition(config, context);
}
function findComponentDefinitionById(id, context) {
  return $findComponentDefinitionById(id, context);
}
function findComponentDefinitionsByType(tag, context) {
  return allDefs(context).filter(def => toArray$1(def.type ?? []).includes(tag));
}

/**
 * Generic
 */

function $findComponentDefinition(config, context) {
  if (!config) {
    return undefined;
  }
  return $findComponentDefinitionById(config._component, context);
}
function $findComponentDefinitionById(id, context) {
  return allDefs(context).find(component => component.id === id);
}

/* with love from shopstory */
function isSchemaPropComponentCollectionLocalised(schemaProp) {
  return schemaProp.type === "component-collection-localised";
}
function isSchemaPropCollection(schemaProp) {
  return schemaProp.type === "component-collection" || schemaProp.type === "component-collection-localised";
}
function isSchemaPropComponent(schemaProp) {
  return schemaProp.type === "component";
}
function isSchemaPropComponentOrComponentCollection(schemaProp) {
  return isSchemaPropCollection(schemaProp) || isSchemaPropComponent(schemaProp);
}
function isSchemaPropActionTextModifier(schemaProp) {
  return schemaProp.type === "component" && schemaProp.accepts.includes("actionTextModifier");
}
function isSchemaPropTextModifier(schemaProp) {
  return schemaProp.type === "component" && schemaProp.accepts.includes("textModifier");
}
function isExternalSchemaProp(schemaProp, types) {
  return types[schemaProp.type] && types[schemaProp.type].type === "external";
}

/* with love from shopstory */
function serialize$1(value) {
  if (value instanceof Error) {
    return JSON.parse(JSON.stringify(value, Object.getOwnPropertyNames(value)));
  }
  return JSON.parse(JSON.stringify(value));
}

/* with love from shopstory */

function selectionFramePositionChanged(target, container) {
  return {
    type: "@easyblocks-editor/selection-frame-position-changed",
    payload: {
      target,
      container
    }
  };
}
function richTextChangedEvent(payload) {
  return {
    type: "@easyblocks-editor/rich-text-changed",
    payload: serialize$1(payload)
  };
}
function componentPickerOpened(path) {
  return {
    type: "@easyblocks-editor/component-picker-opened",
    payload: {
      path
    }
  };
}
function componentPickerClosed(config) {
  return {
    type: "@easyblocks-editor/component-picker-closed",
    payload: {
      config
    }
  };
}
function itemInserted(payload) {
  return {
    type: "@easyblocks-editor/item-inserted",
    payload
  };
}
function itemMoved(payload) {
  return {
    type: "@easyblocks-editor/item-moved",
    payload
  };
}

/* with love from shopstory */
function isEmptyRenderableContent(input) {
  return typeof input === "object" && input !== null && "renderableContent" in input && input.renderableContent === null;
}
z$2.object({
  documentId: z$2.string(),
  projectId: z$2.string(),
  rootContainer: z$2.string().optional(),
  preview: z$2.object({}).optional(),
  config: z$2.optional(z$2.object({}))
});
function isComponentConfig(value) {
  return typeof value === "object" && typeof value?._component === "string" && typeof value?._id === "string";
}
const localValueSchema = z$2.object({
  value: z$2.any(),
  widgetId: z$2.string()
});
function isLocalValue(value) {
  return localValueSchema.safeParse(value).success;
}

/* with love from shopstory */
// Sorry for this name
function isTrulyResponsiveValue$1(x) {
  return typeof x === "object" && x !== null && !Array.isArray(x) && x.$res === true;
}

/* with love from shopstory */
/**
 * `Object.entries` is badly typed for its reasons and this function just fixes it.
 * https://stackoverflow.com/questions/55012174/why-doesnt-object-keys-return-a-keyof-type-in-typescript
 */
function entries(o) {
  return Object.entries(o);
}

/* with love from shopstory */

function responsiveValueEntries(value) {
  const values = [];
  entries(value).forEach(_ref => {
    let [key, v] = _ref;
    if (key === "$res") return;
    values.push([key, v]);
  });
  return values;
}

/* with love from shopstory */

function responsiveValueMap(resVal, mapper) {
  if (!isTrulyResponsiveValue$1(resVal)) {
    return mapper(resVal);
  }
  const ret = {
    $res: true
  };
  responsiveValueEntries(resVal).forEach(_ref => {
    let [key, value] = _ref;
    ret[key] = mapper(value, key);
  });
  return ret;
}

/* with love from shopstory */

function getExternalValue(externalDataValue) {
  if ("error" in externalDataValue) {
    return;
  }
  return externalDataValue.value;
}
function isLocalTextReference(resource, type) {
  if (resource.id === null) {
    return false;
  }
  return type === "text" && resource.id.startsWith("local.");
}
function getExternalReferenceLocationKey(configId, fieldName, deviceId) {
  let resourceId = `${configId}.${fieldName}`;
  if (deviceId) {
    resourceId += `.${deviceId}`;
  }
  return resourceId;
}
function getResolvedExternalDataValue(externalData, configId, fieldName, value) {
  const externalReferenceLocationKey = typeof value.id === "string" && value.id.startsWith("$.") ? value.id : getExternalReferenceLocationKey(configId, fieldName);
  const externalValue = externalData[externalReferenceLocationKey];
  if (externalValue === undefined || "error" in externalValue) {
    return;
  }
  return externalValue;
}
function resolveExternalValue(responsiveResource, configId, schemaProp, externalData) {
  return responsiveValueMap(responsiveResource, (r, breakpointIndex) => {
    if (r.id) {
      // If resource field has `key` defined and its `id` starts with "$.", it means that it's a reference to the
      // root resource and we need to look for the resource with the same id as the root resource.
      const locationKey = r.key && typeof r.id === "string" && r.id.startsWith("$.") ? r.id : getExternalReferenceLocationKey(configId, schemaProp.prop, breakpointIndex);
      const externalDataValue = externalData[locationKey];
      let resourceValue;
      if (externalDataValue) {
        resourceValue = getExternalValue(externalDataValue);
      }
      if (externalDataValue === undefined || isEmptyRenderableContent(resourceValue)) {
        return;
      }
      if ("error" in externalDataValue) {
        return;
      }
      if (isCompoundExternalDataValue(externalDataValue)) {
        if (!r.key) {
          return;
        }
        const resolvedResourceValue = externalDataValue.value[r.key].value;
        if (!resolvedResourceValue) {
          return;
        }
        return resolvedResourceValue;
      }
      return resourceValue;
    }
    return;
  });
}
function isCompoundExternalDataValue(value) {
  return "type" in value && value.type === "object" && "value" in value || "error" in value;
}

/* with love from shopstory */
function resop(config, callback, devices) {
  // Decompose config into scalar configs
  const scalarConfigs = {};
  devices.forEach(device => {
    scalarConfigs[device.id] = scalarizeConfig$1(config, device.id);
  });
  const scalarOutputs = {};

  // run callback for scalar configs
  devices.forEach(device => {
    scalarOutputs[device.id] = callback(scalarConfigs[device.id], device.id);
  });
  return squashCSSResults$1(scalarOutputs, devices);
}
function squashCSSResults$1(scalarValues, devices, disableNesting) {
  // Let's check whether scalarValues represent object (for nesting) or a scalar value.
  let objectsNum = 0;
  let noObjectsNum = 0;
  let arraysNum = 0;
  for (const breakpointName in scalarValues) {
    const val = scalarValues[breakpointName];
    if (Array.isArray(val) && !disableNesting) {
      arraysNum++;
    } else if (typeof val === "object" && val !== null && !Array.isArray(val) && !disableNesting) {
      objectsNum++;
    } else if (val !== null && val !== undefined) {
      noObjectsNum++;
    }
  }

  // Only one flag can be > 0!!! Otherwise breakpoints return incompatible types
  if (objectsNum > 0 && (noObjectsNum > 0 || arraysNum > 0) || arraysNum > 0 && (noObjectsNum > 0 || objectsNum > 0) || noObjectsNum > 0 && (arraysNum > 0 || objectsNum > 0)) {
    throw new Error("This shouldn't happen. Mismatched types for different breakpoints!!!");
  }
  if (arraysNum > 0) {
    let biggestArrayLength = 0;
    for (const breakpoint in scalarValues) {
      biggestArrayLength = Math.max(biggestArrayLength, scalarValues[breakpoint].length); // {...allKeysObject, ...scalarValues[breakpoint]};
    }
    const ret = [];
    for (let i = 0; i < biggestArrayLength; i++) {
      const newScalarValues = {};
      for (const breakpoint in scalarValues) {
        let value = undefined;
        if (scalarValues[breakpoint]) {
          value = scalarValues[breakpoint][i];
        }
        newScalarValues[breakpoint] = value;
      }
      ret[i] = squashCSSResults$1(newScalarValues, devices);
    }
    return ret;
  }

  // If object -> recursion
  if (objectsNum > 0) {
    // allKeys is the object that has all the keys from all the scalar configs
    let allKeysObject = {};

    /**
     * Scalar values are like:
     *
     * {
     *    b1: { a: 10, b: 20 }
     *    b2: { a: 100, c: 300 }
     * }
     */

    for (const breakpoint in scalarValues) {
      allKeysObject = {
        ...allKeysObject,
        ...scalarValues[breakpoint]
      };
    }

    // scalarValues.forEach(scalarConfig => {
    //     allKeysObject = {...allKeysObject, ...scalarConfig};
    // });

    const allKeys = Object.keys(allKeysObject);
    const ret = {};

    /**
     * All keys are like: ['a', 'b', 'c']
     *
     * All used keys across all breakpoints
     */

    allKeys.forEach(key => {
      const newScalarValues = {};
      for (const breakpoint in scalarValues) {
        let value = undefined;
        if (scalarValues[breakpoint]) {
          value = scalarValues[breakpoint][key];
        }
        newScalarValues[breakpoint] = value;
      }
      /**
       * newScalarValues values are like:
       *
       * For key 'a':
       * {
       *      b1: 10,
       *      b2: 100
       * }
       *
       * For key 'b':
       * {
       *     b1: 20,
       *     b2: undefined
       * }
       *
       */

      /**
       * For fonts we don't want nesting + recursion. We want entire object to be passed to results.
       *
       * Later, renderer must know how to render xfont property :)
       *
       * Otherwise, media query conflicts arise and bad values are set.
       */
      ret[key] = squashCSSResults$1(newScalarValues, devices, key === "xfont");
    });
    return ret;
  }

  // Here we are sure we have scalar value, not some object to be nested. We must do 2 things:
  // - add "unset" instead of null / undefined
  // - create ResponsiveValue and normalize

  for (const key in scalarValues) {
    if (scalarValues[key] === undefined || scalarValues[key] === null) {
      scalarValues[key] = "unset";
    }
  }

  // Values (non-objects -> no nesting)
  return responsiveValueNormalize$1({
    ...scalarValues,
    $res: true
  }, devices);
}
function responsiveValueForceGet$1(value, deviceId) {
  if (isTrulyResponsiveValue(value)) {
    if (value[deviceId] === undefined) {
      const error = `You called responsiveValueForceGet with value ${JSON.stringify(value)} and deviceId: ${deviceId}. Value undefined.`;
      throw new Error(error);
    }
    return value[deviceId];
  }
  return value;
}
function isTrulyResponsiveValue(x) {
  return typeof x === "object" && x !== null && !Array.isArray(x) && x.$res === true;
}
function responsiveValueNormalize$1(arg, devices) {
  if (!isTrulyResponsiveValue(arg)) {
    return arg;
  }
  let previousVal = undefined;
  const ret = {
    $res: true
  };
  let numberOfDefinedValues = 0;
  for (let i = devices.length - 1; i >= 0; i--) {
    const breakpoint = devices[i].id;
    const val = arg[breakpoint];

    // TODO: if values are objects, it's to do
    if (typeof val === "object" && val !== null) {
      if (JSON.stringify(val) !== JSON.stringify(previousVal)) {
        ret[breakpoint] = val;
        previousVal = val;
        numberOfDefinedValues++;
      }
    } else {
      if (val !== undefined && val !== previousVal) {
        ret[breakpoint] = val;
        previousVal = val;
        numberOfDefinedValues++;
      }
    }

    // [x, null, null, y] => [x, y]
    if (i < devices.length - 1) {
      const nextBreakpoint = devices[i + 1].id;
      if (numberOfDefinedValues === 1 && ret[breakpoint] === undefined && ret[nextBreakpoint] !== undefined) {
        ret[breakpoint] = ret[nextBreakpoint];
        delete ret[nextBreakpoint];
      }
    }
  }
  if (numberOfDefinedValues === 1) {
    return ret[devices[0].id];
  }
  return ret;
}
function scalarizeConfig$1(config, breakpoint) {
  const ret = {};
  for (const prop in config) {
    ret[prop] = responsiveValueForceGet$1(config[prop], breakpoint);
  }
  return ret;
}

const EasyblocksExternalDataContext = /*#__PURE__*/createContext(null);
function useEasyblocksExternalData() {
  const context = useContext(EasyblocksExternalDataContext);
  if (!context) {
    throw new Error("useEasyblocksExternalData must be used within a EasyblocksExternalDataProvider");
  }
  return context;
}

var t="colors",n="sizes",r="space",i={gap:r,gridGap:r,columnGap:r,gridColumnGap:r,rowGap:r,gridRowGap:r,inset:r,insetBlock:r,insetBlockEnd:r,insetBlockStart:r,insetInline:r,insetInlineEnd:r,insetInlineStart:r,margin:r,marginTop:r,marginRight:r,marginBottom:r,marginLeft:r,marginBlock:r,marginBlockEnd:r,marginBlockStart:r,marginInline:r,marginInlineEnd:r,marginInlineStart:r,padding:r,paddingTop:r,paddingRight:r,paddingBottom:r,paddingLeft:r,paddingBlock:r,paddingBlockEnd:r,paddingBlockStart:r,paddingInline:r,paddingInlineEnd:r,paddingInlineStart:r,top:r,right:r,bottom:r,left:r,scrollMargin:r,scrollMarginTop:r,scrollMarginRight:r,scrollMarginBottom:r,scrollMarginLeft:r,scrollMarginX:r,scrollMarginY:r,scrollMarginBlock:r,scrollMarginBlockEnd:r,scrollMarginBlockStart:r,scrollMarginInline:r,scrollMarginInlineEnd:r,scrollMarginInlineStart:r,scrollPadding:r,scrollPaddingTop:r,scrollPaddingRight:r,scrollPaddingBottom:r,scrollPaddingLeft:r,scrollPaddingX:r,scrollPaddingY:r,scrollPaddingBlock:r,scrollPaddingBlockEnd:r,scrollPaddingBlockStart:r,scrollPaddingInline:r,scrollPaddingInlineEnd:r,scrollPaddingInlineStart:r,fontSize:"fontSizes",background:t,backgroundColor:t,backgroundImage:t,borderImage:t,border:t,borderBlock:t,borderBlockEnd:t,borderBlockStart:t,borderBottom:t,borderBottomColor:t,borderColor:t,borderInline:t,borderInlineEnd:t,borderInlineStart:t,borderLeft:t,borderLeftColor:t,borderRight:t,borderRightColor:t,borderTop:t,borderTopColor:t,caretColor:t,color:t,columnRuleColor:t,fill:t,outline:t,outlineColor:t,stroke:t,textDecorationColor:t,fontFamily:"fonts",fontWeight:"fontWeights",lineHeight:"lineHeights",letterSpacing:"letterSpacings",blockSize:n,minBlockSize:n,maxBlockSize:n,inlineSize:n,minInlineSize:n,maxInlineSize:n,width:n,minWidth:n,maxWidth:n,height:n,minHeight:n,maxHeight:n,flexBasis:n,gridTemplateColumns:n,gridTemplateRows:n,borderWidth:"borderWidths",borderTopWidth:"borderWidths",borderRightWidth:"borderWidths",borderBottomWidth:"borderWidths",borderLeftWidth:"borderWidths",borderStyle:"borderStyles",borderTopStyle:"borderStyles",borderRightStyle:"borderStyles",borderBottomStyle:"borderStyles",borderLeftStyle:"borderStyles",borderRadius:"radii",borderTopLeftRadius:"radii",borderTopRightRadius:"radii",borderBottomRightRadius:"radii",borderBottomLeftRadius:"radii",boxShadow:"shadows",textShadow:"shadows",transition:"transitions",zIndex:"zIndices"},o=(e,t)=>"function"==typeof t?{"()":Function.prototype.toString.call(t)}:t,l=()=>{const e=Object.create(null);return (t,n,...r)=>{const i=(e=>JSON.stringify(e,o))(t);return i in e?e[i]:e[i]=n(t,...r)}},s=Symbol.for("sxs.internal"),a=(e,t)=>Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)),c=e=>{for(const t in e)return !0;return !1},{hasOwnProperty:d}=Object.prototype,g=e=>e.includes("-")?e:e.replace(/[A-Z]/g,(e=>"-"+e.toLowerCase())),p=/\s+(?![^()]*\))/,u=e=>t=>e(..."string"==typeof t?String(t).split(p):[t]),h={appearance:e=>({WebkitAppearance:e,appearance:e}),backfaceVisibility:e=>({WebkitBackfaceVisibility:e,backfaceVisibility:e}),backdropFilter:e=>({WebkitBackdropFilter:e,backdropFilter:e}),backgroundClip:e=>({WebkitBackgroundClip:e,backgroundClip:e}),boxDecorationBreak:e=>({WebkitBoxDecorationBreak:e,boxDecorationBreak:e}),clipPath:e=>({WebkitClipPath:e,clipPath:e}),content:e=>({content:e.includes('"')||e.includes("'")||/^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(e)?e:`"${e}"`}),hyphens:e=>({WebkitHyphens:e,hyphens:e}),maskImage:e=>({WebkitMaskImage:e,maskImage:e}),maskSize:e=>({WebkitMaskSize:e,maskSize:e}),tabSize:e=>({MozTabSize:e,tabSize:e}),textSizeAdjust:e=>({WebkitTextSizeAdjust:e,textSizeAdjust:e}),userSelect:e=>({WebkitUserSelect:e,userSelect:e}),marginBlock:u(((e,t)=>({marginBlockStart:e,marginBlockEnd:t||e}))),marginInline:u(((e,t)=>({marginInlineStart:e,marginInlineEnd:t||e}))),maxSize:u(((e,t)=>({maxBlockSize:e,maxInlineSize:t||e}))),minSize:u(((e,t)=>({minBlockSize:e,minInlineSize:t||e}))),paddingBlock:u(((e,t)=>({paddingBlockStart:e,paddingBlockEnd:t||e}))),paddingInline:u(((e,t)=>({paddingInlineStart:e,paddingInlineEnd:t||e})))},f=/([\d.]+)([^]*)/,m=(e,t)=>e.length?e.reduce(((e,n)=>(e.push(...t.map((e=>e.includes("&")?e.replace(/&/g,/[ +>|~]/.test(n)&&/&.*&/.test(e)?`:is(${n})`:n):n+" "+e))),e)),[]):t,b=(e,t)=>e in S&&"string"==typeof t?t.replace(/^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/,((t,n,r,i)=>n+("stretch"===r?`-moz-available${i};${g(e)}:${n}-webkit-fill-available`:`-moz-fit-content${i};${g(e)}:${n}fit-content`)+i)):String(t),S={blockSize:1,height:1,inlineSize:1,maxBlockSize:1,maxHeight:1,maxInlineSize:1,maxWidth:1,minBlockSize:1,minHeight:1,minInlineSize:1,minWidth:1,width:1},k=e=>e?e+"-":"",y=(e,t,n)=>e.replace(/([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g,((e,r,i,o,l)=>"$"==o==!!i?e:(r||"--"==o?"calc(":"")+"var(--"+("$"===o?k(t)+(l.includes("$")?"":k(n))+l.replace(/\$/g,"-"):l)+")"+(r||"--"==o?"*"+(r||"")+(i||"1")+")":""))),B=/\s*,\s*(?![^()]*\))/,$=Object.prototype.toString,x=(e,t,n,r,i)=>{let o,l,s;const a=(e,t,n)=>{let c,d;const p=e=>{for(c in e){const x=64===c.charCodeAt(0),z=x&&Array.isArray(e[c])?e[c]:[e[c]];for(d of z){const e=/[A-Z]/.test(S=c)?S:S.replace(/-[^]/g,(e=>e[1].toUpperCase())),z="object"==typeof d&&d&&d.toString===$&&(!r.utils[e]||!t.length);if(e in r.utils&&!z){const t=r.utils[e];if(t!==l){l=t,p(t(d)),l=null;continue}}else if(e in h){const t=h[e];if(t!==s){s=t,p(t(d)),s=null;continue}}if(x&&(u=c.slice(1)in r.media?"@media "+r.media[c.slice(1)]:c,c=u.replace(/\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g,((e,t,n,r,i,o)=>{const l=f.test(t),s=.0625*(l?-1:1),[a,c]=l?[r,t]:[t,r];return "("+("="===n[0]?"":">"===n[0]===l?"max-":"min-")+a+":"+("="!==n[0]&&1===n.length?c.replace(f,((e,t,r)=>Number(t)+s*(">"===n?1:-1)+r)):c)+(i?") and ("+(">"===i[0]?"min-":"max-")+a+":"+(1===i.length?o.replace(f,((e,t,n)=>Number(t)+s*(">"===i?-1:1)+n)):o):"")+")"}))),z){const e=x?n.concat(c):[...n],r=x?[...t]:m(t,c.split(B));void 0!==o&&i(I(...o)),o=void 0,a(d,r,e);}else void 0===o&&(o=[[],t,n]),c=x||36!==c.charCodeAt(0)?c:`--${k(r.prefix)}${c.slice(1).replace(/\$/g,"-")}`,d=z?d:"number"==typeof d?d&&e in R?String(d)+"px":String(d):y(b(e,null==d?"":d),r.prefix,r.themeMap[e]),o[0].push(`${x?`${c} `:`${g(c)}:`}${d}`);}}var u,S;};p(e),void 0!==o&&i(I(...o)),o=void 0;};a(e,t,n);},I=(e,t,n)=>`${n.map((e=>`${e}{`)).join("")}${t.length?`${t.join(",")}{`:""}${e.join(";")}${t.length?"}":""}${Array(n.length?n.length+1:0).join("}")}`,R={animationDelay:1,animationDuration:1,backgroundSize:1,blockSize:1,border:1,borderBlock:1,borderBlockEnd:1,borderBlockEndWidth:1,borderBlockStart:1,borderBlockStartWidth:1,borderBlockWidth:1,borderBottom:1,borderBottomLeftRadius:1,borderBottomRightRadius:1,borderBottomWidth:1,borderEndEndRadius:1,borderEndStartRadius:1,borderInlineEnd:1,borderInlineEndWidth:1,borderInlineStart:1,borderInlineStartWidth:1,borderInlineWidth:1,borderLeft:1,borderLeftWidth:1,borderRadius:1,borderRight:1,borderRightWidth:1,borderSpacing:1,borderStartEndRadius:1,borderStartStartRadius:1,borderTop:1,borderTopLeftRadius:1,borderTopRightRadius:1,borderTopWidth:1,borderWidth:1,bottom:1,columnGap:1,columnRule:1,columnRuleWidth:1,columnWidth:1,containIntrinsicSize:1,flexBasis:1,fontSize:1,gap:1,gridAutoColumns:1,gridAutoRows:1,gridTemplateColumns:1,gridTemplateRows:1,height:1,inlineSize:1,inset:1,insetBlock:1,insetBlockEnd:1,insetBlockStart:1,insetInline:1,insetInlineEnd:1,insetInlineStart:1,left:1,letterSpacing:1,margin:1,marginBlock:1,marginBlockEnd:1,marginBlockStart:1,marginBottom:1,marginInline:1,marginInlineEnd:1,marginInlineStart:1,marginLeft:1,marginRight:1,marginTop:1,maxBlockSize:1,maxHeight:1,maxInlineSize:1,maxWidth:1,minBlockSize:1,minHeight:1,minInlineSize:1,minWidth:1,offsetDistance:1,offsetRotate:1,outline:1,outlineOffset:1,outlineWidth:1,overflowClipMargin:1,padding:1,paddingBlock:1,paddingBlockEnd:1,paddingBlockStart:1,paddingBottom:1,paddingInline:1,paddingInlineEnd:1,paddingInlineStart:1,paddingLeft:1,paddingRight:1,paddingTop:1,perspective:1,right:1,rowGap:1,scrollMargin:1,scrollMarginBlock:1,scrollMarginBlockEnd:1,scrollMarginBlockStart:1,scrollMarginBottom:1,scrollMarginInline:1,scrollMarginInlineEnd:1,scrollMarginInlineStart:1,scrollMarginLeft:1,scrollMarginRight:1,scrollMarginTop:1,scrollPadding:1,scrollPaddingBlock:1,scrollPaddingBlockEnd:1,scrollPaddingBlockStart:1,scrollPaddingBottom:1,scrollPaddingInline:1,scrollPaddingInlineEnd:1,scrollPaddingInlineStart:1,scrollPaddingLeft:1,scrollPaddingRight:1,scrollPaddingTop:1,shapeMargin:1,textDecoration:1,textDecorationThickness:1,textIndent:1,textUnderlineOffset:1,top:1,transitionDelay:1,transitionDuration:1,verticalAlign:1,width:1,wordSpacing:1},z=e=>String.fromCharCode(e+(e>25?39:97)),W=e=>(e=>{let t,n="";for(t=Math.abs(e);t>52;t=t/52|0)n=z(t%52)+n;return z(t%52)+n})(((e,t)=>{let n=t.length;for(;n;)e=33*e^t.charCodeAt(--n);return e})(5381,JSON.stringify(e))>>>0),j=["themed","global","styled","onevar","resonevar","allvar","inline"],E=e=>{if(e.href&&!e.href.startsWith(location.origin))return !1;try{return !!e.cssRules}catch(e){return !1}},T=e=>{let t;const n=()=>{const{cssRules:e}=t.sheet;return [].map.call(e,((n,r)=>{const{cssText:i}=n;let o="";if(i.startsWith("--sxs"))return "";if(e[r-1]&&(o=e[r-1].cssText).startsWith("--sxs")){if(!n.cssRules.length)return "";for(const e in t.rules)if(t.rules[e].group===n)return `--sxs{--sxs:${[...t.rules[e].cache].join(" ")}}${i}`;return n.cssRules.length?`${o}${i}`:""}return i})).join("")},r=()=>{if(t){const{rules:e,sheet:n}=t;if(!n.deleteRule){for(;3===Object(Object(n.cssRules)[0]).type;)n.cssRules.splice(0,1);n.cssRules=[];}for(const t in e)delete e[t];}const i=Object(e).styleSheets||[];for(const e of i)if(E(e)){for(let i=0,o=e.cssRules;o[i];++i){const l=Object(o[i]);if(1!==l.type)continue;const s=Object(o[i+1]);if(4!==s.type)continue;++i;const{cssText:a}=l;if(!a.startsWith("--sxs"))continue;const c=a.slice(14,-3).trim().split(/\s+/),d=j[c[0]];d&&(t||(t={sheet:e,reset:r,rules:{},toString:n}),t.rules[d]={group:s,index:i,cache:new Set(c)});}if(t)break}if(!t){const i=(e,t)=>({type:t,cssRules:[],insertRule(e,t){this.cssRules.splice(t,0,i(e,{import:3,undefined:1}[(e.toLowerCase().match(/^@([a-z]+)/)||[])[1]]||4));},get cssText(){return "@media{}"===e?`@media{${[].map.call(this.cssRules,(e=>e.cssText)).join("")}}`:e}});t={sheet:e?(e.head||e).appendChild(document.createElement("style")).sheet:i("","text/css"),rules:{},reset:r,toString:n};}const{sheet:o,rules:l}=t;for(let e=j.length-1;e>=0;--e){const t=j[e];if(!l[t]){const n=j[e+1],r=l[n]?l[n].index:o.cssRules.length;o.insertRule("@media{}",r),o.insertRule(`--sxs{--sxs:${e}}`,r),l[t]={group:o.cssRules[r+1],index:r,cache:new Set([e])};}v(l[t]);}};return r(),t},v=e=>{const t=e.group;let n=t.cssRules.length;e.apply=e=>{try{t.insertRule(e,n),++n;}catch(e){}};},M=Symbol(),w=l(),C=(e,t)=>w(e,(()=>(...n)=>{let r={type:null,composers:new Set};for(const t of n)if(null!=t)if(t[s]){null==r.type&&(r.type=t[s].type);for(const e of t[s].composers)r.composers.add(e);}else t.constructor!==Object||t.$$typeof?null==r.type&&(r.type=t):r.composers.add(P(t,e));return null==r.type&&(r.type="span"),r.composers.size||r.composers.add(["PJLV",{},[],[],{},[]]),L(e,r,t)})),P=({variants:e,compoundVariants:t,defaultVariants:n,...r},i)=>{const o=`${k(i.prefix)}c-${W(r)}`,l=[],s=[],a=Object.create(null),g=[];for(const e in n)a[e]=String(n[e]);if("object"==typeof e&&e)for(const t in e){p=a,u=t,d.call(p,u)||(a[t]="undefined");const n=e[t];for(const e in n){const r={[t]:String(e)};"undefined"===String(e)&&g.push(t);const i=n[e],o=[r,i,!c(i)];l.push(o);}}var p,u;if("object"==typeof t&&t)for(const e of t){let{css:t,...n}=e;t="object"==typeof t&&t||{};for(const e in n)n[e]=String(n[e]);const r=[n,t,!c(t)];s.push(r);}return [o,r,l,s,a,g]},L=(e,t,n)=>{const[r,i,o,l]=O(t.composers),c="function"==typeof t.type||t.type.$$typeof?(e=>{function t(){for(let n=0;n<t[M].length;n++){const[r,i]=t[M][n];e.rules[r].apply(i);}return t[M]=[],null}return t[M]=[],t.rules={},j.forEach((e=>t.rules[e]={apply:n=>t[M].push([e,n])})),t})(n):null,d=(c||n).rules,g=`.${r}${i.length>1?`:where(.${i.slice(1).join(".")})`:""}`,p=s=>{s="object"==typeof s&&s||D;const{css:a,...p}=s,u={};for(const e in o)if(delete p[e],e in s){let t=s[e];"object"==typeof t&&t?u[e]={"@initial":o[e],...t}:(t=String(t),u[e]="undefined"!==t||l.has(e)?t:o[e]);}else u[e]=o[e];const h=new Set([...i]);for(const[r,i,o,l]of t.composers){n.rules.styled.cache.has(r)||(n.rules.styled.cache.add(r),x(i,[`.${r}`],[],e,(e=>{d.styled.apply(e);})));const t=A(o,u,e.media),s=A(l,u,e.media,!0);for(const i of t)if(void 0!==i)for(const[t,o,l]of i){const i=`${r}-${W(o)}-${t}`;h.add(i);const s=(l?n.rules.resonevar:n.rules.onevar).cache,a=l?d.resonevar:d.onevar;s.has(i)||(s.add(i),x(o,[`.${i}`],[],e,(e=>{a.apply(e);})));}for(const t of s)if(void 0!==t)for(const[i,o]of t){const t=`${r}-${W(o)}-${i}`;h.add(t),n.rules.allvar.cache.has(t)||(n.rules.allvar.cache.add(t),x(o,[`.${t}`],[],e,(e=>{d.allvar.apply(e);})));}}if("object"==typeof a&&a){const t=`${r}-i${W(a)}-css`;h.add(t),n.rules.inline.cache.has(t)||(n.rules.inline.cache.add(t),x(a,[`.${t}`],[],e,(e=>{d.inline.apply(e);})));}for(const e of String(s.className||"").trim().split(/\s+/))e&&h.add(e);const f=p.className=[...h].join(" ");return {type:t.type,className:f,selector:g,props:p,toString:()=>f,deferredInjector:c}};return a(p,{className:r,selector:g,[s]:t,toString:()=>(n.rules.styled.cache.has(r)||p(),r)})},O=e=>{let t="";const n=[],r={},i=[];for(const[o,,,,l,s]of e){""===t&&(t=o),n.push(o),i.push(...s);for(const e in l){const t=l[e];(void 0===r[e]||"undefined"!==t||s.includes(t))&&(r[e]=t);}}return [t,n,r,new Set(i)]},A=(e,t,n,r)=>{const i=[];e:for(let[o,l,s]of e){if(s)continue;let e,a=0,c=!1;for(e in o){const r=o[e];let i=t[e];if(i!==r){if("object"!=typeof i||!i)continue e;{let e,t,o=0;for(const l in i){if(r===String(i[l])){if("@initial"!==l){const e=l.slice(1);(t=t||[]).push(e in n?n[e]:l.replace(/^@media ?/,"")),c=!0;}a+=o,e=!0;}++o;}if(t&&t.length&&(l={["@media "+t.join(", ")]:l}),!e)continue e}}}(i[a]=i[a]||[]).push([r?"cv":`${e}-${o[e]}`,l,c]);}return i},D={},H=l(),N=(e,t)=>H(e,(()=>(...n)=>{const r=()=>{for(let r of n){r="object"==typeof r&&r||{};let n=W(r);if(!t.rules.global.cache.has(n)){if(t.rules.global.cache.add(n),"@import"in r){let e=[].indexOf.call(t.sheet.cssRules,t.rules.themed.group)-1;for(let n of [].concat(r["@import"]))n=n.includes('"')||n.includes("'")?n:`"${n}"`,t.sheet.insertRule(`@import ${n};`,e++);delete r["@import"];}x(r,[],[],e,(e=>{t.rules.global.apply(e);}));}}return ""};return a(r,{toString:r})})),V=l(),G=(e,t)=>V(e,(()=>n=>{const r=`${k(e.prefix)}k-${W(n)}`,i=()=>{if(!t.rules.global.cache.has(r)){t.rules.global.cache.add(r);const i=[];x(n,[],[],e,(e=>i.push(e)));const o=`@keyframes ${r}{${i.join("")}}`;t.rules.global.apply(o);}return r};return a(i,{get name(){return i()},toString:i})})),F=class{constructor(e,t,n,r){this.token=null==e?"":String(e),this.value=null==t?"":String(t),this.scale=null==n?"":String(n),this.prefix=null==r?"":String(r);}get computedValue(){return "var("+this.variable+")"}get variable(){return "--"+k(this.prefix)+k(this.scale)+this.token}toString(){return this.computedValue}},J=l(),U=(e,t)=>J(e,(()=>(n,r)=>{r="object"==typeof n&&n||Object(r);const i=`.${n=(n="string"==typeof n?n:"")||`${k(e.prefix)}t-${W(r)}`}`,o={},l=[];for(const t in r){o[t]={};for(const n in r[t]){const i=`--${k(e.prefix)}${t}-${n}`,s=y(String(r[t][n]),e.prefix,t);o[t][n]=new F(n,s,t,e.prefix),l.push(`${i}:${s}`);}}const s=()=>{if(l.length&&!t.rules.themed.cache.has(n)){t.rules.themed.cache.add(n);const i=`${r===e.theme?":root,":""}.${n}{${l.join(";")}}`;t.rules.themed.apply(i);}return n};return {...o,get className(){return s()},selector:i,toString:s}})),Z=l(),X=e=>{let t=!1;const n=Z(e,(e=>{t=!0;const n="prefix"in(e="object"==typeof e&&e||{})?String(e.prefix):"",r="object"==typeof e.media&&e.media||{},o="object"==typeof e.root?e.root||null:globalThis.document||null,l="object"==typeof e.theme&&e.theme||{},s={prefix:n,media:r,theme:l,themeMap:"object"==typeof e.themeMap&&e.themeMap||{...i},utils:"object"==typeof e.utils&&e.utils||{}},a=T(o),c={css:C(s,a),globalCss:N(s,a),keyframes:G(s,a),createTheme:U(s,a),reset(){a.reset(),c.theme.toString();},theme:{},sheet:a,config:s,prefix:n,getCssText:a.toString,toString:a.toString};return String(c.theme=c.createTheme(l)),c}));return t||n.reset(),n};//# sourceMappingUrl=index.map

/* with love from shopstory */

const easyblocksStitchesInstances = [];

const EasyblocksMetadataContext = /*#__PURE__*/createContext(undefined);
const EasyblocksMetadataProvider = _ref => {
  let {
    meta,
    children
  } = _ref;
  // Let's load stitches instance
  if (easyblocksStitchesInstances.length === 0) {
    easyblocksStitchesInstances.push(X({}));
  }
  return /*#__PURE__*/React__default.createElement(EasyblocksMetadataContext.Provider, {
    value: {
      ...meta,
      stitches: easyblocksStitchesInstances[0]
    }
  }, children);
};
function useEasyblocksMetadata() {
  const context = useContext(EasyblocksMetadataContext);
  if (!context) {
    throw new Error("useEasyblocksMetadata must be used within a EasyblocksMetadataProvider");
  }
  return context;
}

/* with love from shopstory */

function responsiveValueValues(value) {
  const values = [];
  entries(value).forEach(_ref => {
    let [key, v] = _ref;
    if (key === "$res") return;
    values.push(v);
  });
  return values;
}

/* with love from shopstory */

function responsiveValueReduce(resVal, reducer, initialValue, devices) {
  if (!isTrulyResponsiveValue$1(resVal)) {
    return reducer(initialValue, resVal);
  }
  let result = initialValue;
  for (let i = 0; i < devices.length; i++) {
    const key = devices[i].id;
    if (resVal[key] === undefined) {
      continue;
    }
    result = reducer(result, resVal[key], key);
  }
  return result;
}

/* with love from shopstory */

function responsiveValueGet(value, deviceId) {
  if (isTrulyResponsiveValue$1(value)) {
    return value[deviceId];
  }
  return value;
}
function responsiveValueForceGet(value, deviceId) {
  if (isTrulyResponsiveValue$1(value)) {
    if (value[deviceId] === undefined) {
      const error = `You called responsiveValueForceGet with value ${JSON.stringify(value)} and deviceId: ${deviceId}. Value undefined.`;
      throw new Error(error);
    }
    return value[deviceId];
  }
  return value;
}

/* with love from shopstory */

function getDeviceWidthPairs(widths, devices) {
  const componentWidths = [];
  for (const key in widths) {
    if (key === "$res") {
      continue;
    }
    componentWidths.push({
      width: responsiveValueForceGet(widths, key),
      deviceId: key
    });
  }
  componentWidths.sort((x, y) => {
    if (x.width === y.width) {
      const xDevicesIndex = devices.findIndex(d => d.id === x.deviceId);
      const yDevicesIndex = devices.findIndex(d => d.id === y.deviceId);
      return xDevicesIndex > yDevicesIndex ? 1 : -1;
    }
    return x.width === y.width ? 0 : x.width > y.width ? 1 : -1;
  });
  return componentWidths;
}
function getDeviceWidthPairsFromDevices(devices) {
  return devices.map(d => ({
    width: d.w,
    deviceId: d.id
  }));
}

/* with love from shopstory */

function responsiveValueFindHigherDeviceWithDefinedValue(value, breakpoint, devices, widths) {
  const componentWidths = widths ? getDeviceWidthPairs(widths, devices) : getDeviceWidthPairsFromDevices(devices);
  const componentWidthIndex = componentWidths.findIndex(x => x.deviceId === breakpoint);
  const componentWidth = devices[componentWidthIndex];
  if (!componentWidth) {
    throw new Error("undefined breakpoint");
  }

  //
  // if (device.breakpoint === null) {
  //   return;
  // }

  for (let i = componentWidthIndex + 1; i <= componentWidths.length - 1; i++) {
    const deviceId = componentWidths[i].deviceId;
    if (value[deviceId] !== undefined) {
      return devices.find(d => d.id === deviceId);
    }
  }
  return undefined;
}
function responsiveValueFindLowerDeviceWithDefinedValue(value, breakpoint, devices, widths) {
  const componentWidths = widths ? getDeviceWidthPairs(widths, devices) : getDeviceWidthPairsFromDevices(devices);
  const componentWidthIndex = componentWidths.findIndex(x => x.deviceId === breakpoint);
  const componentWidth = devices[componentWidthIndex];
  if (!componentWidth) {
    throw new Error("undefined breakpoint");
  }
  for (let i = componentWidthIndex - 1; i >= 0; i--) {
    const deviceId = componentWidths[i].deviceId;
    if (value[deviceId] !== undefined) {
      return devices.find(d => d.id === deviceId);
    }
  }
  return undefined;
}
function responsiveValueFindDeviceWithDefinedValue(value, breakpoint, devices, widths) {
  if (value[breakpoint] !== undefined) {
    return devices.find(x => x.id === breakpoint);
  }
  const higherDevice = responsiveValueFindHigherDeviceWithDefinedValue(value, breakpoint, devices, widths);
  if (higherDevice !== undefined) {
    return higherDevice;
  }
  const lowerDevice = responsiveValueFindLowerDeviceWithDefinedValue(value, breakpoint, devices, widths);
  if (lowerDevice !== undefined) {
    return lowerDevice;
  }
  return undefined;
}

/* with love from shopstory */

function responsiveValueGetFirstHigherValue(value, breakpoint, devices, widths) {
  const higherDefinedDevice = responsiveValueFindHigherDeviceWithDefinedValue(value, breakpoint, devices, widths);
  if (!higherDefinedDevice) {
    return;
  }
  return value[higherDefinedDevice.id];
}
function responsiveValueGetFirstLowerValue(value, breakpoint, devices, widths) {
  const lowerDefinedDevice = responsiveValueFindLowerDeviceWithDefinedValue(value, breakpoint, devices, widths);
  if (!lowerDefinedDevice) {
    return;
  }
  return value[lowerDefinedDevice.id];
}
function responsiveValueGetDefinedValue(value, breakpoint, devices, widths) {
  if (!isTrulyResponsiveValue$1(value)) {
    return value;
  }
  const definedDevice = responsiveValueFindDeviceWithDefinedValue(value, breakpoint, devices, widths);
  if (!definedDevice) {
    return;
  }
  return value[definedDevice.id];
}

/* with love from shopstory */

function buildBoxes(compiled, name, actionWrappers, meta) {
  if (Array.isArray(compiled)) {
    return compiled.map((x, index) => buildBoxes(x, `${name}.${index}`, actionWrappers, meta));
  } else if (typeof compiled === "object" && compiled !== null) {
    if (compiled.__isBox) {
      const boxProps = {
        __compiled: compiled,
        __name: name,
        devices: meta.vars.devices,
        stitches: meta.stitches
      };
      return /*#__PURE__*/React__default.createElement(Box, boxProps);
    }
    const ret = {};
    for (const key in compiled) {
      ret[key] = buildBoxes(compiled[key], key, actionWrappers, meta);
    }
    return ret;
  }
  return compiled;
}
function getComponentDefinition(compiled, runtimeContext) {
  return findComponentDefinitionById(compiled._component, runtimeContext);
}

/**
 * Checks whether:
 * 1. component is renderable (if all non-optional externals are defined)
 * 2. is data loading...
 * 3. gets fields that are not defined
 *
 * @param compiled
 * @param runtimeContext
 * @param rendererContext
 */

function getRenderabilityStatus(compiled, meta, externalData) {
  const status = {
    renderable: true,
    isLoading: false,
    fieldsRequiredToRender: new Set()
  };
  const componentDefinition = getComponentDefinition(compiled, {
    definitions: meta.vars.definitions
  });
  if (!componentDefinition) {
    return {
      renderable: false,
      isLoading: false,
      fieldsRequiredToRender: new Set()
    };
  }
  const requiredExternalFields = componentDefinition.schema.filter(schemaProp => {
    if (schemaProp.type === "text") {
      return false;
    }
    const propValue = compiled.props[schemaProp.prop];
    if (typeof propValue === "object" && propValue !== null && "id" in propValue && "widgetId" in propValue) {
      if ("optional" in schemaProp) {
        return !schemaProp.optional;
      }
      return true;
    }
    return false;
  });
  if (requiredExternalFields.length === 0) {
    return status;
  }
  for (const resourceSchemaProp of requiredExternalFields) {
    const externalReference = compiled.props[resourceSchemaProp.prop];
    const fieldStatus = getFieldStatus(externalReference, externalData, compiled._id, resourceSchemaProp.prop, meta.vars.devices);
    status.isLoading = status.isLoading || fieldStatus.isLoading;
    status.renderable = status.renderable && fieldStatus.renderable;
    if (!fieldStatus.renderable && !fieldStatus.isLoading) {
      status.fieldsRequiredToRender.add(resourceSchemaProp.label || resourceSchemaProp.prop);
    }
  }
  return status;
}
function getCompiledSubcomponents(id, compiledArray, contextProps, schemaProp, path, meta, isEditing, components) {
  const originalPath = path;
  if (schemaProp.type === "component-collection-localised") {
    path = path + "." + meta.vars.locale;
  }
  if (schemaProp.noInline) {
    const elements = compiledArray.map((compiledChild, index) => "_component" in compiledChild ? /*#__PURE__*/React__default.createElement(ComponentBuilder, {
      path: `${path}.${index}`,
      compiled: compiledChild,
      components: components
    }) : compiledChild);
    if (isSchemaPropComponent(schemaProp)) {
      return elements[0];
    } else {
      return elements;
    }
  }
  const EditableComponentBuilder = isEditing ? components["EditableComponentBuilder.editor"] : components["EditableComponentBuilder.client"];
  let elements = compiledArray.map((compiledChild, index) => "_component" in compiledChild ? /*#__PURE__*/React__default.createElement(EditableComponentBuilder, {
    compiled: compiledChild,
    index: index,
    length: compiledArray.length,
    path: `${path}.${index}`,
    components: components
  }) : compiledChild);
  const Placeholder = components["Placeholder"];

  // TODO: this code should be editor-only
  if (isEditing && Placeholder && elements.length === 0 && !contextProps.noInline &&
  // We don't want to show add button for this type
  schemaProp.type !== "component-collection-localised") {
    const type = getComponentMainType(schemaProp.accepts);
    elements = [/*#__PURE__*/React__default.createElement(Placeholder, {
      id: id,
      path: path,
      type: type,
      appearance: schemaProp.placeholderAppearance,
      onClick: () => {
        function handleComponentPickerCloseMessage(event) {
          if (event.data.type === "@easyblocks-editor/component-picker-closed") {
            window.removeEventListener("message", handleComponentPickerCloseMessage);
            if (event.data.payload.config) {
              window.parent.postMessage(itemInserted({
                name: path,
                index: 0,
                block: event.data.payload.config
              }));
            }
          }
        }
        window.addEventListener("message", handleComponentPickerCloseMessage);
        window.parent.postMessage(componentPickerOpened(originalPath));
      },
      meta: meta
    })];
  }
  if (isSchemaPropComponent(schemaProp)) {
    return elements[0] ?? /*#__PURE__*/React__default.createElement(Fragment, null);
  } else {
    return elements;
  }
}
function ComponentBuilder(props) {
  const {
    compiled,
    passedProps,
    path,
    components,
    ...restProps
  } = props;
  const allPassedProps = {
    ...passedProps,
    ...restProps
  };
  const meta = useEasyblocksMetadata();
  const externalData = useEasyblocksExternalData();

  /**
   * Component is build in editing mode only if compiled.__editing is set.
   * This is the result of compilation.
   * The only case when compiled.__editing is set is when we're in Editor and for non-nested components.
   */
  const isEditing = compiled.__editing !== undefined;
  const pathSeparator = path === "" ? "" : ".";

  // Here we know we must render just component, without any wrappers
  const componentDefinition = getComponentDefinition(compiled, {
    definitions: meta.vars.definitions
  });
  const component = getComponent(componentDefinition, components, isEditing);
  const isMissingComponent = compiled._component === "@easyblocks/missing-component";
  const isMissingInstance = component === undefined;
  const isMissing = isMissingComponent || isMissingInstance;
  const MissingComponent = components["@easyblocks/missing-component"];
  if (isMissing) {
    if (!isEditing) {
      return null;
    }
    if (isMissingComponent) {
      return /*#__PURE__*/React__default.createElement(MissingComponent, {
        error: true
      }, "Missing");
    } else {
      console.warn(`Missing "${compiled._component}"`);
      return /*#__PURE__*/React__default.createElement(MissingComponent, {
        component: componentDefinition,
        error: true
      }, "Missing");
    }
  }
  const Component = component;
  const renderabilityStatus = getRenderabilityStatus(compiled, meta, externalData);
  if (!renderabilityStatus.renderable) {
    const fieldsRequiredToRender = Array.from(renderabilityStatus.fieldsRequiredToRender);
    return /*#__PURE__*/React__default.createElement(MissingComponent, {
      component: componentDefinition
    }, `Fill following fields to render the component: ${fieldsRequiredToRender.join(", ")}`, renderabilityStatus.isLoading && /*#__PURE__*/React__default.createElement(Fragment, null, /*#__PURE__*/React__default.createElement("br", null), /*#__PURE__*/React__default.createElement("br", null), "Loading data..."));
  }
  const shopstoryCompiledConfig = compiled;

  // Shopstory component
  const styled = buildBoxes(shopstoryCompiledConfig.styled, "", {}, meta);

  // Styled
  componentDefinition.schema.forEach(schemaProp => {
    if (isSchemaPropComponentOrComponentCollection(schemaProp)) {
      const contextProps = shopstoryCompiledConfig.__editing?.components?.[schemaProp.prop] || {};
      const compiledChildren = shopstoryCompiledConfig.components[schemaProp.prop];
      styled[schemaProp.prop] = getCompiledSubcomponents(compiled._id, compiledChildren, contextProps, schemaProp, `${path}${pathSeparator}${schemaProp.prop}`, meta, isEditing, components);
    }
  });

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const {
    ref,
    __isSelected,
    ...restPassedProps
  } = allPassedProps || {};
  const runtime = {
    stitches: meta.stitches,
    resop: resop,
    devices: meta.vars.devices
  };
  const easyblocksProp = {
    id: shopstoryCompiledConfig._id,
    isEditing,
    path,
    runtime,
    isSelected: __isSelected
  };
  const componentProps = {
    ...restPassedProps,
    ...mapExternalProps(shopstoryCompiledConfig.props, shopstoryCompiledConfig._id, componentDefinition, externalData),
    ...styled,
    __easyblocks: easyblocksProp
  };
  return /*#__PURE__*/React__default.createElement(Component, componentProps);
}
function getComponent(componentDefinition, components, isEditing) {
  let component;

  // We first try to find editor version of that component
  if (isEditing) {
    component = components[componentDefinition.id + ".editor"];
  }

  // If it still missing, we try to find client version of that component
  if (!component) {
    component = components[componentDefinition.id + ".client"];
  }
  if (!component) {
    // In most cases we're going to pick component by its id
    component = components[componentDefinition.id];
  }
  return component;
}
function mapExternalProps(props, configId, componentDefinition, externalData) {
  const resultsProps = {};
  for (const propName in props) {
    const schemaProp = componentDefinition.schema.find(currentSchema => currentSchema.prop === propName);
    if (schemaProp) {
      const propValue = props[propName];
      if (schemaProp.type === "text" && isLocalTextReference(propValue, "text")) {
        resultsProps[propName] = propValue.value;
      } else if (
      // FIXME: this is a mess
      !isTrulyResponsiveValue$1(propValue) && typeof propValue === "object" && "id" in propValue && "widgetId" in propValue && !("value" in propValue) || isTrulyResponsiveValue$1(propValue) && responsiveValueValues(propValue).every(v => typeof v === "object" && v && "id" in v && "widgetId" in v && !("value" in v))) {
        resultsProps[propName] = resolveExternalValue(propValue, configId, schemaProp, externalData);
      } else {
        resultsProps[propName] = props[propName];
      }
    } else {
      resultsProps[propName] = props[propName];
    }
  }
  return resultsProps;
}
function getFieldStatus(externalReference, externalData, configId, fieldName, devices) {
  return responsiveValueReduce(externalReference, (currentStatus, value, deviceId) => {
    if (!deviceId) {
      if (!value.id) {
        return {
          isLoading: false,
          renderable: false
        };
      }
      const externalValue = getResolvedExternalDataValue(externalData, configId, fieldName, value);
      return {
        isLoading: currentStatus.isLoading || externalValue === undefined,
        renderable: currentStatus.renderable && externalValue !== undefined && (externalValue.type === "object" ? value.key !== undefined : true)
      };
    }
    if (currentStatus.isLoading || !currentStatus.renderable) {
      return currentStatus;
    }
    const externalReferenceValue = responsiveValueGetDefinedValue(value, deviceId, devices);
    if (!externalReferenceValue || externalReferenceValue.id === null) {
      return {
        isLoading: false,
        renderable: false
      };
    }
    const externalValue = getResolvedExternalDataValue(externalData, configId, fieldName, externalReferenceValue);
    return {
      isLoading: currentStatus.isLoading || externalValue === undefined,
      renderable: currentStatus.renderable && externalValue !== undefined && (externalValue.type === "object" ? externalReferenceValue.key !== undefined : true)
    };
  }, {
    renderable: true,
    isLoading: false
  }, devices);
}
function getComponentMainType(componentTypes) {
  let type;
  if (componentTypes.includes("action") || componentTypes.includes("actionLink")) {
    type = "action";
  } else if (componentTypes.includes("card")) {
    type = "card";
  } else if (componentTypes.includes("symbol")) {
    type = "icon";
  } else if (componentTypes.includes("button")) {
    type = "button";
  } else if (componentTypes.includes("section") || componentTypes.includes("token")) {
    type = "section";
  } else if (componentTypes.includes("item")) {
    type = "item";
  } else if (componentTypes.includes("image") || componentTypes.includes("$image")) {
    type = "image";
  } else if (componentTypes.includes("actionTextModifier")) {
    type = "actionTextModifier";
  } else {
    type = "item";
  }
  return type;
}

/* with love from shopstory */
function getDefaultLocale(locales) {
  const defaultLocale = locales.find(locale => locale.isDefault);
  if (!defaultLocale) {
    throw new Error("No default locale found");
  }
  return defaultLocale;
}
function getFallbackLocaleForLocale(locale, locales) {
  do {
    const fallbackId = locales.find(l => l.code === locale)?.fallback ?? getDefaultLocale(locales).code;

    // Default locale, no fallback
    if (fallbackId === locale) {
      return;
    }
    return fallbackId;
  } while (true);
}
function getFallbackForLocale(translatedValues, locale, locales) {
  while (true) {
    const fallbackLocale = getFallbackLocaleForLocale(locale, locales);
    if (!fallbackLocale) {
      return;
    }
    const fallbackValue = translatedValues[fallbackLocale];
    if (fallbackValue !== undefined && fallbackValue !== null) {
      return fallbackValue;
    }
    locale = fallbackLocale;
  }
}

/* with love from shopstory */
function getDevicesWidths(devices) {
  const widths = {
    $res: true
  };
  devices.forEach(device => {
    widths[device.id] = device.w;
  });
  return widths;
}

/* with love from shopstory */

/**
 * Traverses given `config` by invoking given `callback` for each schema prop defined within components from `context`
 */
function configTraverse(config, context, callback) {
  configTraverseInternal(config, context, callback, "");
}
function configTraverseArray(array, context, callback, path) {
  array.forEach((config, index) => {
    configTraverseInternal(config, context, callback, `${path}.${index}`);
  });
}
function configTraverseInternal(config, context, callback, path) {
  const componentDefinition = findComponentDefinition(config, context);
  if (!componentDefinition) {
    console.warn(`[configTraverse] Unknown component definition for: ${config._component}`);
    return;
  }
  const pathPrefix = path === "" ? "" : path + ".";
  componentDefinition.schema.forEach(schemaProp => {
    if (isSchemaPropComponent(schemaProp) || schemaProp.type === "component-collection") {
      callback({
        config,
        value: config[schemaProp.prop],
        path: `${pathPrefix}${schemaProp.prop}`,
        schemaProp
      });
      configTraverseArray(config[schemaProp.prop], context, callback, `${pathPrefix}${schemaProp.prop}`);
    } else if (schemaProp.type === "component-collection-localised") {
      callback({
        config,
        value: config[schemaProp.prop],
        path: `${pathPrefix}${schemaProp.prop}`,
        schemaProp
      });
      for (const locale in config[schemaProp.prop]) {
        configTraverseArray(config[schemaProp.prop][locale], context, callback, `${pathPrefix}${schemaProp.prop}.${locale}`);
      }
    } else {
      const currentPath = `${pathPrefix}${schemaProp.prop}`;
      callback({
        config,
        path: currentPath,
        value: config[schemaProp.prop],
        schemaProp
      });
    }
  });
}

/* with love from shopstory */

/**
 * Traverses given `config` by invoking given `callback` for each schema prop defined within components from `context`
 */
function traverseComponents(config, context, callback) {
  traverseComponentsInternal(config, context, callback, "");
}
function traverseComponentsArray(array, context, callback, path) {
  array.forEach((config, index) => {
    traverseComponentsInternal(config, context, callback, `${path}.${index}`);
  });
}
function traverseComponentsInternal(componentConfig, context, callback, path) {
  const componentDefinition = findComponentDefinition(componentConfig, context);
  if (!componentDefinition) {
    console.warn("[traverseComponents] Unknown component definition", componentConfig);
    return;
  }
  const pathPrefix = path === "" ? "" : path + ".";
  callback({
    componentConfig,
    path
  });
  componentDefinition.schema.forEach(schemaProp => {
    if (isSchemaPropComponent(schemaProp) || schemaProp.type === "component-collection") {
      traverseComponentsArray(componentConfig[schemaProp.prop], context, callback, `${pathPrefix}${schemaProp.prop}`);
    } else if (schemaProp.type === "component-collection-localised") {
      for (const locale in componentConfig[schemaProp.prop]) {
        traverseComponentsArray(componentConfig[schemaProp.prop][locale], context, callback, `${pathPrefix}${schemaProp.prop}.${locale}`);
      }
    }
  });
}

/* with love from shopstory */
function deepClone$1(source) {
  return JSON.parse(JSON.stringify(source));
}

/* with love from shopstory */
function uniqueId$1() {
  const id = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    const r = Math.random() * 16 | 0,
      v = c == "x" ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
  return id;
}

/* with love from shopstory */

function duplicateConfig(inputConfig, compilationContext) {
  // deep copy first
  const config = deepClone$1(inputConfig);

  // refresh component ids
  traverseComponents(config, compilationContext, _ref => {
    let {
      componentConfig
    } = _ref;
    componentConfig._id = uniqueId$1();
  });

  // every text must get new local id
  configTraverse(config, compilationContext, _ref2 => {
    let {
      value,
      schemaProp
    } = _ref2;
    if (schemaProp.type === "text") {
      value.id = "local." + uniqueId$1();
    }
  });
  return config;
}

/* with love from shopstory */
const RICH_TEXT_CONFIG_SYNC_THROTTLE_TIMEOUT = 150;
const RICH_TEXT_FOCUSED_FIELDS_SYNC_THROTTLE_TIMEOUT = 100;

/* with love from shopstory */

function RichTextPartClient(props) {
  const {
    value,
    Text,
    TextWrapper
  } = props;
  const textValue = value || "\uFEFF";
  if (TextWrapper) {
    return /*#__PURE__*/React__default.createElement(Text.type, Text.props, /*#__PURE__*/React__default.createElement(TextWrapper.type, TextWrapper.props, textValue));
  }
  return /*#__PURE__*/React__default.createElement(Text.type, Text.props, textValue);
}

/* with love from shopstory */
function getAbsoluteRichTextPartPath(relativeRichTextPartPath, richTextPath, locale) {
  return `${richTextPath}.elements.${locale}.${relativeRichTextPartPath}`;
}

/* with love from shopstory */

function buildRichTextNoCodeEntry(options) {
  const {
    accessibilityRole,
    font,
    color,
    text,
    locale = "en"
  } = options ?? {};
  const colorTokenValue = {
    value: "#000000",
    widgetId: "@easyblocks/color"
  };
  if (color) {
    colorTokenValue.tokenId = color;
  }
  const fontTokenValue = {
    value: {
      fontFamily: "sans-serif",
      fontSize: "16px"
    }
  };
  if (font) {
    fontTokenValue.tokenId = font;
  }
  return {
    _id: uniqueId$1(),
    _component: "@easyblocks/rich-text",
    accessibilityRole: accessibilityRole ?? "div",
    elements: {
      [locale ?? "en"]: [buildRichTextBlockElementComponentConfig("paragraph", [buildRichTextLineElementComponentConfig({
        elements: [buildRichTextPartComponentConfig({
          color: colorTokenValue,
          font: fontTokenValue,
          value: text ?? "Lorem ipsum",
          TextWrapper: []
        })]
      })])]
    },
    isListStyleAuto: true,
    mainColor: colorTokenValue,
    mainFont: fontTokenValue
  };
}
function buildRichTextBlockElementComponentConfig(type, elements) {
  return {
    _component: "@easyblocks/rich-text-block-element",
    elements,
    type,
    _id: uniqueId$1()
  };
}
function buildRichTextLineElementComponentConfig(_ref4) {
  let {
    elements
  } = _ref4;
  return {
    _component: "@easyblocks/rich-text-line-element",
    elements,
    _id: uniqueId$1()
  };
}
function buildRichTextPartComponentConfig(_ref5) {
  let {
    color,
    font,
    value,
    id,
    TextWrapper
  } = _ref5;
  return {
    _id: id ?? uniqueId$1(),
    _component: "@easyblocks/rich-text-part",
    color,
    font,
    value,
    TextWrapper: TextWrapper ?? []
  };
}

/* with love from shopstory */
function cleanString(value) {
  return value.replace(/\u2028/g, "");
}

/* with love from shopstory */

function convertEditorValueToRichTextElements(editorValue) {
  return editorValue.map(blockElement => {
    if (Element$1.isElementType(blockElement, "bulleted-list")) {
      return convertEditorListElementToRichTextListBlockElement("bulleted-list", blockElement);
    }
    if (Element$1.isElementType(blockElement, "numbered-list")) {
      return convertEditorListElementToRichTextListBlockElement("numbered-list", blockElement);
    }
    if (Element$1.isElementType(blockElement, "paragraph")) {
      return convertEditorParagraphElementToRichTextParagraphBlockElement(blockElement);
    }
    throw new Error("Unknown block element");
  });
}
function convertEditorElementToRichTextLineElement(editorElement) {
  const lineElement = buildRichTextLineElementComponentConfig({
    elements: editorElement.children.map(child => {
      return buildRichTextPartComponentConfig({
        value: cleanString(child.text),
        color: child.color,
        font: child.font,
        id: child.id,
        TextWrapper: child.TextWrapper
      });
    })
  });
  lineElement._id = editorElement.id;
  return lineElement;
}
function convertEditorListElementToRichTextListBlockElement(type, editorElement) {
  const listBlockElement = buildRichTextBlockElementComponentConfig(type, editorElement.children.map(child => {
    return convertEditorElementToRichTextLineElement(child);
  }));
  listBlockElement._id = editorElement.id;
  return listBlockElement;
}
function convertEditorParagraphElementToRichTextParagraphBlockElement(editorElement) {
  const paragraphBlockElement = buildRichTextBlockElementComponentConfig("paragraph", editorElement.children.map(child => {
    return convertEditorElementToRichTextLineElement(child);
  }));
  paragraphBlockElement._id = editorElement.id;
  return paragraphBlockElement;
}

/* with love from shopstory */

function getFocusedRichTextPartsConfigPaths(editor) {
  if (editor.selection !== null) {
    const isBackward = Range.isBackward(editor.selection);
    const anchorProperty = isBackward ? "focus" : "anchor";
    const focusProperty = isBackward ? "anchor" : "focus";
    const anchor = editor.selection[anchorProperty];
    const focus = editor.selection[focusProperty];
    const selectedTextNodes = Array.from(Editor$1.nodes(editor, {
      match: Text$1.isText
    }));
    if (selectedTextNodes.length === 1) {
      const range = {
        start: anchor.offset,
        end: focus.offset
      };
      const [textNode, textPath] = selectedTextNodes[0];
      return [buildFocusedRichTextPartConfigPath(textNode, textPath, range)];
    }
    const focusedRichTextPartsConfigPaths = selectedTextNodes.map((_ref, textEntryIndex) => {
      let [textNode, textPath] = _ref;
      if (textNode.text === "") {
        return null;
      }
      let range = null;
      if (textEntryIndex === 0) {
        range = {
          start: anchor.offset,
          end: textNode.text.length
        };
      }
      if (textEntryIndex === selectedTextNodes.length - 1) {
        range = {
          start: 0,
          end: focus.offset
        };
      }
      return buildFocusedRichTextPartConfigPath(textNode, textPath, range);
    }).filter(configPath => {
      return configPath !== null;
    });
    return focusedRichTextPartsConfigPaths;
  }
  return [];
}
function buildFocusedRichTextPartConfigPath(textNode, path, range) {
  let focusedRichTextPartConfigPath = path.join(".elements.");
  if (range !== null && (isPartialSelection(range, textNode) || isCaretSelection(range))) {
    focusedRichTextPartConfigPath += `.{${range.start},${range.end}}`;
  }
  return focusedRichTextPartConfigPath;
}
function isPartialSelection(range, textNode) {
  return range.end - range.start !== textNode.text.length;
}
function isCaretSelection(range) {
  return range.end - range.start === 0;
}

/* with love from shopstory */
/**
 * Returns a new function that filters nullable elements to be used as callback of `.filter` method.
 * It's useful because it has already defined guard which otherwise would be repeated in many places
 * and also it automatically changes the return value of filter function by extracting `null` and `undefined` types.
 *
 * Usage:
 * ```
 * const onlyNonNullable = nullableElements.filter<TypeOfCollectionItem>(nonNullable())
 * ```
 */
function nonNullable() {
  return function (value) {
    return value != null;
  };
}

/* with love from shopstory */

function isEditorSelection(editor) {
  return editor.selection !== null;
}
function updateSelection(editor, key) {
  for (var _len = arguments.length, values = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    values[_key - 2] = arguments[_key];
  }
  if (!isEditorSelection(editor)) {
    return;
  }
  const isSelectionCollapsed = Range.isCollapsed(editor.selection);
  if (values.length === 1) {
    if (key === "TextWrapper" && isSelectionCollapsed) {
      expandCurrentSelectionToWholeTextPart(editor);
    }

    // If `values` contains one element, we want to apply this value to all text nodes.
    Editor$1.addMark(editor, key, values[0]);
    if (key === "TextWrapper") {
      if (values[0].length > 0) {
        const firstSelectedNodeEntry = Node.first(editor, editor.selection.anchor.path);
        const lastSelectedNodeEntry = Node.last(editor, editor.selection.focus.path);
        if (Text$1.isText(firstSelectedNodeEntry[0])) {
          const firstSelectedNode = firstSelectedNodeEntry[0];
          const lastSelectedNode = lastSelectedNodeEntry[0];
          if (firstSelectedNode !== lastSelectedNode) {
            Transforms.setNodes(editor, {
              color: firstSelectedNode.color,
              font: firstSelectedNode.font
            }, {
              match: Text$1.isText
            });
          }
        }
      }
    }
  } else {
    // If `values` contains multiple values, we want to update each selected text node separately with its
    // corresponding value. To do that, we need to obtain selection range for each selected text node
    // and apply correct value.
    const selectedTextNodeEntries = Array.from(Editor$1.nodes(editor, {
      match: Text$1.isText
    }));
    const selectedTextNodesRanges = selectedTextNodeEntries.map(_ref => {
      let [, textNodePath] = _ref;
      return Range.intersection(editor.selection, Editor$1.range(editor, textNodePath));
    }).filter(nonNullable());
    Editor$1.withoutNormalizing(editor, () => {
      selectedTextNodesRanges.reverse().forEach((range, index) => {
        Transforms.setNodes(editor, {
          [key]: values[index]
        }, {
          at: range,
          match: Text$1.isText,
          split: true
        });
      });
    });
  }
  const richTextElements = convertEditorValueToRichTextElements(editor.children);
  const newFocusedRichTextParts = getFocusedRichTextPartsConfigPaths(editor);
  return {
    elements: richTextElements,
    focusedRichTextParts: newFocusedRichTextParts
  };
}
function expandCurrentSelectionToWholeTextPart(editor) {
  const textPartPath = Editor$1.path(editor, editor.selection.anchor.path);
  Transforms.setSelection(editor, {
    anchor: Editor$1.start(editor, textPartPath),
    focus: Editor$1.end(editor, textPartPath)
  });
}

/* with love from shopstory */

function convertRichTextElementsToEditorValue(richTextElements) {
  if (!richTextElements || richTextElements.length === 0) {
    return getPlaceholderRichTextElements();
  }
  return richTextElements.map(richTextBlockElementComponentConfig => {
    return convertRichTextBlockElementComponentConfigToEditorElement(richTextBlockElementComponentConfig);
  });
}
function convertRichTextPartComponentConfigToEditorText(richTextPartComponentConfig) {
  return {
    color: richTextPartComponentConfig.color,
    font: richTextPartComponentConfig.font,
    id: richTextPartComponentConfig._id,
    text: richTextPartComponentConfig.value,
    TextWrapper: richTextPartComponentConfig.TextWrapper
  };
}
function convertRichTextBlockElementComponentConfigToEditorElement(blockElementComponentConfig) {
  if (blockElementComponentConfig.type === "bulleted-list" || blockElementComponentConfig.type === "numbered-list") {
    return {
      id: blockElementComponentConfig._id,
      type: blockElementComponentConfig.type,
      children: blockElementComponentConfig.elements.map(lineElementComponentConfig => {
        return {
          type: "list-item",
          id: lineElementComponentConfig._id,
          children: lineElementComponentConfig.elements.map(childComponentConfig => {
            return convertRichTextPartComponentConfigToEditorText(childComponentConfig);
          })
        };
      })
    };
  }
  return {
    id: blockElementComponentConfig._id,
    type: blockElementComponentConfig.type,
    children: blockElementComponentConfig.elements.map(lineElementComponentConfig => {
      return {
        type: "text-line",
        id: lineElementComponentConfig._id,
        children: lineElementComponentConfig.elements.map(childComponentConfig => {
          return convertRichTextPartComponentConfigToEditorText(childComponentConfig);
        })
      };
    })
  };
}
function getPlaceholderRichTextElements() {
  return [{
    id: uniqueId$1(),
    type: "paragraph",
    children: [{
      id: uniqueId$1(),
      type: "text-line",
      children: [{
        id: uniqueId$1(),
        color: {
          tokenId: "black",
          value: "black",
          widgetId: "@easyblocks/color"
        },
        font: {
          tokenId: "$body",
          value: ""
        },
        text: "",
        TextWrapper: []
      }]
    }]
  }];
}

/* with love from shopstory */
/**
 * `Object.keys` is badly typed for its reasons and this function just fixes it.
 * https://stackoverflow.com/questions/55012174/why-doesnt-object-keys-return-a-keyof-type-in-typescript
 */
function keys(o) {
  return Object.keys(o);
}

/* with love from shopstory */
function deepCompare$1() {
  for (let index = 0; index < arguments.length - 1; index++) {
    const currentObject = sortObject$1(index < 0 || arguments.length <= index ? undefined : arguments[index]);
    const nextObject = sortObject$1(index + 1 < 0 || arguments.length <= index + 1 ? undefined : arguments[index + 1]);
    const areObjectsHashesEqual = JSON.stringify(currentObject) === JSON.stringify(nextObject);
    if (!areObjectsHashesEqual) {
      return false;
    }
  }
  return true;
}
function sortObject$1(value) {
  if (typeof value !== "object") {
    return value;
  }
  if (Array.isArray(value)) {
    return [...value].sort();
  }
  if (value === null) {
    return null;
  }
  const sortedObject = {};
  const objectKeys = Object.keys(value).sort();
  objectKeys.forEach(key => {
    sortedObject[key] = sortObject$1(value[key]);
  });
  return sortedObject;
}

/* with love from shopstory */

/**
 * Tracks which ids were used during current normalization run
 */
const USED_IDS = new Set();

/**
 * Keeps track what was the previous id before generating the unique id. This is needed because Slate rerenders before
 * our config updates and it wouldn't know which compiled component to render.
 */
const NORMALIZED_IDS_TO_IDS = new Map();
function withEasyblocks(editor) {
  const {
    /*insertText,*/normalizeNode
  } = editor;

  // editor.insertText = (text) => {
  //   // Verify if the current selection is placed at the end of an inline element. If yes, set the selection to start of
  //   // the next element before adding new text. This allows to break out from the inline element if it's placed at the end of line.
  //   if (editor.selection && Range.isCollapsed(editor.selection)) {
  //     const selectedNodeParent = Editor.parent(
  //       editor,
  //       editor.selection.focus.path
  //     );

  //     if (selectedNodeParent) {
  //       const [parentNode, parentNodePath] = selectedNodeParent;

  //       if (SlateElement.isElement(parentNode) && editor.isInline(parentNode)) {
  //         const isCursorSetAtTheEnd = Editor.isEnd(
  //           editor,
  //           editor.selection.focus,
  //           parentNodePath
  //         );

  //         const nodePointAfterInlineElement = Editor.after(
  //           editor,
  //           parentNodePath
  //         );

  //         if (isCursorSetAtTheEnd && nodePointAfterInlineElement) {
  //           Transforms.setSelection(editor, {
  //             anchor: nodePointAfterInlineElement,
  //             focus: nodePointAfterInlineElement,
  //           });
  //         }
  //       }
  //     }
  //   }

  //   insertText(text);
  // };

  editor.normalizeNode = entry => {
    // When copying text content from content editable element, Slate wraps pasted content into top most element.
    // We need to unwrap each block element that is nested within another block element.
    if (unwrapBlockElementsNestedWithinBlockElement(editor, entry)) {
      return;
    }

    // Slate by default compares text elements and merges them, but to compare them it uses strict equality comparison algorithm.
    // We need to compare them using our own algorithm.
    if (mergeVisuallyTheSameOrEmptyTextNodes(editor, entry)) {
      return;
    }

    // if (normalizeEmptyTextNodesAfterInlineElements(editor, entry)) {
    //   return;
    // }

    // Rich text and its elements contains collections. Each item of collection should have unique id.
    if (updateNonUniqueIds(editor, entry)) {
      return;
    }

    // Slate normalizes fields from deepest to lowest. The lowest element is editor element which has empty path.
    if (entry[1].length === 0) {
      USED_IDS.clear();
    }
    normalizeNode(entry);
  };
  return editor;
}
function unwrapBlockElementsNestedWithinBlockElement(editor, entry) {
  const [node, path] = entry;
  if (Element$1.isElement(node) &&
  // This cast is fine since `RichTextBlockElementType` overlaps with type of `node.type`.
  ["bulleted-list", "numbered-list", "paragraph"].includes(node.type)) {
    const nodeParent = Node.parent(editor, path);
    if (Element$1.isElement(nodeParent)) {
      if (nodeParent.type === node.type) {
        Transforms.unwrapNodes(editor, {
          at: path
        });
        return true;
      }

      // For now there is only one case where block element can be nested within block element of different type,
      // it can happen while pasting content from one $richText to another. We want to keep the type of pasted content
      // so instead of unwrapping nodes, we lift them one level up.
      if (nodeParent.type !== node.type && ["bulleted-list", "numbered-list", "paragraph"].includes(nodeParent.type)) {
        Transforms.liftNodes(editor, {
          at: path
        });
        return true;
      }
    }
  }
  return false;
}
function updateNonUniqueIds(editor, entry) {
  const [node, path] = entry;
  if (Text$1.isText(node) || Element$1.isElement(node)) {
    if (USED_IDS.has(node.id)) {
      const newId = uniqueId$1();
      NORMALIZED_IDS_TO_IDS.set(newId, node.id);
      Transforms.setNodes(editor, {
        id: newId
      }, {
        at: path,
        match: n => (Text$1.isText(n) || Element$1.isElement(n)) && n.id === node.id
      });
      return true;
    } else {
      USED_IDS.add(node.id);
    }
  }
  return false;
}
function mergeVisuallyTheSameOrEmptyTextNodes(editor, entry) {
  const [node, path] = entry;
  if (Element$1.isElement(node) && (node.type === "text-line" || node.type === "list-item")) {
    const textLineChildren = Array.from(Node.children(editor, path));
    if (textLineChildren.length > 1) {
      for (let childIndex = 0; childIndex < textLineChildren.length - 1; childIndex++) {
        const [currentChildNode, currentChildPath] = textLineChildren[childIndex];
        const [nextChildNode, nextChildPath] = textLineChildren[childIndex + 1];
        if (Text$1.isText(currentChildNode) && Text$1.isText(nextChildNode)) {
          if (compareText(currentChildNode, nextChildNode)) {
            Transforms.mergeNodes(editor, {
              at: nextChildPath,
              match: node => Text$1.isText(node)
            });
            return true;
          }
          if (nextChildNode.text.trim() === "" && childIndex + 1 < textLineChildren.length - 1 && currentChildNode.TextWrapper.length === 0) {
            Transforms.mergeNodes(editor, {
              at: nextChildPath,
              match: node => Text$1.isText(node)
            });
            return true;
          }

          // `Transforms.mergeNodes` always merges node/nodes at given position into PREVIOUS node.
          // In this case, we want to merge node at current position into next one.
          if (currentChildNode.text.trim() === "" && nextChildNode !== undefined) {
            Transforms.setNodes(editor, {
              color: nextChildNode.color,
              font: nextChildNode.font
            }, {
              at: currentChildPath,
              match: node => Text$1.isText(node)
            });
          }
        }
      }
    }
  }
  return false;
}

// This function might be useful in the future, but right now it's not needed.

// Slate normalization rules states that an inline element cannot be first or last child of block element.
// Slate during its own normalization will add empty Text nodes before or/and after inline element.
// Those Text nodes will be missing properties we add during constructing Slate value based on Shopstory config
// thus it will make compilation error because of missing schema prop values.
// function normalizeEmptyTextNodesAfterInlineElements(
//   editor: Editor,
//   entry: NodeEntry<SlateNode>
// ): boolean {
//   const [node, path] = entry;

//   if (
//     SlateElement.isElement(node) &&
//     (node.type === "text-line" || node.type === "list-item")
//   ) {
//     for (let index = 0; index < node.children.length; index++) {
//       const childNode = node.children[index];
//       const previousNode = node.children[index - 1];
//       const nextNode = node.children[index + 1];

//       if (
//         previousNode &&
//         nextNode &&
//         isElementInlineWrapperElement(previousNode) &&
//         isElementInlineWrapperElement(nextNode)
//       ) {
//         if (Text.isText(childNode) && childNode.text === "") {
//           Transforms.removeNodes(editor, {
//             at: [...path, index],
//           });
//           return true;
//         }
//       }

//       if (
//         childNode &&
//         nextNode &&
//         isElementInlineWrapperElement(childNode) &&
//         isElementInlineWrapperElement(nextNode)
//       ) {
//         const nextNodePath = [...path, index + 1];

//         Transforms.mergeNodes(editor, {
//           at: nextNodePath,
//         });

//         return true;
//       }
//     }
//   }

//   return false;
// }

function filterNonComparableProperties(obj) {
  return keys(obj).filter(key => ["color", "font", "TextWrapper"].includes(key)).reduce((filteredObject, currentKey) => {
    filteredObject[currentKey] = obj[currentKey];
    return filteredObject;
  }, {});
}
function compareText(text1, text2) {
  let areEqual = true;
  const part1Keys = keys(filterNonComparableProperties(text1));
  const part2Keys = keys(filterNonComparableProperties(text2));
  if (part1Keys.length !== part2Keys.length) {
    return false;
  }
  for (let index = 0; index < part1Keys.length; index++) {
    const key = part1Keys[index];
    const part1Value = text1[key];
    const part2Value = text2[key];
    const areValuesEqual = deepCompare$1(part1Value, part2Value);
    if (!areValuesEqual) {
      areEqual = false;
      break;
    }
  }
  return areEqual;
}

/* with love from shopstory */

// Slate's transforms methods mutates given editor instance.
// By creating temporary editor instance we can apply all transformations without
// touching original editor and read result from `temporaryEditor.children`
function createTemporaryEditor(editor) {
  const temporaryEditor = withEasyblocks(withReact(createEditor()));
  temporaryEditor.children = [...editor.children];
  temporaryEditor.selection = editor.selection ? {
    ...editor.selection
  } : null;
  return temporaryEditor;
}

/* with love from shopstory */
function traverseCompiledRichTextComponentConfig(config, callback) {
  config.elements.forEach(reactElement => {
    callback(reactElement.props.compiled);
    reactElement.props.compiled.components.elements.forEach(compiledLineElement => {
      callback(compiledLineElement);
      compiledLineElement.components.elements.forEach(compiledTextPart => {
        callback(compiledTextPart);
      });
    });
  });
}

/* with love from shopstory */

function extractElementsFromCompiledComponents(compiledRichText) {
  const extractedCompiledElementComponents = [];
  traverseCompiledRichTextComponentConfig(compiledRichText, compiledConfig => {
    if (compiledConfig._component === "@easyblocks/rich-text-block-element" || compiledConfig._component === "@easyblocks/rich-text-line-element") {
      extractedCompiledElementComponents.push(compiledConfig);
    }
  });
  return extractedCompiledElementComponents;
}

/* with love from shopstory */

function extractTextPartsFromCompiledComponents(compiledRichText) {
  const extractedTextPartComponents = [];
  traverseCompiledRichTextComponentConfig(compiledRichText, compiledConfig => {
    if (compiledConfig._component === "@easyblocks/rich-text-part") {
      extractedTextPartComponents.push(compiledConfig);
    }
  });
  return extractedTextPartComponents;
}

/* with love from shopstory */
function parseFocusedRichTextPartConfigPath(focusedRichTextPartConfigPath) {
  const focusedRichTextPartConfigPathMatch = focusedRichTextPartConfigPath.match(/\d+(\.elements\.\d+){2,3}/);
  if (focusedRichTextPartConfigPathMatch === null) {
    throw new Error("Invalid @easyblocks/rich-text-part config path");
  }
  const [richTextPartConfigPath] = focusedRichTextPartConfigPathMatch;
  const path = richTextPartConfigPath.split(".elements.").map(index => +index);
  const rangeMatch = focusedRichTextPartConfigPath.match(/\.\{(\d+),(\d+)\}$/);
  const range = rangeMatch !== null ? [+rangeMatch[1], +rangeMatch[2]] : null;
  return {
    path: path,
    range
  };
}

/* with love from shopstory */
function last$1(collection) {
  return collection[collection.length - 1];
}

/* with love from shopstory */
function dotNotationGet$1(obj, path) {
  if (path === "") {
    return obj;
  }
  return path.split(".").reduce((acc, curVal) => acc && acc[curVal], obj);
}

/* with love from shopstory */

function getEditorSelectionFromFocusedFields(focusedFields, form) {
  try {
    const anchorFocusedField = focusedFields[0];
    const focusFocusedField = last$1(focusedFields);
    const parsedAnchorField = parseFocusedRichTextPartConfigPath(anchorFocusedField);
    const parsedFocusedField = parseFocusedRichTextPartConfigPath(focusFocusedField);
    if (!parsedAnchorField.path.length || !parsedFocusedField.path.length) {
      return null;
    }
    return {
      anchor: {
        offset: parsedAnchorField.range ? parsedAnchorField.range[0] : 0,
        path: parsedAnchorField.path
      },
      focus: {
        offset: parsedFocusedField.range ? parsedFocusedField.range[1] : dotNotationGet$1(form.values, focusFocusedField).value.length,
        path: parsedFocusedField.path
      }
    };
  } catch (error) {
    console.log(error);
    return null;
  }
}

/* with love from shopstory */

function getFocusedFieldsFromSlateSelection(editor, richTextComponentConfigPath, locale) {
  if (editor.selection === null) {
    return undefined;
  }
  const focusedRichTextPartPaths = getFocusedRichTextPartsConfigPaths(editor);
  const focusedFields = focusedRichTextPartPaths.map(richTextPartPath => getAbsoluteRichTextPartPath(richTextPartPath, richTextComponentConfigPath, locale));
  return focusedFields;
}

/* with love from shopstory */
/**
 * When selecting text within $richText, we keep information about which text parts are selected
 * within focused fields. If the text part is partially selected, we add information about the selection.
 * This selection has format: ".{textPartCharacterSelectionStartIndex,textPartCharacterSelectionEndIndex}".
 * We often want to query related to selection text part component config and to do that correctly we need to
 * strip information about selection.
 */
function stripRichTextPartSelection$1(value) {
  return value.replace(/\.\{\d+,\d+\}$/g, "");
}

/* with love from shopstory */
function dotNotationSet(obj, path, value) {
  if (path === "") {
    throw new Error("Path can't be empty in dotNotationSetter");
  }
  if (typeof obj !== "object" || obj === null) {
    throw new Error("dotNotationSet - you're trying to set value for non-object");
  }
  const splitPath = typeof path === "string" ? path.split(".").map(x => {
    if (typeof x === "string" && !isNaN(parseInt(x))) {
      return parseInt(x);
    }
    return x;
  }) : path;
  if (splitPath.length === 1) {
    obj[splitPath[0]] = value;
  } else {
    if (!obj[splitPath[0]]) {
      if (typeof splitPath[1] === "number") {
        obj[splitPath[0]] = [];
      } else {
        obj[splitPath[0]] = {};
      }
    }
    dotNotationSet(obj[splitPath[0]], splitPath.slice(1), value);
  }
}

/* with love from shopstory */

function getRichTextComponentConfigFragment(sourceRichTextComponentConfig, editorContext) {
  const {
    focussedField,
    form,
    contextParams
  } = editorContext;
  const newRichTextComponentConfig = {
    ...sourceRichTextComponentConfig,
    elements: {
      [contextParams.locale]: []
    }
  };
  focussedField.forEach(focusedField => {
    const textPartConfig = dotNotationGet$1(form.values, stripRichTextPartSelection$1(focusedField));
    const {
      path,
      range
    } = parseFocusedRichTextPartConfigPath(focusedField);
    const newTextPartConfig = duplicateConfig(textPartConfig, editorContext);
    if (range) {
      newTextPartConfig.value = textPartConfig.value.slice(...range);
    }
    let lastParentConfigPath = `elements.${contextParams.locale}`;
    path.slice(0, -1).forEach((pathIndex, index) => {
      let currentConfigPath = lastParentConfigPath;
      if (index === 0) {
        currentConfigPath += `.${pathIndex}`;
      } else {
        const parentConfig = dotNotationGet$1(newRichTextComponentConfig, lastParentConfigPath);
        currentConfigPath += `.elements.${Math.min(parentConfig.elements.length, pathIndex)}`;
      }
      const currentConfig = dotNotationGet$1(newRichTextComponentConfig, currentConfigPath);
      if (!currentConfig) {
        const sourceConfigPath = lastParentConfigPath + (index === 0 ? `.${pathIndex}` : `.elements.${pathIndex}`);
        const sourceConfig = dotNotationGet$1(sourceRichTextComponentConfig, sourceConfigPath);
        const configCopy = {
          ...sourceConfig,
          elements: []
        };
        dotNotationSet(newRichTextComponentConfig, currentConfigPath, configCopy);
      }
      lastParentConfigPath = currentConfigPath;
    });
    const textPartParentConfig = dotNotationGet$1(newRichTextComponentConfig, lastParentConfigPath);
    dotNotationSet(newRichTextComponentConfig, lastParentConfigPath, {
      ...textPartParentConfig,
      elements: [...textPartParentConfig.elements, newTextPartConfig]
    });
  });
  return newRichTextComponentConfig;
}

/* with love from shopstory */

function responsiveValueFill(value, devices, widths) {
  if (!isTrulyResponsiveValue$1(value)) {
    return value;
  }
  const componentWidths = getDeviceWidthPairs(widths, devices);
  const result = {
    ...value
  };
  componentWidths.forEach((_ref, index) => {
    let {
      width,
      deviceId
    } = _ref;
    if (result[deviceId] === undefined) {
      // Let's look for a value up
      for (let i = index + 1; i < componentWidths.length; i++) {
        const valueForHigherWidth = result[componentWidths[i].deviceId];
        if (valueForHigherWidth !== undefined) {
          result[deviceId] = valueForHigherWidth;
          break;
        }
      }

      // If still undefined, let's look for a value down
      if (result[deviceId] === undefined) {
        for (let i = index - 1; i >= 0; i--) {
          const valueForLowerWidth = result[componentWidths[i].deviceId];
          if (valueForLowerWidth !== undefined) {
            result[deviceId] = valueForLowerWidth;
            break;
          }
        }
      }
      if (result[deviceId] === undefined) {
        throw new Error("Can't fill");
      }
    }
  });
  return result;
}

function RichTextEditor(props) {
  const {
    editorContext
  } = window.parent.editorWindowAPI;
  const {
    actions,
    contextParams,
    form,
    focussedField,
    locales,
    setFocussedField
  } = editorContext;
  const {
    __easyblocks: {
      path,
      runtime: {
        resop,
        stitches,
        devices
      }
    },
    align
  } = props;
  let richTextConfig = dotNotationGet$1(form.values, path);
  const [editor] = useState(() => withEasyblocks(withReact(createEditor())));
  const localizedRichTextElements = richTextConfig.elements[contextParams.locale];
  const fallbackRichTextElements = getFallbackForLocale(richTextConfig.elements, contextParams.locale, locales);
  const richTextElements = localizedRichTextElements ?? fallbackRichTextElements;
  const richTextElementsConfigPath = `${path}.elements.${contextParams.locale}`;
  const [editorValue, setEditorValue] = useState(() => convertRichTextElementsToEditorValue(richTextElements));

  // If rich text has no value, we initialize it with default config by updating it during first render
  // This is only possible when we open entry for non main locale without fallback, this is total edge case
  if (richTextElements.length === 0 && !fallbackRichTextElements) {
    // We only want to show rich text for default config within this component, we don't want to update raw content
    // To prevent implicit update of raw content we make a deep copy.
    richTextConfig = deepClone$1(richTextConfig);
    richTextConfig.elements[contextParams.locale] = convertEditorValueToRichTextElements(editorValue);
  }

  /**
   * Controls the visibility of decoration imitating browser selection of
   * the selected text after the user has blurred the content editable element.
   */
  const [isDecorationActive, setIsDecorationActive] = useState(false);

  /**
   * Keeps track what caused last change to editor value.
   * This is used in two cases:
   * - text-only changes of editable content shouldn't trigger update of `editor.children` ("text-input")
   * - changes from outside of editable content shouldn't trigger writing to editor's history within change callback ("external")
   */
  const lastChangeReason = useRef("text-input");

  /**
   * Whether the content editable is enabled or not. We enable it through double click.
   */
  const [isEnabled, setIsEnabled] = useState(false);
  const previousRichTextComponentConfig = useRef();
  const currentSelectionRef = useRef(null);
  const isConfigChanged = !isConfigEqual(previousRichTextComponentConfig.current, richTextConfig);
  if (previousRichTextComponentConfig.current && isConfigChanged) {
    if (lastChangeReason.current !== "paste") {
      lastChangeReason.current = "external";
    }
    previousRichTextComponentConfig.current = richTextConfig;
    const nextEditorValue = convertRichTextElementsToEditorValue(richTextElements);
    // React bails out the render if state setter function is invoked during the render phase.
    // Doing it makes Slate always up-to date with the latest config if it's changed from outside.
    // https://reactjs.org/docs/hooks-faq.html#how-do-i-implement-getderivedstatefromprops
    setEditorValue(nextEditorValue);
    editor.children = nextEditorValue;
    if (isEnabled) {
      const newEditorSelection = getEditorSelectionFromFocusedFields(focussedField, form);
      if (isDecorationActive) {
        currentSelectionRef.current = newEditorSelection;
      } else {
        // Slate gives us two methods to update its selection:
        // - `setSelection` updates current selection, so `editor.selection` must be not null
        // - `select` sets the selection, so `editor.selection` must be null
        if (newEditorSelection !== null && editor.selection !== null) {
          Transforms.setSelection(editor, newEditorSelection);
        } else if (newEditorSelection !== null && editor.selection === null) {
          Transforms.select(editor, newEditorSelection);
        } else {
          Transforms.deselect(editor);
        }
      }
    }
  }
  useLayoutEffect(() => {
    if (isDecorationActive && currentSelectionRef.current !== null && !Range.isCollapsed(currentSelectionRef.current)) {
      splitStringNodes(editor, currentSelectionRef.current);
      return () => {
        unwrapStringNodesContent(editor);
      };
    }
  }, [editor, isDecorationActive, richTextConfig]);
  const isRichTextActive = focussedField.some(focusedField => focusedField.startsWith(path));
  useLayoutEffect(() => {
    // When rich text becomes inactive we want to restore all original [data-slate-string] nodes
    // by removing all span wrappers that we added to show the mocked browser selection.
    if (!isRichTextActive) {
      unwrapStringNodesContent(editor);
    }
  }, [editor, isRichTextActive]);
  useEffect(() => {
    // We set previous value of rich text only once, then we manually assign it when needed.
    previousRichTextComponentConfig.current = richTextConfig;
  }, []);
  useEffect(
  // Component is blurred when the user selects other component in editor. This is different from blurring content editable.
  // Content editable can be blurred, but the component can remain active ex. when we select some text within content editable
  // and want to update its color from the sidebar.
  function handleRichTextBlur() {
    if (!isRichTextActive && isEnabled) {
      // editor.children = deepClone(editorValue);
      setIsEnabled(false);
      currentSelectionRef.current = null;
    }
    if (!editor.selection) {
      return;
    }
    if (!isRichTextActive) {
      Transforms.deselect(editor);
      const isSlateValueEmpty = isEditorValueEmpty(editor.children);

      // When value for current locale is empty we want to show value from fallback value instead of placeholder
      // if the fallback value is present.
      if (isSlateValueEmpty && fallbackRichTextElements !== undefined) {
        const nextRichTextElement = deepClone$1(richTextConfig);
        delete nextRichTextElement.elements[contextParams.locale];
        editor.children = convertRichTextElementsToEditorValue(fallbackRichTextElements);
        form.change(path, nextRichTextElement);
      }
    }
  }, [focussedField, isEnabled, isRichTextActive]);
  useEffect(() => {
    // If editor has been refocused and it was blurred earlier we have to disable the decoration to show only browser selection
    if (ReactEditor.isFocused(editor) && isDecorationActive) {
      setIsDecorationActive(false);
    }
  });
  useEffect(() => {
    function handleRichTextChanged(event) {
      if (!editor.selection) {
        return;
      }
      if (event.data.type === "@easyblocks-editor/rich-text-changed") {
        const {
          payload
        } = event.data;
        const {
          editorContext
        } = window.parent.editorWindowAPI;

        // Slate is an uncontrolled component and we don't have an easy access to control it.
        // It keeps its state internally and on each change we convert this state to our format.
        // This works great because changing content of editable element is easy, we append or remove things.
        // When we change the color/font of selected text there are many questions:
        // - is the current selection partial or does it span everything?
        // - how to split text chunks when selection is partial?
        // - how to update selection?
        //
        // `Editor.addMark` method automatically will split (or not) text chunks, update selection etc.
        // It will just do all the painful things. After the Slate do its job, we take its current state after the update
        // and convert it to entry and correct focused fields.
        const temporaryEditor = createTemporaryEditor(editor);
        const updateSelectionResult = updateSelection(temporaryEditor, payload.prop, ...payload.values);
        if (!updateSelectionResult) {
          return;
        }
        currentSelectionRef.current = temporaryEditor.selection;
        actions.runChange(() => {
          const newRichTextElement = {
            ...richTextConfig,
            elements: {
              ...richTextConfig.elements,
              [editorContext.contextParams.locale]: updateSelectionResult.elements
            }
          };
          form.change(path, newRichTextElement);
          const newFocusedFields = updateSelectionResult.focusedRichTextParts.map(focusedRichTextPart => getAbsoluteRichTextPartPath(focusedRichTextPart, path, editorContext.contextParams.locale));
          return newFocusedFields;
        });
      }
    }
    window.addEventListener("message", handleRichTextChanged);
    return () => {
      window.removeEventListener("message", handleRichTextChanged);
    };
  }, [richTextConfig, path]);
  const decorate = createTextSelectionDecorator(editor);
  const Elements = extractElementsFromCompiledComponents(props);
  function renderElement(_ref) {
    let {
      attributes,
      children,
      element
    } = _ref;
    const Element = Elements.find(Element => Element._id === element.id || NORMALIZED_IDS_TO_IDS.get(element.id) === Element._id);
    if (!Element) {
      // This can only happen if the current locale has no value and has no fallback
      if (Elements.length === 0) {
        if (element.type === "list-item") {
          return /*#__PURE__*/React__default.createElement("div", attributes, /*#__PURE__*/React__default.createElement("div", null, children));
        }
        return /*#__PURE__*/React__default.createElement("div", attributes, children);
      }
      throw new Error("Missing element");
    }
    const compiledStyles = (() => {
      if (Element._component === "@easyblocks/rich-text-block-element") {
        if (Element.props.type === "bulleted-list") {
          return Element.styled.BulletedList;
        } else if (Element.props.type === "numbered-list") {
          return Element.styled.NumberedList;
        } else if (Element.props.type === "paragraph") {
          return Element.styled.Paragraph;
        }
      } else if (Element._component === "@easyblocks/rich-text-line-element") {
        if (element.type === "text-line") {
          return Element.styled.TextLine;
        } else if (element.type === "list-item") {
          return Element.styled.ListItem;
        }
      }
    })();
    if (compiledStyles === undefined) {
      throw new Error("Unknown element type");
    }
    return /*#__PURE__*/React__default.createElement(Box, _extends({
      __compiled: compiledStyles,
      devices: devices,
      stitches: stitches
    }, attributes, process.env.NODE_ENV === "development" && {
      "data-shopstory-element-type": element.type,
      "data-shopstory-id": element.id
    }), element.type === "list-item" ? /*#__PURE__*/React__default.createElement("div", null, children) : children);
  }
  const TextParts = extractTextPartsFromCompiledComponents(props);
  function renderLeaf(_ref2) {
    let {
      attributes,
      children,
      leaf
    } = _ref2;
    let TextPart = TextParts.find(TextPart => {
      return TextPart._id === leaf.id;
    });
    if (!TextPart) {
      TextPart = TextParts.find(TextPart => {
        return NORMALIZED_IDS_TO_IDS.get(leaf.id) === TextPart._id;
      });
    }
    if (!TextPart) {
      // This can only happen if the current locale has no value and has no fallback
      if (TextParts.length === 0) {
        return /*#__PURE__*/React__default.createElement("span", attributes, children);
      }
      throw new Error("Missing part");
    }
    const TextPartComponent = /*#__PURE__*/React__default.createElement(RichTextPartClient, {
      value: children,
      Text: /*#__PURE__*/React__default.createElement(Box, _extends({
        __compiled: TextPart.styled.Text,
        devices: devices,
        stitches: stitches
      }, attributes)),
      TextWrapper: TextPart.components.TextWrapper[0] ? /*#__PURE__*/React__default.createElement(ComponentBuilder, {
        compiled: TextPart.components.TextWrapper[0],
        path: path,
        components: editorContext.components,
        passedProps: {
          __isSelected: leaf.isHighlighted && leaf.highlightType === "textWrapper"
        }
      }) : undefined
    });
    return TextPartComponent;
  }

  // Setting `display: flex` for element's aligning on `Editable` component makes default styles
  // of placeholder insufficient thus they require to explicitly set `top` and `left`.
  function renderPlaceholder(_ref3) {
    let {
      attributes,
      children
    } = _ref3;
    return /*#__PURE__*/React__default.createElement("span", _extends({}, attributes, {
      style: {
        ...attributes.style,
        top: 0,
        left: 0
      }
    }), children);
  }
  const scheduleConfigSync = useCallback(throttle(nextValue => {
    setEditorValue(nextValue);
    const nextElements = convertEditorValueToRichTextElements(nextValue);
    actions.runChange(() => {
      const newRichTextElement = {
        ...richTextConfig,
        elements: {
          ...richTextConfig.elements,
          [editorContext.contextParams.locale]: nextElements
        }
      };
      form.change(path, newRichTextElement);
      previousRichTextComponentConfig.current = newRichTextElement;
      if (editor.selection) {
        const nextFocusedFields = getFocusedFieldsFromSlateSelection(editor, path, contextParams.locale);
        return nextFocusedFields;
      }
    });
  }, RICH_TEXT_CONFIG_SYNC_THROTTLE_TIMEOUT), [isConfigChanged, editorContext.contextParams.locale]);
  const scheduleFocusedFieldsChange = useCallback(
  // Slate internally throttles the invocation of DOMSelectionChange for performance reasons.
  // We also throttle update of our focused fields state for the same reason.
  // This gives us a good balance between perf and showing updated fields within the sidebar.
  throttle(focusedFields => {
    setFocussedField(focusedFields);
  }, RICH_TEXT_FOCUSED_FIELDS_SYNC_THROTTLE_TIMEOUT), [setFocussedField]);
  function handleEditableChange(value) {
    if (!isEnabled) {
      return;
    }

    // Editor's value can be changed from outside ex. sidebar or history undo/redo. If the last reason for change
    // was "external", we skip this change. In case we would like to start typing immediately after undo/redo we
    // set last change reason to `text-input`.
    if (lastChangeReason.current === "external" || lastChangeReason.current === "paste") {
      lastChangeReason.current = "text-input";
      return;
    }
    const isValueSame = deepCompare$1(value, editorValue);

    // Slate runs `onChange` callback on any change, even when the text haven't changed.
    // If value haven't changed, it must be a selection change.
    if (isValueSame) {
      const nextFocusedFields = getFocusedFieldsFromSlateSelection(editor, path, contextParams.locale);
      if (nextFocusedFields) {
        scheduleFocusedFieldsChange(nextFocusedFields);
      }
      return;
    }
    lastChangeReason.current = "text-input";
    scheduleConfigSync(value);
  }
  function handleEditableFocus() {
    if (!isEnabled) {
      return;
    }
    lastChangeReason.current = "text-input";

    // When value for current locale is empty we present the value from fallback.
    // If user focuses editable element, we present the value of fallback unless it's also empty.
    if (!localizedRichTextElements) {
      let nextSlateValue = editor.children;
      let nextRichTextComponentConfig;
      if (fallbackRichTextElements) {
        nextRichTextComponentConfig = richTextConfig;
        const fallbackFirstTextPart = fallbackRichTextElements[0].elements[0].elements[0];

        // Keep only one line element with single empty rich text
        nextRichTextComponentConfig.elements[contextParams.locale] = [{
          ...fallbackRichTextElements[0],
          elements: [{
            ...fallbackRichTextElements[0].elements[0],
            elements: [{
              ...fallbackFirstTextPart,
              value: ""
            }]
          }]
        }];
        nextSlateValue = convertRichTextElementsToEditorValue(nextRichTextComponentConfig.elements[contextParams.locale]);
        editor.children = nextSlateValue;
        Transforms.select(editor, {
          anchor: Editor$1.start(editor, []),
          focus: Editor$1.start(editor, [])
        });
        form.change(path, nextRichTextComponentConfig);
      } else {
        // If current and fallback value is missing we have:
        // - empty Slate value
        // - empty config within component-collection-localised
        // We will build next $richText component config based on current Slate value
        nextRichTextComponentConfig = richTextConfig;
        nextRichTextComponentConfig.elements[contextParams.locale] = convertEditorValueToRichTextElements(editor.children);
        form.change(path, nextRichTextComponentConfig);
      }
      previousRichTextComponentConfig.current = nextRichTextComponentConfig;
      if (editor.selection) {
        const nextFocusedFields = getFocusedRichTextPartsConfigPaths(editor).map(richTextPartPath => getAbsoluteRichTextPartPath(richTextPartPath, path, contextParams.locale));
        setFocussedField(nextFocusedFields);
      }
    }
    if (isDecorationActive) {
      const root = ReactEditor.findDocumentOrShadowRoot(editor);
      const slateStringElements = root.querySelectorAll("[data-slate-string]");
      slateStringElements.forEach(element => {
        element.replaceChildren(document.createTextNode(element.textContent));
      });
    }
  }
  useEffect(() => {
    function saveLatestSelection() {
      const root = ReactEditor.findDocumentOrShadowRoot(editor);
      const selection = root.getSelection();
      if (selection && selection.type === "Range") {
        currentSelectionRef.current = ReactEditor.toSlateRange(editor, selection, {
          exactMatch: false,
          suppressThrow: true
        });
      } else {
        currentSelectionRef.current = null;
      }
    }
    const throttledSaveLatestSelection = throttle(saveLatestSelection, 100);
    if (isEnabled) {
      window.document.addEventListener("selectionchange", throttledSaveLatestSelection);
      return () => {
        window.document.removeEventListener("selectionchange", throttledSaveLatestSelection);
      };
    }
  }, [editor, isEnabled]);
  function handleEditableBlur() {
    lastChangeReason.current = "external";
    setIsDecorationActive(true);
  }

  // When copying content from content editable, Slate will copy HTML content of selected nodes
  // and this is not what we want. Instead we set clipboard data to contain selected content
  // in form of rich text editable component config.
  function handleEditableCopy(event) {
    const selectedRichTextComponentConfig = getRichTextComponentConfigFragment(richTextConfig, editorContext);
    event.clipboardData.setData("text/x-shopstory", JSON.stringify(selectedRichTextComponentConfig));
  }
  function handleEditablePaste(event) {
    const selectedRichTextComponentConfigClipboardData = event.clipboardData.getData("text/x-shopstory");
    if (selectedRichTextComponentConfigClipboardData) {
      const selectedRichTextComponentConfig = JSON.parse(selectedRichTextComponentConfigClipboardData);

      // Preventing the default action will also prevent Slate from handling this event on his own.
      event.preventDefault();
      const nextSlateValue = convertRichTextElementsToEditorValue(duplicateConfig(selectedRichTextComponentConfig, editorContext).elements[contextParams.locale]);
      const temporaryEditor = createTemporaryEditor(editor);
      Editor$1.insertFragment(temporaryEditor, nextSlateValue);
      const nextElements = convertEditorValueToRichTextElements(temporaryEditor.children);
      actions.runChange(() => {
        form.change(richTextElementsConfigPath, nextElements);
        const nextFocusedFields = getFocusedFieldsFromSlateSelection(temporaryEditor, path, contextParams.locale);
        return nextFocusedFields;
      });
      lastChangeReason.current = "paste";
    } else if (
    // Slate only handles pasting if the clipboardData contains text/plain type.
    // When copying text from the Contentful's rich text editor, the clipboardData contains
    // more than one type, so we have to handle this case manually.
    event.clipboardData.types.length > 1 && event.clipboardData.types.some(type => type === "text/plain")) {
      Editor$1.insertText(editor, event.clipboardData.getData("text/plain"));
      event.preventDefault();
    }
  }
  const contentEditableClassName = useMemo(() => {
    const responsiveAlignmentStyles = mapResponsiveAlignmentToStyles(align, {
      devices: editorContext.devices,
      resop
    });
    const isFallbackValueShown = localizedRichTextElements === undefined && fallbackRichTextElements !== undefined;

    // When we make a selection of text within editable container and then blur
    // sometimes the browser selection changes and shows incorrectly selected chunks.
    const getStyles = stitches.css({
      display: "flex",
      ...responsiveAlignmentStyles,
      cursor: !isEnabled ? "inherit" : "text",
      "& *": {
        pointerEvents: isEnabled ? "auto" : "none",
        userSelect: isEnabled ? "auto" : "none"
      },
      "& *::selection": {
        backgroundColor: "#b4d5fe"
      },
      ...(isDecorationActive && {
        "& *::selection": {
          backgroundColor: "transparent"
        },
        "& *[data-easyblocks-rich-text-selection]": {
          backgroundColor: "#b4d5fe"
        }
      }),
      ...(isFallbackValueShown && {
        opacity: 0.5
      }),
      // Remove any text decoration from slate nodes that are elements. We only need text decoration on text elements.
      "[data-slate-node]": {
        textDecoration: "none"
      }
    });
    return getStyles().className;
  }, [align, isDecorationActive, localizedRichTextElements, fallbackRichTextElements, isEnabled]);
  return /*#__PURE__*/React__default.createElement(Slate, {
    editor: editor,
    value: editorValue,
    onChange: handleEditableChange
  }, /*#__PURE__*/React__default.createElement("div", null, /*#__PURE__*/React__default.createElement(Editable, {
    className: contentEditableClassName,
    placeholder: "Here goes text content",
    renderElement: renderElement,
    renderLeaf: renderLeaf,
    renderPlaceholder: renderPlaceholder,
    decorate: decorate,
    onFocus: handleEditableFocus,
    onBlur: handleEditableBlur,
    onCopy: handleEditableCopy,
    onPaste: handleEditablePaste,
    onMouseDown: event => {
      if (isEnabled) {
        event.stopPropagation();
        return;
      }
      if (event.detail === 2) {
        event.preventDefault();
        flushSync(() => {
          setIsEnabled(true);
        });
        ReactEditor.focus(editor);
        if (isEditorValueEmpty(editor.children)) {
          return;
        }
        const editorSelectionRange = {
          anchor: Editor$1.start(editor, []),
          focus: Editor$1.end(editor, [])
        };
        Transforms.setSelection(editor, editorSelectionRange);
        const editorSelectionDOMRange = ReactEditor.toDOMRange(editor, editorSelectionRange);
        window.getSelection()?.setBaseAndExtent(editorSelectionDOMRange.startContainer, editorSelectionDOMRange.startOffset, editorSelectionDOMRange.endContainer, editorSelectionDOMRange.endOffset);
      }
    },
    readOnly: !isEnabled
  })));
}
function isEditorValueEmpty(editorValue) {
  return editorValue.length === 1 && editorValue[0].children.length === 1 && editorValue[0].children[0].children.length === 1 && Text$1.isText(editorValue[0].children[0].children[0]) && editorValue[0].children[0].children[0].text === "";
}
function isConfigEqual(newConfig, oldConfig) {
  return deepCompare$1(newConfig, oldConfig);
}
function mapResponsiveAlignmentToStyles(align, _ref4) {
  let {
    devices,
    resop
  } = _ref4;
  function mapAlignmentToFlexAlignment(align) {
    if (align === "center") {
      return "center";
    }
    if (align === "right") {
      return "flex-end";
    }
    return "flex-start";
  }
  const responsiveStyles = resop({
    align: responsiveValueFill(align, devices, getDevicesWidths(devices))
  }, values => {
    return {
      justifyContent: mapAlignmentToFlexAlignment(values.align),
      textAlign: values.align
    };
  }, devices);
  const compiledStyles = compileBox(responsiveStyles, devices);
  return getBoxStyles(compiledStyles, devices);
}
function createTextSelectionDecorator(editor) {
  return _ref5 => {
    let [node, path] = _ref5;
    const decorations = [];
    if (Text$1.isText(node) && editor.selection !== null && node.TextWrapper.length > 0 && Range.isCollapsed(editor.selection)) {
      const textRange = Editor$1.range(editor, path);
      const intersection = Range.intersection(editor.selection, textRange);
      if (intersection !== null) {
        const range = {
          isHighlighted: true,
          highlightType: "textWrapper",
          ...textRange
        };
        decorations.push(range);
      }
    }
    return decorations;
  };
}
function splitStringNodes(editor, selection) {
  const nodes = Editor$1.nodes(editor, {
    at: selection,
    match: Text$1.isText
  });
  const domNodes = Array.from(nodes).map(_ref6 => {
    let [node] = _ref6;
    const domNode = ReactEditor.toDOMNode(editor, node);
    return domNode;
  });
  if (domNodes.length === 1) {
    const slateString = domNodes[0].querySelector("[data-slate-string]");
    const textContent = slateString.textContent;
    const newChild = document.createDocumentFragment();

    // Selection made within whole text node
    if (textContent.length === selection.focus.offset - selection.anchor.offset || textContent.length === selection.anchor.offset - selection.focus.offset) {
      const selectedTextNode = document.createElement("span");
      selectedTextNode.textContent = textContent;
      selectedTextNode.dataset.easyblocksRichTextSelection = "true";
      newChild.appendChild(selectedTextNode);
      slateString.replaceChildren(newChild);
    } else {
      const selectedTextNode = document.createElement("span");
      selectedTextNode.textContent = textContent.slice(selection.anchor.offset, selection.focus.offset);
      selectedTextNode.dataset.easyblocksRichTextSelection = "true";
      newChild.appendChild(document.createTextNode(textContent.slice(0, selection.anchor.offset)));
      newChild.appendChild(selectedTextNode);
      newChild.appendChild(document.createTextNode(textContent.slice(selection.focus.offset)));
      slateString.replaceChildren(newChild);
    }
    return;
  }
  domNodes.forEach((node, index) => {
    const slateString = node.querySelector("[data-slate-string]");
    if (slateString) {
      const textContent = slateString.textContent;
      const newChild = document.createDocumentFragment();
      if (index === 0) {
        newChild.appendChild(document.createTextNode(slateString.textContent.slice(0, selection.anchor.offset)));
        const selectedTextNode = document.createElement("span");
        selectedTextNode.textContent = textContent.slice(selection.anchor.offset);
        selectedTextNode.dataset.easyblocksRichTextSelection = "true";
        newChild.appendChild(selectedTextNode);
        slateString.replaceChildren(newChild);
      } else if (index === domNodes.length - 1) {
        const selectedTextNode = document.createElement("span");
        selectedTextNode.textContent = textContent.slice(0, selection.focus.offset);
        selectedTextNode.dataset.easyblocksRichTextSelection = "true";
        newChild.appendChild(selectedTextNode);
        newChild.appendChild(document.createTextNode(textContent.slice(selection.focus.offset)));
        slateString.replaceChildren(newChild);
      } else {
        const selectedTextNode = document.createElement("span");
        selectedTextNode.textContent = textContent;
        selectedTextNode.dataset.easyblocksRichTextSelection = "true";
        newChild.appendChild(selectedTextNode);
        slateString.replaceChildren(newChild);
      }
    }
  });
}
function unwrapStringNodesContent(editor) {
  const root = ReactEditor.findDocumentOrShadowRoot(editor);
  const slateStringElements = root.querySelectorAll("[data-slate-string]");
  slateStringElements.forEach(element => {
    element.replaceChildren(document.createTextNode(element.textContent));
  });
}

var index$1 = useLayoutEffect ;

var useLatest = function useLatest(value) {
  var ref = React__default.useRef(value);
  index$1(function () {
    ref.current = value;
  });
  return ref;
};

// basically Exclude<React.ClassAttributes<T>["ref"], string>

var updateRef = function updateRef(ref, value) {
  if (typeof ref === 'function') {
    ref(value);
    return;
  }
  ref.current = value;
};
var useComposedRef = function useComposedRef(libRef, userRef) {
  var prevUserRef = React__default.useRef();
  return React__default.useCallback(function (instance) {
    libRef.current = instance;
    if (prevUserRef.current) {
      updateRef(prevUserRef.current, null);
    }
    prevUserRef.current = userRef;
    if (!userRef) {
      return;
    }
    updateRef(userRef, instance);
  }, [userRef]);
};

var HIDDEN_TEXTAREA_STYLE = {
  'min-height': '0',
  'max-height': 'none',
  height: '0',
  visibility: 'hidden',
  overflow: 'hidden',
  position: 'absolute',
  'z-index': '-1000',
  top: '0',
  right: '0',
  display: 'block'
};
var forceHiddenStyles = function forceHiddenStyles(node) {
  Object.keys(HIDDEN_TEXTAREA_STYLE).forEach(function (key) {
    node.style.setProperty(key, HIDDEN_TEXTAREA_STYLE[key], 'important');
  });
};
var forceHiddenStyles$1 = forceHiddenStyles;

var hiddenTextarea = null;
var getHeight = function getHeight(node, sizingData) {
  var height = node.scrollHeight;
  if (sizingData.sizingStyle.boxSizing === 'border-box') {
    // border-box: add border, since height = content + padding + border
    return height + sizingData.borderSize;
  }

  // remove padding, since height = content
  return height - sizingData.paddingSize;
};
function calculateNodeHeight(sizingData, value, minRows, maxRows) {
  if (minRows === void 0) {
    minRows = 1;
  }
  if (maxRows === void 0) {
    maxRows = Infinity;
  }
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement('textarea');
    hiddenTextarea.setAttribute('tabindex', '-1');
    hiddenTextarea.setAttribute('aria-hidden', 'true');
    forceHiddenStyles$1(hiddenTextarea);
  }
  if (hiddenTextarea.parentNode === null) {
    document.body.appendChild(hiddenTextarea);
  }
  var paddingSize = sizingData.paddingSize,
    borderSize = sizingData.borderSize,
    sizingStyle = sizingData.sizingStyle;
  var boxSizing = sizingStyle.boxSizing;
  Object.keys(sizingStyle).forEach(function (_key) {
    var key = _key;
    hiddenTextarea.style[key] = sizingStyle[key];
  });
  forceHiddenStyles$1(hiddenTextarea);
  hiddenTextarea.value = value;
  var height = getHeight(hiddenTextarea, sizingData);
  // Double set and calc due to Firefox bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1795904
  hiddenTextarea.value = value;
  height = getHeight(hiddenTextarea, sizingData);

  // measure height of a textarea with a single row
  hiddenTextarea.value = 'x';
  var rowHeight = hiddenTextarea.scrollHeight - paddingSize;
  var minHeight = rowHeight * minRows;
  if (boxSizing === 'border-box') {
    minHeight = minHeight + paddingSize + borderSize;
  }
  height = Math.max(minHeight, height);
  var maxHeight = rowHeight * maxRows;
  if (boxSizing === 'border-box') {
    maxHeight = maxHeight + paddingSize + borderSize;
  }
  height = Math.min(maxHeight, height);
  return [height, rowHeight];
}

var noop = function noop() {};
var pick = function pick(props, obj) {
  return props.reduce(function (acc, prop) {
    acc[prop] = obj[prop];
    return acc;
  }, {});
};

var SIZING_STYLE = ['borderBottomWidth', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth', 'boxSizing', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'letterSpacing', 'lineHeight', 'paddingBottom', 'paddingLeft', 'paddingRight', 'paddingTop',
// non-standard
'tabSize', 'textIndent',
// non-standard
'textRendering', 'textTransform', 'width', 'wordBreak', 'wordSpacing', 'scrollbarGutter'];
var isIE = !!document.documentElement.currentStyle ;
var getSizingData = function getSizingData(node) {
  var style = window.getComputedStyle(node);
  if (style === null) {
    return null;
  }
  var sizingStyle = pick(SIZING_STYLE, style);
  var boxSizing = sizingStyle.boxSizing;

  // probably node is detached from DOM, can't read computed dimensions
  if (boxSizing === '') {
    return null;
  }

  // IE (Edge has already correct behaviour) returns content width as computed width
  // so we need to add manually padding and border widths
  if (isIE && boxSizing === 'border-box') {
    sizingStyle.width = parseFloat(sizingStyle.width) + parseFloat(sizingStyle.borderRightWidth) + parseFloat(sizingStyle.borderLeftWidth) + parseFloat(sizingStyle.paddingRight) + parseFloat(sizingStyle.paddingLeft) + 'px';
  }
  var paddingSize = parseFloat(sizingStyle.paddingBottom) + parseFloat(sizingStyle.paddingTop);
  var borderSize = parseFloat(sizingStyle.borderBottomWidth) + parseFloat(sizingStyle.borderTopWidth);
  return {
    sizingStyle: sizingStyle,
    paddingSize: paddingSize,
    borderSize: borderSize
  };
};
var getSizingData$1 = getSizingData;

function useListener(target, type, listener) {
  var latestListener = useLatest(listener);
  React.useLayoutEffect(function () {
    var handler = function handler(ev) {
      return latestListener.current(ev);
    };
    // might happen if document.fonts is not defined, for instance
    if (!target) {
      return;
    }
    target.addEventListener(type, handler);
    return function () {
      return target.removeEventListener(type, handler);
    };
  }, []);
}
var useFormResetListener = function useFormResetListener(libRef, listener) {
  useListener(document.body, 'reset', function (ev) {
    if (libRef.current.form === ev.target) {
      listener(ev);
    }
  });
};
var useWindowResizeListener = function useWindowResizeListener(listener) {
  useListener(window, 'resize', listener);
};
var useFontsLoadedListener = function useFontsLoadedListener(listener) {
  useListener(document.fonts, 'loadingdone', listener);
};

var _excluded = ["cacheMeasurements", "maxRows", "minRows", "onChange", "onHeightChange"];
var TextareaAutosize = function TextareaAutosize(_ref, userRef) {
  var cacheMeasurements = _ref.cacheMeasurements,
    maxRows = _ref.maxRows,
    minRows = _ref.minRows,
    _ref$onChange = _ref.onChange,
    onChange = _ref$onChange === void 0 ? noop : _ref$onChange,
    _ref$onHeightChange = _ref.onHeightChange,
    onHeightChange = _ref$onHeightChange === void 0 ? noop : _ref$onHeightChange,
    props = _objectWithoutPropertiesLoose$2(_ref, _excluded);
  var isControlled = props.value !== undefined;
  var libRef = React.useRef(null);
  var ref = useComposedRef(libRef, userRef);
  var heightRef = React.useRef(0);
  var measurementsCacheRef = React.useRef();
  var resizeTextarea = function resizeTextarea() {
    var node = libRef.current;
    var nodeSizingData = cacheMeasurements && measurementsCacheRef.current ? measurementsCacheRef.current : getSizingData$1(node);
    if (!nodeSizingData) {
      return;
    }
    measurementsCacheRef.current = nodeSizingData;
    var _calculateNodeHeight = calculateNodeHeight(nodeSizingData, node.value || node.placeholder || 'x', minRows, maxRows),
      height = _calculateNodeHeight[0],
      rowHeight = _calculateNodeHeight[1];
    if (heightRef.current !== height) {
      heightRef.current = height;
      node.style.setProperty('height', height + "px", 'important');
      onHeightChange(height, {
        rowHeight: rowHeight
      });
    }
  };
  var handleChange = function handleChange(event) {
    if (!isControlled) {
      resizeTextarea();
    }
    onChange(event);
  };
  {
    React.useLayoutEffect(resizeTextarea);
    useFormResetListener(libRef, function () {
      if (!isControlled) {
        var currentValue = libRef.current.value;
        requestAnimationFrame(function () {
          var node = libRef.current;
          if (node && currentValue !== node.value) {
            resizeTextarea();
          }
        });
      }
    });
    useWindowResizeListener(resizeTextarea);
    useFontsLoadedListener(resizeTextarea);
    return /*#__PURE__*/React.createElement("textarea", _extends$1({}, props, {
      onChange: handleChange,
      ref: ref
    }));
  }
};
var index = /* #__PURE__ */React.forwardRef(TextareaAutosize);

/* with love from shopstory */

function useTextValue(value, onChange, locale, locales, defaultPlaceholder, normalize) {
  const isExternal = typeof value === "object" && value !== null;
  const fallbackValue = isExternal ? getFallbackForLocale(value.value, locale, locales) : undefined;
  const valueFromProps = (() => {
    if (isExternal) {
      let displayedValue = value.value?.[locale];
      if (typeof displayedValue !== "string") {
        displayedValue = fallbackValue ?? "";
      }
      return displayedValue;
    }
    return value ?? "";
  })();
  const previousValue = React__default.useRef(valueFromProps);
  const [localInputValue, setLocalInputValue] = React__default.useState(valueFromProps);
  function saveNewValue(newValue) {
    if (isExternal) {
      const newExternalValue = {
        ...value,
        value: {
          ...value.value,
          [locale]: newValue
        }
      };
      onChange(newExternalValue);
    } else {
      onChange(newValue);
    }
  }
  const onChangeDebounced = React__default.useCallback(debounce(newValue => {
    // If normalization is on, we shouldn't save on change
    if (normalize) {
      return;
    }
    saveNewValue(newValue);
  }, 500), [isExternal]);
  function handleBlur() {
    onChangeDebounced.cancel();
    let newValue = localInputValue;
    if (normalize) {
      const normalized = normalize(newValue);
      if (normalized === null) {
        newValue = previousValue.current;
      } else {
        newValue = normalized;
        previousValue.current = localInputValue;
      }
    }
    setLocalInputValue(newValue);
    if (isExternal) {
      if (newValue.trim() === "") {
        saveNewValue(null);
        setLocalInputValue(fallbackValue ?? "");
      } else {
        saveNewValue(newValue);
      }
    } else {
      if (value !== newValue) {
        saveNewValue(newValue);
      }
    }
  }
  function handleChange(event) {
    setLocalInputValue(event.target.value);
    onChangeDebounced(event.target.value);
  }

  // Sync local value with value from the config if the field value has been
  // changed from outside
  React__default.useEffect(() => {
    setLocalInputValue(valueFromProps);
  }, [valueFromProps]);
  const style = {
    opacity: localInputValue === fallbackValue ? 0.5 : 1
  };
  return {
    onChange: handleChange,
    onBlur: handleBlur,
    value: cleanString(localInputValue),
    style,
    placeholder: defaultPlaceholder ?? "Enter text"
  };
}

/* with love from shopstory */

function InlineTextarea(_ref) {
  let {
    path,
    placeholder,
    stitches
  } = _ref;
  const [isEnabled, setIsEnabled] = useState(false);
  const textAreaRef = useRef(null);
  const {
    form,
    contextParams: {
      locale
    },
    locales
  } = window.parent.editorWindowAPI.editorContext;
  const valuePath = `${path}.value`;
  const value = dotNotationGet$1(form.values, valuePath);
  const inputProps = useTextValue(value, val => {
    form.change(valuePath, val);
  }, locale, locales, placeholder);
  const css = stitches.css({
    width: "100%",
    wordWrap: "break-word",
    display: "block",
    fontSize: "inherit",
    fontFamily: "inherit",
    fontWeight: "inherit",
    boxSizing: "border-box",
    color: "inherit",
    letterSpacing: "inherit",
    lineHeight: "inherit",
    margin: "0 auto",
    maxWidth: "inherit",
    textTransform: "inherit",
    backgroundColor: "inherit",
    textAlign: "inherit",
    outline: "none",
    resize: "none",
    border: "none",
    overflow: "visible",
    position: "relative",
    padding: 0,
    "-ms-overflow-style": "none",
    "&::-webkit-scrollbar": {
      display: "none"
    },
    pointerEvents: isEnabled ? "auto" : "none"
  })();
  return /*#__PURE__*/React__default.createElement("div", {
    onMouseDown: event => {
      if (event.detail === 2) {
        event.preventDefault();
        flushSync(() => {
          setIsEnabled(true);
        });
        textAreaRef.current?.select();
      }
    }
  }, /*#__PURE__*/React__default.createElement(index, _extends({
    className: css,
    rows: 1
  }, inputProps, {
    ref: textAreaRef,
    onMouseDown: event => {
      if (isEnabled) {
        event.stopPropagation();
        return;
      }
    },
    onBlur: () => {
      setIsEnabled(false);
    }
  })));
}

function TextEditor(props) {
  const {
    Text,
    value,
    __easyblocks: {
      path,
      runtime
    }
  } = props;
  const {
    form
  } = window.parent.editorWindowAPI.editorContext;
  const valuePath = `${path}.value`;
  const configValue = dotNotationGet$1(form.values, valuePath);
  const isLocalTextReference = configValue.id?.startsWith("local.");
  return /*#__PURE__*/React__default.createElement(Text.type, _extends({}, Text.props, {
    as: "div"
  }), isLocalTextReference ? /*#__PURE__*/React__default.createElement(InlineTextarea, {
    path: path,
    placeholder: "Here goes text content",
    stitches: runtime.stitches
  }) : value ?? /*#__PURE__*/React__default.createElement("span", null, "\xA0"));
}

const PRIME32_1 = 2654435761;
const PRIME32_2 = 2246822519;
const PRIME32_3 = 3266489917;
const PRIME32_4 = 668265263;
const PRIME32_5 = 374761393;
let encoder;
/**
 *
 * @param input - byte array or string
 * @param seed - optional seed (32-bit unsigned);
 */
function xxHash32(input, seed = 0) {
    const buffer = typeof input === 'string' ? (encoder ??= new TextEncoder()).encode(input) : input;
    const b = buffer;
    /*
        Step 1. Initialize internal accumulators
        Each accumulator gets an initial value based on optional seed input. Since the seed is optional, it can be 0.

        ```
            u32 acc1 = seed + PRIME32_1 + PRIME32_2;
            u32 acc2 = seed + PRIME32_2;
            u32 acc3 = seed + 0;
            u32 acc4 = seed - PRIME32_1;
        ```
        Special case : input is less than 16 bytes
        When input is too small (< 16 bytes), the algorithm will not process any stripe. Consequently, it will not
        make use of parallel accumulators.

        In which case, a simplified initialization is performed, using a single accumulator :

        u32 acc  = seed + PRIME32_5;
        The algorithm then proceeds directly to step 4.
    */
    let acc = (seed + PRIME32_5) & 0xffffffff;
    let offset = 0;
    if (b.length >= 16) {
        const accN = [
            (seed + PRIME32_1 + PRIME32_2) & 0xffffffff,
            (seed + PRIME32_2) & 0xffffffff,
            (seed + 0) & 0xffffffff,
            (seed - PRIME32_1) & 0xffffffff,
        ];
        /*
            Step 2. Process stripes
            A stripe is a contiguous segment of 16 bytes. It is evenly divided into 4 lanes, of 4 bytes each.
            The first lane is used to update accumulator 1, the second lane is used to update accumulator 2, and so on.

            Each lane read its associated 32-bit value using little-endian convention.

            For each {lane, accumulator}, the update process is called a round, and applies the following formula :

            ```
            accN = accN + (laneN * PRIME32_2);
            accN = accN <<< 13;
            accN = accN * PRIME32_1;
            ```

            This shuffles the bits so that any bit from input lane impacts several bits in output accumulator.
            All operations are performed modulo 2^32.

            Input is consumed one full stripe at a time. Step 2 is looped as many times as necessary to consume
            the whole input, except the last remaining bytes which cannot form a stripe (< 16 bytes). When that
            happens, move to step 3.
        */
        const b = buffer;
        const limit = b.length - 16;
        let lane = 0;
        for (offset = 0; (offset & 0xfffffff0) <= limit; offset += 4) {
            const i = offset;
            const laneN0 = b[i + 0] + (b[i + 1] << 8);
            const laneN1 = b[i + 2] + (b[i + 3] << 8);
            const laneNP = laneN0 * PRIME32_2 + ((laneN1 * PRIME32_2) << 16);
            let acc = (accN[lane] + laneNP) & 0xffffffff;
            acc = (acc << 13) | (acc >>> 19);
            const acc0 = acc & 0xffff;
            const acc1 = acc >>> 16;
            accN[lane] = (acc0 * PRIME32_1 + ((acc1 * PRIME32_1) << 16)) & 0xffffffff;
            lane = (lane + 1) & 0x3;
        }
        /*
            Step 3. Accumulator convergence
            All 4 lane accumulators from previous steps are merged to produce a single remaining accumulator
            of same width (32-bit). The associated formula is as follows :

            ```
            acc = (acc1 <<< 1) + (acc2 <<< 7) + (acc3 <<< 12) + (acc4 <<< 18);
            ```
        */
        acc =
            (((accN[0] << 1) | (accN[0] >>> 31)) +
                ((accN[1] << 7) | (accN[1] >>> 25)) +
                ((accN[2] << 12) | (accN[2] >>> 20)) +
                ((accN[3] << 18) | (accN[3] >>> 14))) &
                0xffffffff;
    }
    /*
        Step 4. Add input length
        The input total length is presumed known at this stage. This step is just about adding the length to
        accumulator, so that it participates to final mixing.

        ```
        acc = acc + (u32)inputLength;
        ```
    */
    acc = (acc + buffer.length) & 0xffffffff;
    /*
        Step 5. Consume remaining input
        There may be up to 15 bytes remaining to consume from the input. The final stage will digest them according
        to following pseudo-code :
        ```
        while (remainingLength >= 4) {
            lane = read_32bit_little_endian(input_ptr);
            acc = acc + lane * PRIME32_3;
            acc = (acc <<< 17) * PRIME32_4;
            input_ptr += 4; remainingLength -= 4;
        }
        ```
        This process ensures that all input bytes are present in the final mix.
    */
    const limit = buffer.length - 4;
    for (; offset <= limit; offset += 4) {
        const i = offset;
        const laneN0 = b[i + 0] + (b[i + 1] << 8);
        const laneN1 = b[i + 2] + (b[i + 3] << 8);
        const laneP = laneN0 * PRIME32_3 + ((laneN1 * PRIME32_3) << 16);
        acc = (acc + laneP) & 0xffffffff;
        acc = (acc << 17) | (acc >>> 15);
        acc = ((acc & 0xffff) * PRIME32_4 + (((acc >>> 16) * PRIME32_4) << 16)) & 0xffffffff;
    }
    /*
        ```
        while (remainingLength >= 1) {
            lane = read_byte(input_ptr);
            acc = acc + lane * PRIME32_5;
            acc = (acc <<< 11) * PRIME32_1;
            input_ptr += 1; remainingLength -= 1;
        }
        ```
    */
    for (; offset < b.length; ++offset) {
        const lane = b[offset];
        acc = acc + lane * PRIME32_5;
        acc = (acc << 11) | (acc >>> 21);
        acc = ((acc & 0xffff) * PRIME32_1 + (((acc >>> 16) * PRIME32_1) << 16)) & 0xffffffff;
    }
    /*
        Step 6. Final mix (avalanche)
        The final mix ensures that all input bits have a chance to impact any bit in the output digest,
        resulting in an unbiased distribution. This is also called avalanche effect.
        ```
        acc = acc xor (acc >> 15);
        acc = acc * PRIME32_2;
        acc = acc xor (acc >> 13);
        acc = acc * PRIME32_3;
        acc = acc xor (acc >> 16);
        ```
    */
    acc = acc ^ (acc >>> 15);
    acc = (((acc & 0xffff) * PRIME32_2) & 0xffffffff) + (((acc >>> 16) * PRIME32_2) << 16);
    acc = acc ^ (acc >>> 13);
    acc = (((acc & 0xffff) * PRIME32_3) & 0xffffffff) + (((acc >>> 16) * PRIME32_3) << 16);
    acc = acc ^ (acc >>> 16);
    // turn any negatives back into a positive number;
    return acc < 0 ? acc + 4294967296 : acc;
}

/* with love from shopstory */
function responsiveValueGetHighestDefinedDevice(input, devices) {
  let highestDefinedDevice;
  for (let i = devices.length - 1; i >= 0; i--) {
    const device = devices[i];
    if (input[device.id] !== undefined) {
      highestDefinedDevice = device;
      break;
    }
  }
  if (highestDefinedDevice === undefined) {
    throw new Error("highest defined value doesn't exist");
  }
  return highestDefinedDevice;
}

/* with love from shopstory */

function applyAutoUsingResponsiveTokens(input, compilationContext) {
  if (!isTrulyResponsiveValue$1(input)) {
    return input;
  }
  const highestDefinedDevice = responsiveValueGetHighestDefinedDevice(input, compilationContext.devices);
  let highestDefinedValue = responsiveValueForceGet(input, highestDefinedDevice.id);
  const inputAfterAuto = {
    $res: true
  };
  for (let i = compilationContext.devices.length - 1; i >= 0; i--) {
    const device = compilationContext.devices[i];
    const value = responsiveValueGet(input, device.id);
    if (value === undefined && isTrulyResponsiveValue$1(highestDefinedValue.value)) {
      inputAfterAuto[device.id] = highestDefinedValue;
    }
    if (value !== undefined) {
      inputAfterAuto[device.id] = value;
      highestDefinedValue = input[device.id];
    }
  }
  return inputAfterAuto;
}

/* with love from shopstory */

function compileFromSchema(value, schemaProp, compilationContext, cache, contextProps, meta, editingInfoComponent, configPrefix) {
  return getSchemaDefinition(schemaProp, compilationContext).compile(value, contextProps, meta, editingInfoComponent, configPrefix, cache);
}

/* with love from shopstory */

/**
 * This compilation function doesn't take schema. It means that it assumes couple of things:
 * 1. That input is NoCodeComponentEntry or 1-item array of. NoCodeComponentEntry. Basically it's a single component.
 * 2. Return format
 */
function compileComponentValues(inputValues, componentDefinition, compilationContext, cache) {
  const values = {};
  componentDefinition.schema.forEach(schemaProp => {
    if (!isSchemaPropComponentOrComponentCollection(schemaProp)) {
      values[schemaProp.prop] = compileFromSchema(inputValues[schemaProp.prop], schemaProp, compilationContext, cache);
    }
  });
  return values;
}

/* with love from shopstory */

/**
 * When selecting text within $richText, we keep information about which text parts are selected
 * within focused fields. If the text part is partially selected, we add information about the selection.
 * This selection has format: ".{textPartCharacterSelectionStartIndex,textPartCharacterSelectionEndIndex}".
 * We often want to query related to selection text part component config and to do that correctly we need to
 * strip information about selection.
 */
function stripRichTextPartSelection(value) {
  return value.replace(/\.\{\d+,\d+\}$/g, "");
}
function parsePath(path, form) {
  const values = form.values;
  const pathSplit = path === "" ? [] : stripRichTextPartSelection(path).split(".");
  let pathInfo = undefined;

  // We're going from current path down the path to find current template and parent template
  for (let i = pathSplit.length; i >= 0; i--) {
    const testedPath = pathSplit.slice(0, i).join(".");
    const value = dotNotationGet$1(values, testedPath);
    if (typeof value === "object" && typeof value._component === "string") {
      if (pathInfo === undefined) {
        pathInfo = {
          templateId: value._component
        };

        // fieldName
        const fieldPath = pathSplit.slice(i);
        if (fieldPath.length > 0) {
          pathInfo.fieldName = fieldPath.join(".");
        }
        const potentialIndex = parseInt(pathSplit[i - 1]);
        if (!isNaN(potentialIndex)) {
          pathInfo.index = potentialIndex;
        }
      } else {
        pathInfo.parent = {
          templateId: value._component,
          fieldName: pathSplit[i],
          path: testedPath
        };
        break;
      }
    }
  }
  if (!pathInfo) {
    throw new Error(`incorrect path: ${path}`);
  }
  return pathInfo;
}
function findPathOfFirstAncestorOfType(path, templateId, form) {
  while (true) {
    const parseResult = parsePath(path, form);
    if (!parseResult.parent) {
      throw new Error(`couldn't find ancestor of type ${templateId}`);
    }
    if (parseResult.parent.templateId === templateId) {
      return parseResult.parent.path;
    }
    path = parseResult.parent.path;
  }
}

/* with love from shopstory */
const DEFAULT_FONT_VALUES = {
  fontWeight: "initial",
  fontStyle: "initial"
};
function richTextPartStyles(_ref) {
  let {
    values: {
      color,
      font,
      TextWrapper
    },
    isEditing
  } = _ref;
  const fontWithDefaults = {
    ...DEFAULT_FONT_VALUES,
    ...font
  };
  const hasTextWrapper = TextWrapper.length > 0;
  const textStyles = {
    __as: "span",
    color,
    ...fontWithDefaults
  };
  if (hasTextWrapper && !isEditing) {
    // Force pointer events to be enabled on the text when text wrapper is attached and we're not editing
    textStyles.pointerEvents = "auto";
  }
  if (isEditing) {
    // When editing, we're going to have nested spans rendered by Slate so we need to make sure they inherit the font
    // styles defined on Text component
    textStyles['& [data-slate-string="true"]'] = {
      fontFamily: "inherit",
      fontStyle: "inherit",
      color: "inherit"
    };
  }
  return {
    styled: {
      Text: textStyles
    }
  };
}

/* with love from shopstory */

const editing = _ref => {
  let {
    editingInfo,
    __SECRET_INTERNALS__
  } = _ref;
  if (!__SECRET_INTERNALS__) {
    throw new Error("Missing __SECRET_INTERNALS__");
  }
  const {
    pathPrefix,
    editorContext
  } = __SECRET_INTERNALS__;
  const resultFields = [];
  const richTextPath = findPathOfFirstAncestorOfType(pathPrefix, "@easyblocks/rich-text", editorContext.form);
  const richTextBlockPath = findPathOfFirstAncestorOfType(pathPrefix, "@easyblocks/rich-text-block-element", editorContext.form);
  resultFields.push({
    type: "fields",
    path: richTextPath,
    filters: {
      group: ["Size", "Margins"]
    }
  }, {
    type: "field",
    path: `${richTextPath}.align`
  }, ...editingInfo.fields, {
    type: "field",
    path: `${richTextBlockPath}.type`
  }, {
    type: "field",
    path: `${richTextPath}.isListStyleAuto`
  }, {
    type: "field",
    path: `${richTextPath}.mainFont`
  }, {
    type: "field",
    path: `${richTextPath}.mainColor`
  }, {
    type: "fields",
    path: richTextPath,
    filters: {
      group: ["Accessibility and SEO"]
    }
  });
  return {
    fields: resultFields
  };
};
const richTextPartEditableComponent = {
  id: "@easyblocks/rich-text-part",
  label: "Text",
  schema: [{
    prop: "value",
    type: "string",
    visible: false,
    group: "Text"
  }, {
    prop: "font",
    label: "Style",
    type: "font",
    group: "Text"
  }, {
    prop: "color",
    label: "Color",
    type: "color",
    group: "Text"
  }, {
    prop: "TextWrapper",
    label: "Text Wrapper",
    type: "component",
    noInline: true,
    accepts: ["@easyblocks/text-wrapper"],
    visible: true,
    group: "Text Wrapper",
    isLabelHidden: true
  }],
  editing,
  styles: richTextPartStyles
};

/* with love from shopstory */

/**
 * Returns the most common value for given `prop` parameter among all @easyblocks/rich-text-part components from `richTextComponentConfig`.
 */
function getMostCommonValueFromRichTextParts(richTextComponentConfig, prop, compilationContext, cache) {
  const richTextBlockElements = richTextComponentConfig.elements[compilationContext.contextParams.locale] ?? getFallbackForLocale(richTextComponentConfig.elements, compilationContext.contextParams.locale, compilationContext.locales);
  if (!richTextBlockElements) {
    return;
  }
  const richTextParts = richTextBlockElements.flatMap(blockElement => {
    return blockElement.elements.flatMap(lineElement => {
      return lineElement.elements;
    });
  });
  const richTextPartComponentDefinition = findComponentDefinitionById(richTextPartEditableComponent.id, compilationContext);
  const deviceIdToRichTextPartValuesGroupedByPropValue = Object.fromEntries(compilationContext.devices.map(device => {
    const richTextPartsCompiledPropValues = richTextParts.flatMap(richTextPart => {
      return mapRichTextPartToCompiledPropValue(richTextPart, richTextPartComponentDefinition, compilationContext, prop, cache);
    });
    const richTextPartValuesLengthGroupedByPropValue = richTextPartsCompiledPropValues.reduce((acc, current) => groupTotalValueLengthByCompiledPropValue(prop, device)(acc, current), {});
    return [device.id, richTextPartValuesLengthGroupedByPropValue];
  }).filter(entry => Object.keys(entry[1]).length > 0).map(entry => {
    return [entry[0], getCompiledValueFromEntryWithMaxTotalValueLength(entry)];
  }));
  if (Object.keys(deviceIdToRichTextPartValuesGroupedByPropValue).length === 0) {
    return;
  }
  return {
    $res: true,
    ...deviceIdToRichTextPartValuesGroupedByPropValue
  };
}
function getCompiledValueFromEntryWithMaxTotalValueLength(entry) {
  const compiledPropValue = entries(entry[1]).reduce((maxEntry, currentEntry) => currentEntry[1] > maxEntry[1] ? currentEntry : maxEntry)[0];
  try {
    return JSON.parse(compiledPropValue);
  } catch {
    return compiledPropValue;
  }
}
function groupTotalValueLengthByCompiledPropValue(prop, device) {
  return (acc, current) => {
    const key = JSON.stringify(current[prop][device.id]);
    if (key === undefined) {
      return acc;
    }
    if (!acc[key]) {
      acc[key] = 0;
    }
    acc[key] += current.value.length;
    return acc;
  };
}
function mapRichTextPartToCompiledPropValue(richTextPart, richTextPartComponentDefinition, compilationContext, prop, cache) {
  const compiledValues = compileComponentValues(richTextPart, richTextPartComponentDefinition, compilationContext, cache);
  return {
    value: richTextPart.value,
    [prop]: compiledValues[prop]
  };
}

var openParentheses = "(".charCodeAt(0);
var closeParentheses = ")".charCodeAt(0);
var singleQuote = "'".charCodeAt(0);
var doubleQuote = '"'.charCodeAt(0);
var backslash = "\\".charCodeAt(0);
var slash = "/".charCodeAt(0);
var comma = ",".charCodeAt(0);
var colon = ":".charCodeAt(0);
var star = "*".charCodeAt(0);

var parse$3 = function(input) {
  var tokens = [];
  var value = input;

  var next, quote, prev, token, escape, escapePos, whitespacePos;
  var pos = 0;
  var code = value.charCodeAt(pos);
  var max = value.length;
  var stack = [{ nodes: tokens }];
  var balanced = 0;
  var parent;

  var name = "";
  var before = "";
  var after = "";

  while (pos < max) {
    // Whitespaces
    if (code <= 32) {
      next = pos;
      do {
        next += 1;
        code = value.charCodeAt(next);
      } while (code <= 32);
      token = value.slice(pos, next);

      prev = tokens[tokens.length - 1];
      if (code === closeParentheses && balanced) {
        after = token;
      } else if (prev && prev.type === "div") {
        prev.after = token;
      } else if (
        code === comma ||
        code === colon ||
        (code === slash && value.charCodeAt(next + 1) !== star)
      ) {
        before = token;
      } else {
        tokens.push({
          type: "space",
          sourceIndex: pos,
          value: token
        });
      }

      pos = next;

      // Quotes
    } else if (code === singleQuote || code === doubleQuote) {
      next = pos;
      quote = code === singleQuote ? "'" : '"';
      token = {
        type: "string",
        sourceIndex: pos,
        quote: quote
      };
      do {
        escape = false;
        next = value.indexOf(quote, next + 1);
        if (~next) {
          escapePos = next;
          while (value.charCodeAt(escapePos - 1) === backslash) {
            escapePos -= 1;
            escape = !escape;
          }
        } else {
          value += quote;
          next = value.length - 1;
          token.unclosed = true;
        }
      } while (escape);
      token.value = value.slice(pos + 1, next);

      tokens.push(token);
      pos = next + 1;
      code = value.charCodeAt(pos);

      // Comments
    } else if (code === slash && value.charCodeAt(pos + 1) === star) {
      token = {
        type: "comment",
        sourceIndex: pos
      };

      next = value.indexOf("*/", pos);
      if (next === -1) {
        token.unclosed = true;
        next = value.length;
      }

      token.value = value.slice(pos + 2, next);
      tokens.push(token);

      pos = next + 2;
      code = value.charCodeAt(pos);

      // Dividers
    } else if (code === slash || code === comma || code === colon) {
      token = value[pos];

      tokens.push({
        type: "div",
        sourceIndex: pos - before.length,
        value: token,
        before: before,
        after: ""
      });
      before = "";

      pos += 1;
      code = value.charCodeAt(pos);

      // Open parentheses
    } else if (openParentheses === code) {
      // Whitespaces after open parentheses
      next = pos;
      do {
        next += 1;
        code = value.charCodeAt(next);
      } while (code <= 32);
      token = {
        type: "function",
        sourceIndex: pos - name.length,
        value: name,
        before: value.slice(pos + 1, next)
      };
      pos = next;

      if (name === "url" && code !== singleQuote && code !== doubleQuote) {
        next -= 1;
        do {
          escape = false;
          next = value.indexOf(")", next + 1);
          if (~next) {
            escapePos = next;
            while (value.charCodeAt(escapePos - 1) === backslash) {
              escapePos -= 1;
              escape = !escape;
            }
          } else {
            value += ")";
            next = value.length - 1;
            token.unclosed = true;
          }
        } while (escape);
        // Whitespaces before closed
        whitespacePos = next;
        do {
          whitespacePos -= 1;
          code = value.charCodeAt(whitespacePos);
        } while (code <= 32);
        if (pos !== whitespacePos + 1) {
          token.nodes = [
            {
              type: "word",
              sourceIndex: pos,
              value: value.slice(pos, whitespacePos + 1)
            }
          ];
        } else {
          token.nodes = [];
        }
        if (token.unclosed && whitespacePos + 1 !== next) {
          token.after = "";
          token.nodes.push({
            type: "space",
            sourceIndex: whitespacePos + 1,
            value: value.slice(whitespacePos + 1, next)
          });
        } else {
          token.after = value.slice(whitespacePos + 1, next);
        }
        pos = next + 1;
        code = value.charCodeAt(pos);
        tokens.push(token);
      } else {
        balanced += 1;
        token.after = "";
        tokens.push(token);
        stack.push(token);
        tokens = token.nodes = [];
        parent = token;
      }
      name = "";

      // Close parentheses
    } else if (closeParentheses === code && balanced) {
      pos += 1;
      code = value.charCodeAt(pos);

      parent.after = after;
      after = "";
      balanced -= 1;
      stack.pop();
      parent = stack[balanced];
      tokens = parent.nodes;

      // Words
    } else {
      next = pos;
      do {
        if (code === backslash) {
          next += 1;
        }
        next += 1;
        code = value.charCodeAt(next);
      } while (
        next < max &&
        !(
          code <= 32 ||
          code === singleQuote ||
          code === doubleQuote ||
          code === comma ||
          code === colon ||
          code === slash ||
          code === openParentheses ||
          (code === closeParentheses && balanced)
        )
      );
      token = value.slice(pos, next);

      if (openParentheses === code) {
        name = token;
      } else {
        tokens.push({
          type: "word",
          sourceIndex: pos,
          value: token
        });
      }

      pos = next;
    }
  }

  for (pos = stack.length - 1; pos; pos -= 1) {
    stack[pos].unclosed = true;
  }

  return stack[0].nodes;
};

var walk$1 = function walk(nodes, cb, bubble) {
  var i, max, node, result;

  for (i = 0, max = nodes.length; i < max; i += 1) {
    node = nodes[i];
    if (!bubble) {
      result = cb(node, i, nodes);
    }

    if (
      result !== false &&
      node.type === "function" &&
      Array.isArray(node.nodes)
    ) {
      walk(node.nodes, cb, bubble);
    }

    if (bubble) {
      cb(node, i, nodes);
    }
  }
};

function stringifyNode(node, custom) {
  var type = node.type;
  var value = node.value;
  var buf;
  var customResult;

  if (custom && (customResult = custom(node)) !== undefined) {
    return customResult;
  } else if (type === "word" || type === "space") {
    return value;
  } else if (type === "string") {
    buf = node.quote || "";
    return buf + value + (node.unclosed ? "" : buf);
  } else if (type === "comment") {
    return "/*" + value + (node.unclosed ? "" : "*/");
  } else if (type === "div") {
    return (node.before || "") + value + (node.after || "");
  } else if (Array.isArray(node.nodes)) {
    buf = stringify$2(node.nodes);
    if (type !== "function") {
      return buf;
    }
    return (
      value +
      "(" +
      (node.before || "") +
      buf +
      (node.after || "") +
      (node.unclosed ? "" : ")")
    );
  }
  return value;
}

function stringify$2(nodes, custom) {
  var result, i;

  if (Array.isArray(nodes)) {
    result = "";
    for (i = nodes.length - 1; ~i; i -= 1) {
      result = stringifyNode(nodes[i], custom) + result;
    }
    return result;
  }
  return stringifyNode(nodes, custom);
}

var stringify_1 = stringify$2;

var minus = "-".charCodeAt(0);
var plus = "+".charCodeAt(0);
var dot = ".".charCodeAt(0);
var exp = "e".charCodeAt(0);
var EXP = "E".charCodeAt(0);

var unit = function(value) {
  var pos = 0;
  var length = value.length;
  var dotted = false;
  var sciPos = -1;
  var containsNumber = false;
  var code;

  while (pos < length) {
    code = value.charCodeAt(pos);

    if (code >= 48 && code <= 57) {
      containsNumber = true;
    } else if (code === exp || code === EXP) {
      if (sciPos > -1) {
        break;
      }
      sciPos = pos;
    } else if (code === dot) {
      if (dotted) {
        break;
      }
      dotted = true;
    } else if (code === plus || code === minus) {
      if (pos !== 0) {
        break;
      }
    } else {
      break;
    }

    pos += 1;
  }

  if (sciPos + 1 === pos) pos--;

  return containsNumber
    ? {
        number: value.slice(0, pos),
        unit: value.slice(pos)
      }
    : false;
};

var parse$2 = parse$3;
var walk = walk$1;
var stringify$1 = stringify_1;

function ValueParser(value) {
  if (this instanceof ValueParser) {
    this.nodes = parse$2(value);
    return this;
  }
  return new ValueParser(value);
}

ValueParser.prototype.toString = function() {
  return Array.isArray(this.nodes) ? stringify$1(this.nodes) : "";
};

ValueParser.prototype.walk = function(cb, bubble) {
  walk(this.nodes, cb, bubble);
  return this;
};

ValueParser.unit = unit;

ValueParser.walk = walk;

ValueParser.stringify = stringify$1;

var lib = ValueParser;

var valueParser = lib;

/* with love from shopstory */
/* parser generated by jison 0.6.1-215 */

/*
 * Returns a Parser object of the following structure:
 *
 *  Parser: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a derivative/copy of this one,
 *               not a direct reference!
 *  }
 *
 *  Parser.prototype: {
 *    yy: {},
 *    EOF: 1,
 *    TERROR: 2,
 *
 *    trace: function(errorMessage, ...),
 *
 *    JisonParserError: function(msg, hash),
 *
 *    quoteName: function(name),
 *               Helper function which can be overridden by user code later on: put suitable
 *               quotes around literal IDs in a description string.
 *
 *    originalQuoteName: function(name),
 *               The basic quoteName handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function
 *               at the end of the `parse()`.
 *
 *    describeSymbol: function(symbol),
 *               Return a more-or-less human-readable description of the given symbol, when
 *               available, or the symbol itself, serving as its own 'description' for lack
 *               of something better to serve up.
 *
 *               Return NULL when the symbol is unknown to the parser.
 *
 *    symbols_: {associative list: name ==> number},
 *    terminals_: {associative list: number ==> name},
 *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},
 *    terminal_descriptions_: (if there are any) {associative list: number ==> description},
 *    productions_: [...],
 *
 *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)
 *                             to store/reference the rule value `$$` and location info `@$`.
 *
 *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets
 *                 to see the same object via the `this` reference, i.e. if you wish to carry custom
 *                 data from one reduce action through to the next within a single parse run, then you
 *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.
 *
 *                 `this.yy` is a direct reference to the `yy` shared state object.
 *
 *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`
 *                 object at `parse()` start and are therefore available to the action code via the
 *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from
 *                 the %parse-param` list.
 *
 *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used
 *                             to match this rule. This is *not* the look-ahead token, but the last token
 *                             that's actually part of this rule.
 *
 *                 Formulated another way, `yytext` is the value of the token immediately preceeding
 *                 the current look-ahead token.
 *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.
 *
 *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.
 *
 *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.
 *
 *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.
 *
 *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead
 *                               of an empty object when no suitable location info can be provided.
 *
 *               - `yystate` : the current parser state number, used internally for dispatching and
 *                               executing the action code chunk matching the rule currently being reduced.
 *
 *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *                 Also note that you can access this and other stack index values using the new double-hash
 *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things
 *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.
 *                 This is made available to write very advanced grammar action rules, e.g. when you want
 *                 to investigate the parse state stack in your action code, which would, for example,
 *                 be relevant when you wish to implement error diagnostics and reporting schemes similar
 *                 to the work described here:
 *
 *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.
 *                   In Journées Francophones des Languages Applicatifs.
 *
 *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.
 *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.
 *
 *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.
 *                             constructs.
 *
 *               - `yylstack`: reference to the parser token location stack. Also accessed via
 *                             the `@1` etc. constructs.
 *
 *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are
 *                             UNDEFINED rather than an empty (location) object, when the lexer/parser
 *                             action code did not provide a suitable location info object when such a
 *                             slot was filled!
 *
 *               - `yystack` : reference to the parser token id stack. Also accessed via the
 *                             `#1` etc. constructs.
 *
 *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to
 *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might
 *                 want access this array for your own purposes, such as error analysis as mentioned above!
 *
 *                 Note that this stack stores the current stack of *tokens*, that is the sequence of
 *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*
 *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and
 *                 *reduced*.
 *
 *               - `yysstack`: reference to the parser state stack. This one carries the internal parser
 *                             *states* such as the one in `yystate`, which are used to represent
 *                             the parser state machine in the *parse table*. *Very* *internal* stuff,
 *                             what can I say? If you access this one, you're clearly doing wicked things
 *
 *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your
 *                             grammar definition file.
 *
 *    table: [...],
 *               State transition table
 *               ----------------------
 *
 *               index levels are:
 *               - `state`  --> hash table
 *               - `symbol` --> action (number or array)
 *
 *                 If the `action` is an array, these are the elements' meaning:
 *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept
 *                 - index [1]: GOTO `state`
 *
 *                 If the `action` is a number, it is the GOTO `state`
 *
 *    defaultActions: {...},
 *
 *    parseError: function(str, hash, ExceptionClass),
 *    yyError: function(str, ...),
 *    yyRecovering: function(),
 *    yyErrOk: function(),
 *    yyClearIn: function(),
 *
 *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this parser kernel in many places; example usage:
 *
 *                   var infoObj = parser.constructParseErrorInfo('fail!', null,
 *                                     parser.collect_expected_token_set(state), true);
 *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);
 *
 *    originalParseError: function(str, hash, ExceptionClass),
 *               The basic `parseError` handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function
 *               at the end of the `parse()`.
 *
 *    options: { ... parser %options ... },
 *
 *    parse: function(input[, args...]),
 *               Parse the given `input` and return the parsed value (or `true` when none was provided by
 *               the root action, in which case the parser is acting as a *matcher*).
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the jison run-time;
 *               when such a collision is detected an exception is thrown to prevent the generated run-time
 *               from silently accepting this confusing and potentially hazardous situation!
 *
 *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in
 *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state
 *               object and any collision with those will be reported by the lexer via a thrown exception.
 *
 *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown
 *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY
 *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and
 *               the internal parser gets properly garbage collected under these particular circumstances.
 *
 *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API can be invoked to calculate a spanning `yylloc` location info object.
 *
 *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case
 *               this function will attempt to obtain a suitable location marker by inspecting the location stack
 *               backwards.
 *
 *               For more info see the documentation comment further below, immediately above this function's
 *               implementation.
 *
 *    lexer: {
 *        yy: {...},           A reference to the so-called "shared state" `yy` once
 *                             received via a call to the `.setInput(input, yy)` lexer API.
 *        EOF: 1,
 *        ERROR: 2,
 *        JisonLexerError: function(msg, hash),
 *        parseError: function(str, hash, ExceptionClass),
 *        setInput: function(input, [yy]),
 *        input: function(),
 *        unput: function(str),
 *        more: function(),
 *        reject: function(),
 *        less: function(n),
 *        pastInput: function(n),
 *        upcomingInput: function(n),
 *        showPosition: function(),
 *        test_match: function(regex_match_array, rule_index, ...),
 *        next: function(...),
 *        lex: function(...),
 *        begin: function(condition),
 *        pushState: function(condition),
 *        popState: function(),
 *        topState: function(),
 *        _currentRules: function(),
 *        stateStackSize: function(),
 *        cleanupAfterLex: function()
 *
 *        options: { ... lexer %options ... },
 *
 *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),
 *        rules: [...],
 *        conditions: {associative list: name ==> set},
 *    }
 *  }
 *
 *
 *  token location info (@$, _$, etc.): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer and
 * parser errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *  }
 *
 * parser (grammar) errors will also provide these additional members:
 *
 *  {
 *    expected:    (array describing the set of expected tokens;
 *                  may be UNDEFINED when we cannot easily produce such a set)
 *    state:       (integer (or array when the table includes grammar collisions);
 *                  represents the current internal state of the parser kernel.
 *                  can, for example, be used to pass to the `collect_expected_token_set()`
 *                  API to obtain the expected token set)
 *    action:      (integer; represents the current internal action which will be executed)
 *    new_state:   (integer; represents the next/planned internal state, once the current
 *                  action has executed)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *    parser:      (reference to the current parser instance)
 *  }
 *
 * while `this` will reference the current parser instance.
 *
 * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    lexer:       (reference to the current lexer instance which reported the error)
 *  }
 *
 * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired
 * from either the parser or lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    exception:   (reference to the exception thrown)
 *  }
 *
 * Please do note that in the latter situation, the `expected` field will be omitted as
 * this type of failure is assumed not to be due to *parse errors* but rather due to user
 * action code in either parser or lexer failing unexpectedly.
 *
 * ---
 *
 * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.
 * These options are available:
 *
 * ### options which are global for all parser instances
 *
 *  Parser.pre_parse: function(yy)
 *                 optional: you can specify a pre_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`.
 *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: you can specify a post_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`. When it does not return any value,
 *                 the parser will return the original `retval`.
 *
 * ### options which can be set up per parser instance
 *
 *  yy: {
 *      pre_parse:  function(yy)
 *                 optional: is invoked before the parse cycle starts (and before the first
 *                 invocation of `lex()`) but immediately after the invocation of
 *                 `parser.pre_parse()`).
 *      post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: is invoked when the parse terminates due to success ('accept')
 *                 or failure (even when exceptions are thrown).
 *                 `retval` contains the return value to be produced by `Parser.parse()`;
 *                 this function can override the return value by returning another.
 *                 When it does not return any value, the parser will return the original
 *                 `retval`.
 *                 This function is invoked immediately before `parser.post_parse()`.
 *
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *      quoteName: function(name),
 *                 optional: overrides the default `quoteName` function.
 *  }
 *
 *  parser.lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */

/** @type {Parser} */
var parser = function () {
  // See also:
  // http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
  // but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
  // with userland code which might access the derived class in a 'classic' way.
  function JisonParserError(msg, hash) {
    Object.defineProperty(this, "name", {
      enumerable: false,
      writable: false,
      value: "JisonParserError"
    });
    if (msg == null) msg = "???";
    Object.defineProperty(this, "message", {
      enumerable: false,
      writable: true,
      value: msg
    });
    this.hash = hash;
    var stacktrace;
    if (hash && hash.exception instanceof Error) {
      var ex2 = hash.exception;
      this.message = ex2.message || msg;
      stacktrace = ex2.stack;
    }
    if (!stacktrace) {
      if (Error.hasOwnProperty("captureStackTrace")) {
        // V8/Chrome engine
        Error.captureStackTrace(this, this.constructor);
      } else {
        stacktrace = new Error(msg).stack;
      }
    }
    if (stacktrace) {
      Object.defineProperty(this, "stack", {
        enumerable: false,
        writable: false,
        value: stacktrace
      });
    }
  }
  if (typeof Object.setPrototypeOf === "function") {
    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);
  } else {
    JisonParserError.prototype = Object.create(Error.prototype);
  }
  JisonParserError.prototype.constructor = JisonParserError;
  JisonParserError.prototype.name = "JisonParserError";

  // helper: reconstruct the productions[] table
  function bp(s) {
    var rv = [];
    var p = s.pop;
    var r = s.rule;
    for (var i = 0, l = p.length; i < l; i++) {
      rv.push([p[i], r[i]]);
    }
    return rv;
  }

  // helper: reconstruct the defaultActions[] table
  function bda(s) {
    var rv = {};
    var d = s.idx;
    var g = s.goto;
    for (var i = 0, l = d.length; i < l; i++) {
      var j = d[i];
      rv[j] = g[i];
    }
    return rv;
  }

  // helper: reconstruct the 'goto' table
  function bt(s) {
    var rv = [];
    var d = s.len;
    var y = s.symbol;
    var t = s.type;
    var a = s.state;
    var m = s.mode;
    var g = s.goto;
    for (var i = 0, l = d.length; i < l; i++) {
      var n = d[i];
      var q = {};
      for (var j = 0; j < n; j++) {
        var z = y.shift();
        switch (t.shift()) {
          case 2:
            q[z] = [m.shift(), g.shift()];
            break;
          case 0:
            q[z] = a.shift();
            break;
          default:
            // type === 1: accept
            q[z] = [3];
        }
      }
      rv.push(q);
    }
    return rv;
  }

  // helper: runlength encoding with increment step: code, length: step (default step = 0)
  // `this` references an array
  function s(c, l, a) {
    a = a || 0;
    for (var i = 0; i < l; i++) {
      this.push(c);
      c += a;
    }
  }

  // helper: duplicate sequence from *relative* offset and length.
  // `this` references an array
  function c(i, l) {
    i = this.length - i;
    for (l += i; i < l; i++) {
      this.push(this[i]);
    }
  }

  // helper: unpack an array using helpers and data, all passed in an array argument 'a'.
  function u(a) {
    var rv = [];
    for (var i = 0, l = a.length; i < l; i++) {
      var e = a[i];
      // Is this entry a helper function?
      if (typeof e === "function") {
        i++;
        e.apply(rv, a[i]);
      } else {
        rv.push(e);
      }
    }
    return rv;
  }
  var parser = {
    // Code Generator Information Report
    // ---------------------------------
    //
    // Options:
    //
    //   default action mode: ............. ["classic","merge"]
    //   test-compile action mode: ........ "parser:*,lexer:*"
    //   try..catch: ...................... true
    //   default resolve on conflict: ..... true
    //   on-demand look-ahead: ............ false
    //   error recovery token skip maximum: 3
    //   yyerror in parse actions is: ..... NOT recoverable,
    //   yyerror in lexer actions and other non-fatal lexer are:
    //   .................................. NOT recoverable,
    //   debug grammar/output: ............ false
    //   has partial LR conflict upgrade:   true
    //   rudimentary token-stack support:   false
    //   parser table compression mode: ... 2
    //   export debug tables: ............. false
    //   export *all* tables: ............. false
    //   module type: ..................... commonjs
    //   parser engine type: .............. lalr
    //   output main() in the module: ..... true
    //   has user-specified main(): ....... false
    //   has user-specified require()/import modules for main():
    //   .................................. false
    //   number of expected conflicts: .... 0
    //
    //
    // Parser Analysis flags:
    //
    //   no significant actions (parser is a language matcher only):
    //   .................................. false
    //   uses yyleng: ..................... false
    //   uses yylineno: ................... false
    //   uses yytext: ..................... false
    //   uses yylloc: ..................... false
    //   uses ParseError API: ............. false
    //   uses YYERROR: .................... false
    //   uses YYRECOVERING: ............... false
    //   uses YYERROK: .................... false
    //   uses YYCLEARIN: .................. false
    //   tracks rule values: .............. true
    //   assigns rule values: ............. true
    //   uses location tracking: .......... false
    //   assigns location: ................ false
    //   uses yystack: .................... false
    //   uses yysstack: ................... false
    //   uses yysp: ....................... true
    //   uses yyrulelength: ............... false
    //   uses yyMergeLocationInfo API: .... false
    //   has error recovery: .............. false
    //   has error reporting: ............. false
    //
    // --------- END OF REPORT -----------

    trace: function no_op_trace() {},
    JisonParserError: JisonParserError,
    yy: {},
    options: {
      type: "lalr",
      hasPartialLrUpgradeOnConflict: true,
      errorRecoveryTokenDiscardCount: 3
    },
    symbols_: {
      $accept: 0,
      $end: 1,
      ADD: 3,
      ANGLE: 18,
      CHS: 24,
      COMMA: 11,
      CSS_CPROP: 16,
      CSS_VAR: 15,
      DIV: 6,
      EMS: 22,
      EOF: 1,
      EXS: 23,
      FREQ: 20,
      LENGTH: 17,
      LPAREN: 7,
      MAX: 10,
      MIN: 12,
      MUL: 5,
      NESTED_CALC: 9,
      NUMBER: 14,
      PERCENTAGE: 30,
      PREFIX: 13,
      REMS: 25,
      RES: 21,
      RPAREN: 8,
      SUB: 4,
      TIME: 19,
      VHS: 26,
      VMAXS: 29,
      VMINS: 28,
      VWS: 27,
      css_value: 35,
      css_variable: 34,
      error: 2,
      expression: 31,
      math_expression: 32,
      value: 33
    },
    terminals_: {
      1: "EOF",
      2: "error",
      3: "ADD",
      4: "SUB",
      5: "MUL",
      6: "DIV",
      7: "LPAREN",
      8: "RPAREN",
      9: "NESTED_CALC",
      10: "MAX",
      11: "COMMA",
      12: "MIN",
      13: "PREFIX",
      14: "NUMBER",
      15: "CSS_VAR",
      16: "CSS_CPROP",
      17: "LENGTH",
      18: "ANGLE",
      19: "TIME",
      20: "FREQ",
      21: "RES",
      22: "EMS",
      23: "EXS",
      24: "CHS",
      25: "REMS",
      26: "VHS",
      27: "VWS",
      28: "VMINS",
      29: "VMAXS",
      30: "PERCENTAGE"
    },
    TERROR: 2,
    EOF: 1,
    // internals: defined here so the object *structure* doesn't get modified by parse() et al,
    // thus helping JIT compilers like Chrome V8.
    originalQuoteName: null,
    originalParseError: null,
    cleanupAfterParse: null,
    constructParseErrorInfo: null,
    yyMergeLocationInfo: null,
    __reentrant_call_depth: 0,
    // INTERNAL USE ONLY
    __error_infos: [],
    // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
    __error_recovery_infos: [],
    // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup

    // APIs which will be set up depending on user action code analysis:
    //yyRecovering: 0,
    //yyErrOk: 0,
    //yyClearIn: 0,

    // Helper APIs
    // -----------

    // Helper function which can be overridden by user code later on: put suitable quotes around
    // literal IDs in a description string.
    quoteName: function parser_quoteName(id_str) {
      return '"' + id_str + '"';
    },
    // Return the name of the given symbol (terminal or non-terminal) as a string, when available.
    //
    // Return NULL when the symbol is unknown to the parser.
    getSymbolName: function parser_getSymbolName(symbol) {
      if (this.terminals_[symbol]) {
        return this.terminals_[symbol];
      }

      // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.
      //
      // An example of this may be where a rule's action code contains a call like this:
      //
      //      parser.getSymbolName(#$)
      //
      // to obtain a human-readable name of the current grammar rule.
      var s = this.symbols_;
      for (var key in s) {
        if (s[key] === symbol) {
          return key;
        }
      }
      return null;
    },
    // Return a more-or-less human-readable description of the given symbol, when available,
    // or the symbol itself, serving as its own 'description' for lack of something better to serve up.
    //
    // Return NULL when the symbol is unknown to the parser.
    describeSymbol: function parser_describeSymbol(symbol) {
      if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
        return this.terminal_descriptions_[symbol];
      } else if (symbol === this.EOF) {
        return "end of input";
      }
      var id = this.getSymbolName(symbol);
      if (id) {
        return this.quoteName(id);
      }
      return null;
    },
    // Produce a (more or less) human-readable list of expected tokens at the point of failure.
    //
    // The produced list may contain token or token set descriptions instead of the tokens
    // themselves to help turning this output into something that easier to read by humans
    // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
    // expected terminals and nonterminals is produced.
    //
    // The returned list (array) will not contain any duplicate entries.
    collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
      var TERROR = this.TERROR;
      var tokenset = [];
      var check = {};
      // Has this (error?) state been outfitted with a custom expectations description text for human consumption?
      // If so, use that one instead of the less palatable token set.
      if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
        return [this.state_descriptions_[state]];
      }
      for (var p in this.table[state]) {
        p = +p;
        if (p !== TERROR) {
          var d = do_not_describe ? p : this.describeSymbol(p);
          if (d && !check[d]) {
            tokenset.push(d);
            check[d] = true; // Mark this token description as already mentioned to prevent outputting duplicate entries.
          }
        }
      }
      return tokenset;
    },
    productions_: bp({
      pop: u([31, s, [32, 12], 33, 33, 34, 34, s, [35, 15]]),
      rule: u([2, s, [3, 5], 4, 6, 6, 7, s, [1, 4], 2, 4, 6, s, [1, 14], 2])
    }),
    performAction: function parser__PerformAction(yystate /* action[1] */, yysp, yyvstack) {
      /* this == yyval */

      // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!
      var yy = this.yy;
      yy.parser;
      yy.lexer;
      switch (yystate) {
        case 0:
          /*! Production::    $accept : expression $end */

          // default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,-,-,-,-):
          this.$ = yyvstack[yysp - 1];
          // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,-,-,-,-)
          break;
        case 1:
          /*! Production::    expression : math_expression EOF */

          // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,-,-,-,-):
          this.$ = yyvstack[yysp - 1];
          // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,-,-,-,-)

          return yyvstack[yysp - 1];
        case 2:
        /*! Production::    math_expression : math_expression ADD math_expression */
        case 3:
        /*! Production::    math_expression : math_expression SUB math_expression */
        case 4:
        /*! Production::    math_expression : math_expression MUL math_expression */
        case 5:
          /*! Production::    math_expression : math_expression DIV math_expression */

          this.$ = {
            type: "MathExpression",
            operator: yyvstack[yysp - 1],
            left: yyvstack[yysp - 2],
            right: yyvstack[yysp]
          };
          break;
        case 6:
          /*! Production::    math_expression : LPAREN math_expression RPAREN */

          this.$ = yyvstack[yysp - 1];
          break;
        case 7:
          /*! Production::    math_expression : NESTED_CALC LPAREN math_expression RPAREN */

          this.$ = {
            type: "Calc",
            value: yyvstack[yysp - 1]
          };
          break;
        case 8:
          /*! Production::    math_expression : MAX LPAREN math_expression COMMA math_expression RPAREN */

          this.$ = {
            type: "MathExpression",
            operator: "max",
            left: yyvstack[yysp - 3],
            right: yyvstack[yysp - 1]
          };
          break;
        case 9:
          /*! Production::    math_expression : MIN LPAREN math_expression COMMA math_expression RPAREN */

          this.$ = {
            type: "MathExpression",
            operator: "min",
            left: yyvstack[yysp - 3],
            right: yyvstack[yysp - 1]
          };
          break;
        case 10:
          /*! Production::    math_expression : SUB PREFIX SUB NESTED_CALC LPAREN math_expression RPAREN */

          this.$ = {
            type: "Calc",
            value: yyvstack[yysp - 1],
            prefix: yyvstack[yysp - 5]
          };
          break;
        case 11:
        /*! Production::    math_expression : css_variable */
        case 12:
        /*! Production::    math_expression : css_value */
        case 13:
          /*! Production::    math_expression : value */

          this.$ = yyvstack[yysp];
          break;
        case 14:
          /*! Production::    value : NUMBER */

          this.$ = {
            type: "Value",
            value: parseFloat(yyvstack[yysp])
          };
          break;
        case 15:
          /*! Production::    value : SUB NUMBER */

          this.$ = {
            type: "Value",
            value: parseFloat(yyvstack[yysp]) * -1
          };
          break;
        case 16:
          /*! Production::    css_variable : CSS_VAR LPAREN CSS_CPROP RPAREN */

          this.$ = {
            type: "CssVariable",
            value: yyvstack[yysp - 1]
          };
          break;
        case 17:
          /*! Production::    css_variable : CSS_VAR LPAREN CSS_CPROP COMMA math_expression RPAREN */

          this.$ = {
            type: "CssVariable",
            value: yyvstack[yysp - 3],
            fallback: yyvstack[yysp - 1]
          };
          break;
        case 18:
          /*! Production::    css_value : LENGTH */

          this.$ = {
            type: "LengthValue",
            value: parseFloat(yyvstack[yysp]),
            unit: /[a-z]+/.exec(yyvstack[yysp])[0]
          };
          break;
        case 19:
          /*! Production::    css_value : ANGLE */

          this.$ = {
            type: "AngleValue",
            value: parseFloat(yyvstack[yysp]),
            unit: /[a-z]+/.exec(yyvstack[yysp])[0]
          };
          break;
        case 20:
          /*! Production::    css_value : TIME */

          this.$ = {
            type: "TimeValue",
            value: parseFloat(yyvstack[yysp]),
            unit: /[a-z]+/.exec(yyvstack[yysp])[0]
          };
          break;
        case 21:
          /*! Production::    css_value : FREQ */

          this.$ = {
            type: "FrequencyValue",
            value: parseFloat(yyvstack[yysp]),
            unit: /[a-z]+/.exec(yyvstack[yysp])[0]
          };
          break;
        case 22:
          /*! Production::    css_value : RES */

          this.$ = {
            type: "ResolutionValue",
            value: parseFloat(yyvstack[yysp]),
            unit: /[a-z]+/.exec(yyvstack[yysp])[0]
          };
          break;
        case 23:
          /*! Production::    css_value : EMS */

          this.$ = {
            type: "EmValue",
            value: parseFloat(yyvstack[yysp]),
            unit: "em"
          };
          break;
        case 24:
          /*! Production::    css_value : EXS */

          this.$ = {
            type: "ExValue",
            value: parseFloat(yyvstack[yysp]),
            unit: "ex"
          };
          break;
        case 25:
          /*! Production::    css_value : CHS */

          this.$ = {
            type: "ChValue",
            value: parseFloat(yyvstack[yysp]),
            unit: "ch"
          };
          break;
        case 26:
          /*! Production::    css_value : REMS */

          this.$ = {
            type: "RemValue",
            value: parseFloat(yyvstack[yysp]),
            unit: "rem"
          };
          break;
        case 27:
          /*! Production::    css_value : VHS */

          this.$ = {
            type: "VhValue",
            value: parseFloat(yyvstack[yysp]),
            unit: "vh"
          };
          break;
        case 28:
          /*! Production::    css_value : VWS */

          this.$ = {
            type: "VwValue",
            value: parseFloat(yyvstack[yysp]),
            unit: "vw"
          };
          break;
        case 29:
          /*! Production::    css_value : VMINS */

          this.$ = {
            type: "VminValue",
            value: parseFloat(yyvstack[yysp]),
            unit: "vmin"
          };
          break;
        case 30:
          /*! Production::    css_value : VMAXS */

          this.$ = {
            type: "VmaxValue",
            value: parseFloat(yyvstack[yysp]),
            unit: "vmax"
          };
          break;
        case 31:
          /*! Production::    css_value : PERCENTAGE */

          this.$ = {
            type: "PercentageValue",
            value: parseFloat(yyvstack[yysp]),
            unit: "%"
          };
          break;
        case 32:
          /*! Production::    css_value : SUB css_value */

          var prev = yyvstack[yysp];
          prev.value *= -1;
          this.$ = prev;
          break;
      }
    },
    table: bt({
      len: u([26, 1, 5, 25, s, [1, 3], 18, s, [0, 3], 1, s, [0, 16], s, [25, 4], 5, s, [25, 3], c, [25, 3], 16, 1, 7, 7, s, [0, 3], s, [5, 3], 1, 2, c, [24, 3], 1, 0, 25, 5, 5, 25, 5, c, [17, 3], 0, 0]),
      symbol: u([4, 7, 9, 10, 12, 14, 15, s, [17, 19, 1], 1, 1, s, [3, 4, 1], c, [32, 21], c, [31, 4], s, [7, 3], 4, 13, 14, c, [24, 14], 35, 7, c, [47, 25], c, [25, 75], c, [151, 4], 8, c, [105, 76], 4, c, [198, 15], 16, c, [250, 5], 8, 11, c, [7, 7], c, [6, 5], c, [5, 4], c, [10, 5], 11, 9, 8, 11, c, [100, 50], c, [281, 26], c, [94, 9], c, [211, 26], c, [35, 10]]),
      type: u([s, [2, 21], s, [0, 5], 1, s, [2, 26], s, [0, 4], c, [24, 21], c, [47, 46], c, [25, 76], c, [80, 75], c, [97, 27], s, [2, 28], c, [180, 51], c, [206, 30], c, [35, 19]]),
      state: u([1, 2, 10, 8, 9, 32, c, [4, 3], 37, 41, c, [5, 3], 42, c, [4, 3], 43, c, [4, 3], 44, c, [4, 3], 46, c, [4, 3], 47, c, [4, 3], 48, c, [29, 4], 57, c, [5, 3], 58, c, [4, 3], 60, c, [4, 3], 63, c, [4, 3]]),
      mode: u([s, [1, 237], s, [2, 3], c, [5, 5], c, [7, 6], s, [1, 123]]),
      goto: u([7, s, [3, 4, 1], 26, s, [11, 15, 1], s, [27, 5, 1], c, [26, 21], 33, 34, 35, 39, 36, 38, c, [20, 14], 40, c, [42, 21], c, [21, 63], c, [130, 4], 45, c, [68, 63], 49, 39, c, [16, 14], 50, s, [2, 3], 30, 31, 2, 2, s, [3, 3], 30, 31, 3, 3, c, [99, 4], 51, c, [5, 4], 52, c, [5, 4], s, [53, 4, 1], c, [91, 42], 59, c, [181, 25], 61, c, [5, 4], 62, c, [31, 25], 64, c, [5, 4], 65])
    }),
    defaultActions: bda({
      idx: u([8, 9, 10, s, [12, 16, 1], 37, 38, 43, 44, 45, 51, 55, 61, 62, 64, 65]),
      goto: u([11, 12, 13, s, [18, 14, 1], 14, 1, 32, 15, s, [4, 4, 1], 16, 8, 9, 17, 10])
    }),
    parseError: function parseError(str, hash, ExceptionClass) {
      if (hash.recoverable) {
        if (typeof this.trace === "function") {
          this.trace(str);
        }
        hash.destroy(); // destroy... well, *almost*!
      } else {
        if (typeof this.trace === "function") {
          this.trace(str);
        }
        if (!ExceptionClass) {
          ExceptionClass = this.JisonParserError;
        }
        throw new ExceptionClass(str, hash);
      }
    },
    parse: function parse(input) {
      var self = this;
      var stack = new Array(128); // token stack: stores token which leads to state at the same index (column storage)
      var sstack = new Array(128); // state stack: stores states (column storage)

      var vstack = new Array(128); // semantic value stack

      var table = this.table;
      var sp = 0; // 'stack pointer': index into the stacks

      var symbol = 0;
      this.TERROR;
      var EOF = this.EOF;
      this.options.errorRecoveryTokenDiscardCount | 0 || 3;
      var NO_ACTION = [0, 66 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];
      var lexer;
      if (this.__lexer__) {
        lexer = this.__lexer__;
      } else {
        lexer = this.__lexer__ = Object.create(this.lexer);
      }
      var sharedState_yy = {
        parseError: undefined,
        quoteName: undefined,
        lexer: undefined,
        parser: undefined,
        pre_parse: undefined,
        post_parse: undefined,
        pre_lex: undefined,
        post_lex: undefined // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!
      };
      if (typeof assert !== "function") ; else {
        assert;
      }
      this.yyGetSharedState = function yyGetSharedState() {
        return sharedState_yy;
      };
      function shallow_copy_noclobber(dst, src) {
        for (var k in src) {
          if (typeof dst[k] === "undefined" && Object.prototype.hasOwnProperty.call(src, k)) {
            dst[k] = src[k];
          }
        }
      }

      // copy state
      shallow_copy_noclobber(sharedState_yy, this.yy);
      sharedState_yy.lexer = lexer;
      sharedState_yy.parser = this;

      // Does the shared state override the default `parseError` that already comes with this instance?
      if (typeof sharedState_yy.parseError === "function") {
        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {
          if (!ExceptionClass) {
            ExceptionClass = this.JisonParserError;
          }
          return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);
        };
      } else {
        this.parseError = this.originalParseError;
      }

      // Does the shared state override the default `quoteName` that already comes with this instance?
      if (typeof sharedState_yy.quoteName === "function") {
        this.quoteName = function quoteNameAlt(id_str) {
          return sharedState_yy.quoteName.call(this, id_str);
        };
      } else {
        this.quoteName = this.originalQuoteName;
      }

      // set up the cleanup function; make it an API so that external code can re-use this one in case of
      // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which
      // case this parse() API method doesn't come with a `finally { ... }` block any more!
      //
      // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
      //       or else your `sharedState`, etc. references will be *wrong*!
      this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
        var rv;
        if (invoke_post_methods) {
          var hash;
          if (sharedState_yy.post_parse || this.post_parse) {
            // create an error hash info instance: we re-use this API in a **non-error situation**
            // as this one delivers all parser internals ready for access by userland code.
            hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);
          }
          if (sharedState_yy.post_parse) {
            rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);
            if (typeof rv !== "undefined") resultValue = rv;
          }
          if (this.post_parse) {
            rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);
            if (typeof rv !== "undefined") resultValue = rv;
          }

          // cleanup:
          if (hash && hash.destroy) {
            hash.destroy();
          }
        }
        if (this.__reentrant_call_depth > 1) return resultValue; // do not (yet) kill the sharedState when this is a reentrant run.

        // clean up the lingering lexer structures as well:
        if (lexer.cleanupAfterLex) {
          lexer.cleanupAfterLex(do_not_nuke_errorinfos);
        }

        // prevent lingering circular references from causing memory leaks:
        if (sharedState_yy) {
          sharedState_yy.lexer = undefined;
          sharedState_yy.parser = undefined;
          if (lexer.yy === sharedState_yy) {
            lexer.yy = undefined;
          }
        }
        sharedState_yy = undefined;
        this.parseError = this.originalParseError;
        this.quoteName = this.originalQuoteName;

        // nuke the vstack[] array at least as that one will still reference obsoleted user values.
        // To be safe, we nuke the other internal stack columns as well...
        stack.length = 0; // fastest way to nuke an array without overly bothering the GC
        sstack.length = 0;
        vstack.length = 0;
        sp = 0;

        // nuke the error hash info instances created during this run.
        // Userland code must COPY any data/references
        // in the error hash instance(s) it is more permanently interested in.
        if (!do_not_nuke_errorinfos) {
          for (var i = this.__error_infos.length - 1; i >= 0; i--) {
            var el = this.__error_infos[i];
            if (el && typeof el.destroy === "function") {
              el.destroy();
            }
          }
          this.__error_infos.length = 0;
        }
        return resultValue;
      };

      // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
      //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!
      this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {
        var pei = {
          errStr: msg,
          exception: ex,
          text: lexer.match,
          value: lexer.yytext,
          token: this.describeSymbol(symbol) || symbol,
          token_id: symbol,
          line: lexer.yylineno,
          expected: expected,
          recoverable: recoverable,
          state: state,
          action: action,
          new_state: newState,
          symbol_stack: stack,
          state_stack: sstack,
          value_stack: vstack,
          stack_pointer: sp,
          yy: sharedState_yy,
          lexer: lexer,
          parser: this,
          // and make sure the error info doesn't stay due to potential
          // ref cycle via userland code manipulations.
          // These would otherwise all be memory leak opportunities!
          //
          // Note that only array and object references are nuked as those
          // constitute the set of elements which can produce a cyclic ref.
          // The rest of the members is kept intact as they are harmless.
          destroy: function destructParseErrorInfo() {
            // remove cyclic references added to error info:
            // info.yy = null;
            // info.lexer = null;
            // info.value = null;
            // info.value_stack = null;
            // ...
            var rec = !!this.recoverable;
            for (var key in this) {
              if (this.hasOwnProperty(key) && typeof key === "object") {
                this[key] = undefined;
              }
            }
            this.recoverable = rec;
          }
        };
        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
        this.__error_infos.push(pei);
        return pei;
      };
      function stdLex() {
        var token = lexer.lex();
        // if token isn't its numeric value, convert
        if (typeof token !== "number") {
          token = self.symbols_[token] || token;
        }
        return token || EOF;
      }
      function fastLex() {
        var token = lexer.fastLex();
        // if token isn't its numeric value, convert
        if (typeof token !== "number") {
          token = self.symbols_[token] || token;
        }
        return token || EOF;
      }
      var lex = stdLex;
      var state, action, r, t;
      var yyval = {
        $: true,
        _$: undefined,
        yy: sharedState_yy
      };
      var p;
      var yyrulelen;
      var this_production;
      var newState;
      var retval = false;
      try {
        this.__reentrant_call_depth++;
        lexer.setInput(input, sharedState_yy);

        // NOTE: we *assume* no lexer pre/post handlers are set up *after*
        // this initial `setInput()` call: hence we can now check and decide
        // whether we'll go with the standard, slower, lex() API or the
        // `fast_lex()` one:
        if (typeof lexer.canIUse === "function") {
          var lexerInfo = lexer.canIUse();
          if (lexerInfo.fastLex && typeof fastLex === "function") {
            lex = fastLex;
          }
        }
        vstack[sp] = null;
        sstack[sp] = 0;
        stack[sp] = 0;
        ++sp;
        if (this.pre_parse) {
          this.pre_parse.call(this, sharedState_yy);
        }
        if (sharedState_yy.pre_parse) {
          sharedState_yy.pre_parse.call(this, sharedState_yy);
        }
        newState = sstack[sp - 1];
        for (;;) {
          // retrieve state number from top of stack
          state = newState; // sstack[sp - 1];

          // use default actions if available
          if (this.defaultActions[state]) {
            action = 2;
            newState = this.defaultActions[state];
          } else {
            // The single `==` condition below covers both these `===` comparisons in a single
            // operation:
            //
            //     if (symbol === null || typeof symbol === 'undefined') ...
            if (!symbol) {
              symbol = lex();
            }
            // read action for current state and first input
            t = table[state] && table[state][symbol] || NO_ACTION;
            newState = t[1];
            action = t[0];

            // handle parse error
            if (!action) {
              var errStr;
              var errSymbolDescr = this.describeSymbol(symbol) || symbol;
              var expected = this.collect_expected_token_set(state);

              // Report error
              if (typeof lexer.yylineno === "number") {
                errStr = "Parse error on line " + (lexer.yylineno + 1) + ": ";
              } else {
                errStr = "Parse error: ";
              }
              if (typeof lexer.showPosition === "function") {
                errStr += "\n" + lexer.showPosition(79 - 10, 10) + "\n";
              }
              if (expected.length) {
                errStr += "Expecting " + expected.join(", ") + ", got unexpected " + errSymbolDescr;
              } else {
                errStr += "Unexpected " + errSymbolDescr;
              }
              // we cannot recover from the error!
              p = this.constructParseErrorInfo(errStr, null, expected, false);
              r = this.parseError(p.errStr, p, this.JisonParserError);
              if (typeof r !== "undefined") {
                retval = r;
              }
              break;
            }
          }
          switch (action) {
            // catch misc. parse failures:
            default:
              // this shouldn't happen, unless resolve defaults are off
              if (action instanceof Array) {
                p = this.constructParseErrorInfo("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol, null, null, false);
                r = this.parseError(p.errStr, p, this.JisonParserError);
                if (typeof r !== "undefined") {
                  retval = r;
                }
                break;
              }
              // Another case of better safe than sorry: in case state transitions come out of another error recovery process
              // or a buggy LUT (LookUp Table):
              p = this.constructParseErrorInfo("Parsing halted. No viable error recovery approach available due to internal system failure.", null, null, false);
              r = this.parseError(p.errStr, p, this.JisonParserError);
              if (typeof r !== "undefined") {
                retval = r;
              }
              break;

            // shift:
            case 1:
              stack[sp] = symbol;
              vstack[sp] = lexer.yytext;
              sstack[sp] = newState; // push state

              ++sp;
              symbol = 0;

              // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:

              continue;

            // reduce:
            case 2:
              this_production = this.productions_[newState - 1]; // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
              yyrulelen = this_production[1];
              r = this.performAction.call(yyval, newState, sp - 1, vstack);
              if (typeof r !== "undefined") {
                retval = r;
                break;
              }

              // pop off stack
              sp -= yyrulelen;

              // don't overwrite the `symbol` variable: use a local var to speed things up:
              var ntsymbol = this_production[0]; // push nonterminal (reduce)
              stack[sp] = ntsymbol;
              vstack[sp] = yyval.$;

              // goto new state = table[STATE][NONTERMINAL]
              newState = table[sstack[sp - 1]][ntsymbol];
              sstack[sp] = newState;
              ++sp;
              continue;

            // accept:
            case 3:
              if (sp !== -2) {
                retval = true;
                // Return the `$accept` rule's `$$` result, if available.
                //
                // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                // default, action):
                //
                //     $accept: <startSymbol> $end
                //                  %{ $$ = $1; @$ = @1; %}
                //
                // which, combined with the parse kernel's `$accept` state behaviour coded below,
                // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                //
                // In code:
                //
                //                  %{
                //                      @$ = @1;            // if location tracking support is included
                //                      if (typeof $1 !== 'undefined')
                //                          return $1;
                //                      else
                //                          return true;           // the default parse result if the rule actions don't produce anything
                //                  %}
                sp--;
                if (typeof vstack[sp] !== "undefined") {
                  retval = vstack[sp];
                }
              }
              break;
          }

          // break out of loop: we accept or fail with error
          break;
        }
      } catch (ex) {
        // report exceptions through the parseError callback too, but keep the exception intact
        // if it is a known parser or lexer error which has been thrown by parseError() already:
        if (ex instanceof this.JisonParserError) {
          throw ex;
        } else if (lexer && typeof lexer.JisonLexerError === "function" && ex instanceof lexer.JisonLexerError) {
          throw ex;
        }
        p = this.constructParseErrorInfo("Parsing aborted due to exception.", ex, null, false);
        retval = false;
        r = this.parseError(p.errStr, p, this.JisonParserError);
        if (typeof r !== "undefined") {
          retval = r;
        }
      } finally {
        retval = this.cleanupAfterParse(retval, true, true);
        this.__reentrant_call_depth--;
      } // /finally

      return retval;
    }
  };
  parser.originalParseError = parser.parseError;
  parser.originalQuoteName = parser.quoteName;
  /* lexer generated by jison-lex 0.6.1-215 */

  /*
   * Returns a Lexer object of the following structure:
   *
   *  Lexer: {
   *    yy: {}     The so-called "shared state" or rather the *source* of it;
   *               the real "shared state" `yy` passed around to
   *               the rule actions, etc. is a direct reference!
   *
   *               This "shared context" object was passed to the lexer by way of
   *               the `lexer.setInput(str, yy)` API before you may use it.
   *
   *               This "shared context" object is passed to the lexer action code in `performAction()`
   *               so userland code in the lexer actions may communicate with the outside world
   *               and/or other lexer rules' actions in more or less complex ways.
   *
   *  }
   *
   *  Lexer.prototype: {
   *    EOF: 1,
   *    ERROR: 2,
   *
   *    yy:        The overall "shared context" object reference.
   *
   *    JisonLexerError: function(msg, hash),
   *
   *    performAction: function lexer__performAction(yy, yyrulenumber, YY_START),
   *
   *               The function parameters and `this` have the following value/meaning:
   *               - `this`    : reference to the `lexer` instance.
   *                               `yy_` is an alias for `this` lexer instance reference used internally.
   *
   *               - `yy`      : a reference to the `yy` "shared state" object which was passed to the lexer
   *                             by way of the `lexer.setInput(str, yy)` API before.
   *
   *                             Note:
   *                             The extra arguments you specified in the `%parse-param` statement in your
   *                             **parser** grammar definition file are passed to the lexer via this object
   *                             reference as member variables.
   *
   *               - `yyrulenumber`   : index of the matched lexer rule (regex), used internally.
   *
   *               - `YY_START`: the current lexer "start condition" state.
   *
   *    parseError: function(str, hash, ExceptionClass),
   *
   *    constructLexErrorInfo: function(error_message, is_recoverable),
   *               Helper function.
   *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
   *               See it's use in this lexer kernel in many places; example usage:
   *
   *                   var infoObj = lexer.constructParseErrorInfo('fail!', true);
   *                   var retVal = lexer.parseError(infoObj.errStr, infoObj, lexer.JisonLexerError);
   *
   *    options: { ... lexer %options ... },
   *
   *    lex: function(),
   *               Produce one token of lexed input, which was passed in earlier via the `lexer.setInput()` API.
   *               You MAY use the additional `args...` parameters as per `%parse-param` spec of the **lexer** grammar:
   *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
   *
   *               WARNING:
   *               Lexer's additional `args...` parameters (via lexer's `%parse-param`) MAY conflict with
   *               any attributes already added to `yy` by the **parser** or the jison run-time;
   *               when such a collision is detected an exception is thrown to prevent the generated run-time
   *               from silently accepting this confusing and potentially hazardous situation!
   *
   *    cleanupAfterLex: function(do_not_nuke_errorinfos),
   *               Helper function.
   *
   *               This helper API is invoked when the **parse process** has completed: it is the responsibility
   *               of the **parser** (or the calling userland code) to invoke this method once cleanup is desired.
   *
   *               This helper may be invoked by user code to ensure the internal lexer gets properly garbage collected.
   *
   *    setInput: function(input, [yy]),
   *
   *
   *    input: function(),
   *
   *
   *    unput: function(str),
   *
   *
   *    more: function(),
   *
   *
   *    reject: function(),
   *
   *
   *    less: function(n),
   *
   *
   *    pastInput: function(n),
   *
   *
   *    upcomingInput: function(n),
   *
   *
   *    showPosition: function(),
   *
   *
   *    test_match: function(regex_match_array, rule_index),
   *
   *
   *    next: function(),
   *
   *
   *    begin: function(condition),
   *
   *
   *    pushState: function(condition),
   *
   *
   *    popState: function(),
   *
   *
   *    topState: function(),
   *
   *
   *    _currentRules: function(),
   *
   *
   *    stateStackSize: function(),
   *
   *
   *    performAction: function(yy, yy_, yyrulenumber, YY_START),
   *
   *
   *    rules: [...],
   *
   *
   *    conditions: {associative list: name ==> set},
   *  }
   *
   *
   *  token location info (`yylloc`): {
   *    first_line: n,
   *    last_line: n,
   *    first_column: n,
   *    last_column: n,
   *    range: [start_number, end_number]
   *               (where the numbers are indexes into the input string, zero-based)
   *  }
   *
   * ---
   *
   * The `parseError` function receives a 'hash' object with these members for lexer errors:
   *
   *  {
   *    text:        (matched text)
   *    token:       (the produced terminal token, if any)
   *    token_id:    (the produced terminal token numeric ID, if any)
   *    line:        (yylineno)
   *    loc:         (yylloc)
   *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
   *                  available for this particular error)
   *    yy:          (object: the current parser internal "shared state" `yy`
   *                  as is also available in the rule actions; this can be used,
   *                  for instance, for advanced error analysis and reporting)
   *    lexer:       (reference to the current lexer instance used by the parser)
   *  }
   *
   * while `this` will reference the current lexer instance.
   *
   * When `parseError` is invoked by the lexer, the default implementation will
   * attempt to invoke `yy.parser.parseError()`; when this callback is not provided
   * it will try to invoke `yy.parseError()` instead. When that callback is also not
   * provided, a `JisonLexerError` exception will be thrown containing the error
   * message and `hash`, as constructed by the `constructLexErrorInfo()` API.
   *
   * Note that the lexer's `JisonLexerError` error class is passed via the
   * `ExceptionClass` argument, which is invoked to construct the exception
   * instance to be thrown, so technically `parseError` will throw the object
   * produced by the `new ExceptionClass(str, hash)` JavaScript expression.
   *
   * ---
   *
   * You can specify lexer options by setting / modifying the `.options` object of your Lexer instance.
   * These options are available:
   *
   * (Options are permanent.)
   *
   *  yy: {
   *      parseError: function(str, hash, ExceptionClass)
   *                 optional: overrides the default `parseError` function.
   *  }
   *
   *  lexer.options: {
   *      pre_lex:  function()
   *                 optional: is invoked before the lexer is invoked to produce another token.
   *                 `this` refers to the Lexer object.
   *      post_lex: function(token) { return token; }
   *                 optional: is invoked when the lexer has produced a token `token`;
   *                 this function can override the returned token value by returning another.
   *                 When it does not return any (truthy) value, the lexer will return
   *                 the original `token`.
   *                 `this` refers to the Lexer object.
   *
   * WARNING: the next set of options are not meant to be changed. They echo the abilities of
   * the lexer as per when it was compiled!
   *
   *      ranges: boolean
   *                 optional: `true` ==> token location info will include a .range[] member.
   *      flex: boolean
   *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
   *                 exhaustively to find the longest match.
   *      backtrack_lexer: boolean
   *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
   *                 the lexer terminates the scan when a token is returned by the action code.
   *      xregexp: boolean
   *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
   *                 `XRegExp` library. When this %option has not been specified at compile time, all lexer
   *                 rule regexes have been written as standard JavaScript RegExp expressions.
   *  }
   */

  var lexer = function () {
    /**
     * See also:
     * http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
     * but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
     * with userland code which might access the derived class in a 'classic' way.
     *
     * @public
     * @constructor
     * @nocollapse
     */
    function JisonLexerError(msg, hash) {
      Object.defineProperty(this, "name", {
        enumerable: false,
        writable: false,
        value: "JisonLexerError"
      });
      if (msg == null) msg = "???";
      Object.defineProperty(this, "message", {
        enumerable: false,
        writable: true,
        value: msg
      });
      this.hash = hash;
      var stacktrace;
      if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
      }
      if (!stacktrace) {
        if (Error.hasOwnProperty("captureStackTrace")) {
          // V8
          Error.captureStackTrace(this, this.constructor);
        } else {
          stacktrace = new Error(msg).stack;
        }
      }
      if (stacktrace) {
        Object.defineProperty(this, "stack", {
          enumerable: false,
          writable: false,
          value: stacktrace
        });
      }
    }
    if (typeof Object.setPrototypeOf === "function") {
      Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);
    } else {
      JisonLexerError.prototype = Object.create(Error.prototype);
    }
    JisonLexerError.prototype.constructor = JisonLexerError;
    JisonLexerError.prototype.name = "JisonLexerError";
    var lexer = {
      // Code Generator Information Report
      // ---------------------------------
      //
      // Options:
      //
      //   backtracking: .................... false
      //   location.ranges: ................. false
      //   location line+column tracking: ... true
      //
      //
      // Forwarded Parser Analysis flags:
      //
      //   uses yyleng: ..................... false
      //   uses yylineno: ................... false
      //   uses yytext: ..................... false
      //   uses yylloc: ..................... false
      //   uses lexer values: ............... true / true
      //   location tracking: ............... false
      //   location assignment: ............. false
      //
      //
      // Lexer Analysis flags:
      //
      //   uses yyleng: ..................... ???
      //   uses yylineno: ................... ???
      //   uses yytext: ..................... ???
      //   uses yylloc: ..................... ???
      //   uses ParseError API: ............. ???
      //   uses yyerror: .................... ???
      //   uses location tracking & editing:  ???
      //   uses more() API: ................. ???
      //   uses unput() API: ................ ???
      //   uses reject() API: ............... ???
      //   uses less() API: ................. ???
      //   uses display APIs pastInput(), upcomingInput(), showPosition():
      //        ............................. ???
      //   uses describeYYLLOC() API: ....... ???
      //
      // --------- END OF REPORT -----------

      EOF: 1,
      ERROR: 2,
      // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator

      // options: {},                             /// <-- injected by the code generator

      // yy: ...,                                 /// <-- injected by setInput()

      __currentRuleSet__: null,
      /// INTERNAL USE ONLY: internal rule set cache for the current lexer state

      __error_infos: [],
      /// INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup
      __decompressed: false,
      /// INTERNAL USE ONLY: mark whether the lexer instance has been 'unfolded' completely and is now ready for use
      done: false,
      /// INTERNAL USE ONLY
      _backtrack: false,
      /// INTERNAL USE ONLY
      _input: "",
      /// INTERNAL USE ONLY
      _more: false,
      /// INTERNAL USE ONLY
      _signaled_error_token: false,
      /// INTERNAL USE ONLY
      conditionStack: [],
      /// INTERNAL USE ONLY; managed via `pushState()`, `popState()`, `topState()` and `stateStackSize()`
      match: "",
      /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. `match` is identical to `yytext` except that this one still contains the matched input string after `lexer.performAction()` has been invoked, where userland code MAY have changed/replaced the `yytext` value entirely!
      matched: "",
      /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far
      matches: false,
      /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt
      yytext: "",
      /// ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the 'token value' when the parser consumes the lexer token produced through a call to the `lex()` API.
      offset: 0,
      /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the 'cursor position' in the input string, i.e. the number of characters matched so far
      yyleng: 0,
      /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (`yytext`)
      yylineno: 0,
      /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: 'line number' at which the token under construction is located
      yylloc: null,
      /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction

      /**
       * INTERNAL USE: construct a suitable error info hash object instance for `parseError`.
       *
       * @public
       * @this {RegExpLexer}
       */
      constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable, show_input_position) {
        msg = "" + msg;

        // heuristic to determine if the error message already contains a (partial) source code dump
        // as produced by either `showPosition()` or `prettyPrintRange()`:
        if (show_input_position == undefined) {
          show_input_position = !(msg.indexOf("\n") > 0 && msg.indexOf("^") > 0);
        }
        if (this.yylloc && show_input_position) {
          if (typeof this.prettyPrintRange === "function") {
            this.prettyPrintRange(this.yylloc);
            if (!/\n\s*$/.test(msg)) {
              msg += "\n";
            }
            msg += "\n  Erroneous area:\n" + this.prettyPrintRange(this.yylloc);
          } else if (typeof this.showPosition === "function") {
            var pos_str = this.showPosition();
            if (pos_str) {
              if (msg.length && msg[msg.length - 1] !== "\n" && pos_str[0] !== "\n") {
                msg += "\n" + pos_str;
              } else {
                msg += pos_str;
              }
            }
          }
        }

        /** @constructor */
        var pei = {
          errStr: msg,
          recoverable: !!recoverable,
          text: this.match,
          // This one MAY be empty; userland code should use the `upcomingInput` API to obtain more text which follows the 'lexer cursor position'...
          token: null,
          line: this.yylineno,
          loc: this.yylloc,
          yy: this.yy,
          lexer: this,
          /**
           * and make sure the error info doesn't stay due to potential
           * ref cycle via userland code manipulations.
           * These would otherwise all be memory leak opportunities!
           *
           * Note that only array and object references are nuked as those
           * constitute the set of elements which can produce a cyclic ref.
           * The rest of the members is kept intact as they are harmless.
           *
           * @public
           * @this {LexErrorInfo}
           */
          destroy: function destructLexErrorInfo() {
            // remove cyclic references added to error info:
            // info.yy = null;
            // info.lexer = null;
            // ...
            var rec = !!this.recoverable;
            for (var key in this) {
              if (this.hasOwnProperty(key) && typeof key === "object") {
                this[key] = undefined;
              }
            }
            this.recoverable = rec;
          }
        };

        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
        this.__error_infos.push(pei);
        return pei;
      },
      /**
       * handler which is invoked when a lexer error occurs.
       *
       * @public
       * @this {RegExpLexer}
       */
      parseError: function lexer_parseError(str, hash, ExceptionClass) {
        if (!ExceptionClass) {
          ExceptionClass = this.JisonLexerError;
        }
        if (this.yy) {
          if (this.yy.parser && typeof this.yy.parser.parseError === "function") {
            return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
          } else if (typeof this.yy.parseError === "function") {
            return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
          }
        }
        throw new ExceptionClass(str, hash);
      },
      /**
       * method which implements `yyerror(str, ...args)` functionality for use inside lexer actions.
       *
       * @public
       * @this {RegExpLexer}
       */
      yyerror: function yyError(str /*, ...args */) {
        var lineno_msg = "";
        if (this.yylloc) {
          lineno_msg = " on line " + (this.yylineno + 1);
        }
        var p = this.constructLexErrorInfo("Lexical error" + lineno_msg + ": " + str, this.options.lexerErrorsAreRecoverable);

        // Add any extra args to the hash under the name `extra_error_attributes`:
        var args = Array.prototype.slice.call(arguments, 1);
        if (args.length) {
          p.extra_error_attributes = args;
        }
        return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
      },
      /**
       * final cleanup function for when we have completed lexing the input;
       * make it an API so that external code can use this one once userland
       * code has decided it's time to destroy any lingering lexer error
       * hash object instances and the like: this function helps to clean
       * up these constructs, which *may* carry cyclic references which would
       * otherwise prevent the instances from being properly and timely
       * garbage-collected, i.e. this function helps prevent memory leaks!
       *
       * @public
       * @this {RegExpLexer}
       */
      cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {
        // prevent lingering circular references from causing memory leaks:
        this.setInput("", {});

        // nuke the error hash info instances created during this run.
        // Userland code must COPY any data/references
        // in the error hash instance(s) it is more permanently interested in.
        if (!do_not_nuke_errorinfos) {
          for (var i = this.__error_infos.length - 1; i >= 0; i--) {
            var el = this.__error_infos[i];
            if (el && typeof el.destroy === "function") {
              el.destroy();
            }
          }
          this.__error_infos.length = 0;
        }
        return this;
      },
      /**
       * clear the lexer token context; intended for internal use only
       *
       * @public
       * @this {RegExpLexer}
       */
      clear: function lexer_clear() {
        this.yytext = "";
        this.yyleng = 0;
        this.match = "";

        // - DO NOT reset `this.matched`
        this.matches = false;
        this._more = false;
        this._backtrack = false;
        var col = this.yylloc ? this.yylloc.last_column : 0;
        this.yylloc = {
          first_line: this.yylineno + 1,
          first_column: col,
          last_line: this.yylineno + 1,
          last_column: col,
          range: [this.offset, this.offset]
        };
      },
      /**
       * resets the lexer, sets new input
       *
       * @public
       * @this {RegExpLexer}
       */
      setInput: function lexer_setInput(input, yy) {
        this.yy = yy || this.yy || {};

        // also check if we've fully initialized the lexer instance,
        // including expansion work to be done to go from a loaded
        // lexer to a usable lexer:
        if (!this.__decompressed) {
          // step 1: decompress the regex list:
          var rules = this.rules;
          for (var i = 0, len = rules.length; i < len; i++) {
            var rule_re = rules[i];

            // compression: is the RE an xref to another RE slot in the rules[] table?
            if (typeof rule_re === "number") {
              rules[i] = rules[rule_re];
            }
          }

          // step 2: unfold the conditions[] set to make these ready for use:
          var conditions = this.conditions;
          for (var k in conditions) {
            var spec = conditions[k];
            var rule_ids = spec.rules;
            var len = rule_ids.length;
            var rule_regexes = new Array(len + 1); // slot 0 is unused; we use a 1-based index approach here to keep the hottest code in `lexer_next()` fast and simple!
            var rule_new_ids = new Array(len + 1);
            for (var i = 0; i < len; i++) {
              var idx = rule_ids[i];
              var rule_re = rules[idx];
              rule_regexes[i + 1] = rule_re;
              rule_new_ids[i + 1] = idx;
            }
            spec.rules = rule_new_ids;
            spec.__rule_regexes = rule_regexes;
            spec.__rule_count = len;
          }
          this.__decompressed = true;
        }
        this._input = input || "";
        this.clear();
        this._signaled_error_token = false;
        this.done = false;
        this.yylineno = 0;
        this.matched = "";
        this.conditionStack = ["INITIAL"];
        this.__currentRuleSet__ = null;
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0,
          range: [0, 0]
        };
        this.offset = 0;
        return this;
      },
      /**
       * edit the remaining input via user-specified callback.
       * This can be used to forward-adjust the input-to-parse,
       * e.g. inserting macro expansions and alike in the
       * input which has yet to be lexed.
       * The behaviour of this API contrasts the `unput()` et al
       * APIs as those act on the *consumed* input, while this
       * one allows one to manipulate the future, without impacting
       * the current `yyloc` cursor location or any history.
       *
       * Use this API to help implement C-preprocessor-like
       * `#include` statements, etc.
       *
       * The provided callback must be synchronous and is
       * expected to return the edited input (string).
       *
       * The `cpsArg` argument value is passed to the callback
       * as-is.
       *
       * `callback` interface:
       * `function callback(input, cpsArg)`
       *
       * - `input` will carry the remaining-input-to-lex string
       *   from the lexer.
       * - `cpsArg` is `cpsArg` passed into this API.
       *
       * The `this` reference for the callback will be set to
       * reference this lexer instance so that userland code
       * in the callback can easily and quickly access any lexer
       * API.
       *
       * When the callback returns a non-string-type falsey value,
       * we assume the callback did not edit the input and we
       * will using the input as-is.
       *
       * When the callback returns a non-string-type value, it
       * is converted to a string for lexing via the `"" + retval`
       * operation. (See also why: http://2ality.com/2012/03/converting-to-string.html
       * -- that way any returned object's `toValue()` and `toString()`
       * methods will be invoked in a proper/desirable order.)
       *
       * @public
       * @this {RegExpLexer}
       */
      editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {
        var rv = callback.call(this, this._input, cpsArg);
        if (typeof rv !== "string") {
          if (rv) {
            this._input = "" + rv;
          }
          // else: keep `this._input` as is.
        } else {
          this._input = rv;
        }
        return this;
      },
      /**
       * consumes and returns one char from the input
       *
       * @public
       * @this {RegExpLexer}
       */
      input: function lexer_input() {
        if (!this._input) {
          //this.done = true;    -- don't set `done` as we want the lex()/next() API to be able to produce one custom EOF token match after this anyhow. (lexer can match special <<EOF>> tokens and perform user action code for a <<EOF>> match, but only does so *once*)
          return null;
        }
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;

        // Count the linenumber up when we hit the LF (or a stand-alone CR).
        // On CRLF, the linenumber is incremented when you fetch the CR or the CRLF combo
        // and we advance immediately past the LF as well, returning both together as if
        // it was all a single 'character' only.
        var slice_len = 1;
        var lines = false;
        if (ch === "\n") {
          lines = true;
        } else if (ch === "\r") {
          lines = true;
          var ch2 = this._input[1];
          if (ch2 === "\n") {
            slice_len++;
            ch += ch2;
            this.yytext += ch2;
            this.yyleng++;
            this.offset++;
            this.match += ch2;
            this.matched += ch2;
            this.yylloc.range[1]++;
          }
        }
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
          this.yylloc.last_column = 0;
        } else {
          this.yylloc.last_column++;
        }
        this.yylloc.range[1]++;
        this._input = this._input.slice(slice_len);
        return ch;
      },
      /**
       * unshifts one char (or an entire string) into the input
       *
       * @public
       * @this {RegExpLexer}
       */
      unput: function lexer_unput(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.yyleng = this.yytext.length;
        this.offset -= len;
        this.match = this.match.substr(0, this.match.length - len);
        this.matched = this.matched.substr(0, this.matched.length - len);
        if (lines.length > 1) {
          this.yylineno -= lines.length - 1;
          this.yylloc.last_line = this.yylineno + 1;

          // Get last entirely matched line into the `pre_lines[]` array's
          // last index slot; we don't mind when other previously
          // matched lines end up in the array too.
          var pre = this.match;
          var pre_lines = pre.split(/(?:\r\n?|\n)/g);
          if (pre_lines.length === 1) {
            pre = this.matched;
            pre_lines = pre.split(/(?:\r\n?|\n)/g);
          }
          this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;
        } else {
          this.yylloc.last_column -= len;
        }
        this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;
        this.done = false;
        return this;
      },
      /**
       * cache matched text and append it on next action
       *
       * @public
       * @this {RegExpLexer}
       */
      more: function lexer_more() {
        this._more = true;
        return this;
      },
      /**
       * signal the lexer that this rule fails to match the input, so the
       * next matching rule (regex) should be tested instead.
       *
       * @public
       * @this {RegExpLexer}
       */
      reject: function lexer_reject() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          // when the `parseError()` call returns, we MUST ensure that the error is registered.
          // We accomplish this by signaling an 'error' token to be produced for the current
          // `.lex()` run.
          var lineno_msg = "";
          if (this.yylloc) {
            lineno_msg = " on line " + (this.yylineno + 1);
          }
          var p = this.constructLexErrorInfo("Lexical error" + lineno_msg + ": You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).", false);
          this._signaled_error_token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
        }
        return this;
      },
      /**
       * retain first n characters of the match
       *
       * @public
       * @this {RegExpLexer}
       */
      less: function lexer_less(n) {
        return this.unput(this.match.slice(n));
      },
      /**
       * return (part of the) already matched input, i.e. for error
       * messages.
       *
       * Limit the returned string length to `maxSize` (default: 20).
       *
       * Limit the returned string to the `maxLines` number of lines of
       * input (default: 1).
       *
       * Negative limit values equal *unlimited*.
       *
       * @public
       * @this {RegExpLexer}
       */
      pastInput: function lexer_pastInput(maxSize, maxLines) {
        var past = this.matched.substring(0, this.matched.length - this.match.length);
        if (maxSize < 0) maxSize = past.length;else if (!maxSize) maxSize = 20;
        if (maxLines < 0) maxLines = past.length; // can't ever have more input lines than this!
        else if (!maxLines) maxLines = 1;

        // `substr` anticipation: treat \r\n as a single character and take a little
        // more than necessary so that we can still properly check against maxSize
        // after we've transformed and limited the newLines in here:
        past = past.substr(-maxSize * 2 - 2);

        // now that we have a significantly reduced string to process, transform the newlines
        // and chop them, then limit them:
        var a = past.replace(/\r\n|\r/g, "\n").split("\n");
        a = a.slice(-maxLines);
        past = a.join("\n");

        // When, after limiting to maxLines, we still have too much to return,
        // do add an ellipsis prefix...
        if (past.length > maxSize) {
          past = "..." + past.substr(-maxSize);
        }
        return past;
      },
      /**
       * return (part of the) upcoming input, i.e. for error messages.
       *
       * Limit the returned string length to `maxSize` (default: 20).
       *
       * Limit the returned string to the `maxLines` number of lines of input (default: 1).
       *
       * Negative limit values equal *unlimited*.
       *
       * > ### NOTE ###
       * >
       * > *"upcoming input"* is defined as the whole of the both
       * > the *currently lexed* input, together with any remaining input
       * > following that. *"currently lexed"* input is the input
       * > already recognized by the lexer but not yet returned with
       * > the lexer token. This happens when you are invoking this API
       * > from inside any lexer rule action code block.
       * >
       *
       * @public
       * @this {RegExpLexer}
       */
      upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {
        var next = this.match;
        if (maxSize < 0) maxSize = next.length + this._input.length;else if (!maxSize) maxSize = 20;
        if (maxLines < 0) maxLines = maxSize; // can't ever have more input lines than this!
        else if (!maxLines) maxLines = 1;

        // `substring` anticipation: treat \r\n as a single character and take a little
        // more than necessary so that we can still properly check against maxSize
        // after we've transformed and limited the newLines in here:
        if (next.length < maxSize * 2 + 2) {
          next += this._input.substring(0, maxSize * 2 + 2); // substring is faster on Chrome/V8
        }

        // now that we have a significantly reduced string to process, transform the newlines
        // and chop them, then limit them:
        var a = next.replace(/\r\n|\r/g, "\n").split("\n");
        a = a.slice(0, maxLines);
        next = a.join("\n");

        // When, after limiting to maxLines, we still have too much to return,
        // do add an ellipsis postfix...
        if (next.length > maxSize) {
          next = next.substring(0, maxSize) + "...";
        }
        return next;
      },
      /**
       * return a string which displays the character position where the
       * lexing error occurred, i.e. for error messages
       *
       * @public
       * @this {RegExpLexer}
       */
      showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {
        var pre = this.pastInput(maxPrefix).replace(/\s/g, " ");
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput(maxPostfix).replace(/\s/g, " ") + "\n" + c + "^";
      },
      /**
       * return an YYLLOC info object derived off the given context (actual, preceding, following, current).
       * Use this method when the given `actual` location is not guaranteed to exist (i.e. when
       * it MAY be NULL) and you MUST have a valid location info object anyway:
       * then we take the given context of the `preceding` and `following` locations, IFF those are available,
       * and reconstruct the `actual` location info from those.
       * If this fails, the heuristic is to take the `current` location, IFF available.
       * If this fails as well, we assume the sought location is at/around the current lexer position
       * and then produce that one as a response. DO NOTE that these heuristic/derived location info
       * values MAY be inaccurate!
       *
       * NOTE: `deriveLocationInfo()` ALWAYS produces a location info object *copy* of `actual`, not just
       * a *reference* hence all input location objects can be assumed to be 'constant' (function has no side-effects).
       *
       * @public
       * @this {RegExpLexer}
       */
      deriveLocationInfo: function lexer_deriveYYLLOC(actual, preceding, following, current) {
        var loc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0,
          range: [0, 0]
        };
        if (actual) {
          loc.first_line = actual.first_line | 0;
          loc.last_line = actual.last_line | 0;
          loc.first_column = actual.first_column | 0;
          loc.last_column = actual.last_column | 0;
          if (actual.range) {
            loc.range[0] = actual.range[0] | 0;
            loc.range[1] = actual.range[1] | 0;
          }
        }
        if (loc.first_line <= 0 || loc.last_line < loc.first_line) {
          // plan B: heuristic using preceding and following:
          if (loc.first_line <= 0 && preceding) {
            loc.first_line = preceding.last_line | 0;
            loc.first_column = preceding.last_column | 0;
            if (preceding.range) {
              loc.range[0] = actual.range[1] | 0;
            }
          }
          if ((loc.last_line <= 0 || loc.last_line < loc.first_line) && following) {
            loc.last_line = following.first_line | 0;
            loc.last_column = following.first_column | 0;
            if (following.range) {
              loc.range[1] = actual.range[0] | 0;
            }
          }

          // plan C?: see if the 'current' location is useful/sane too:
          if (loc.first_line <= 0 && current && (loc.last_line <= 0 || current.last_line <= loc.last_line)) {
            loc.first_line = current.first_line | 0;
            loc.first_column = current.first_column | 0;
            if (current.range) {
              loc.range[0] = current.range[0] | 0;
            }
          }
          if (loc.last_line <= 0 && current && (loc.first_line <= 0 || current.first_line >= loc.first_line)) {
            loc.last_line = current.last_line | 0;
            loc.last_column = current.last_column | 0;
            if (current.range) {
              loc.range[1] = current.range[1] | 0;
            }
          }
        }

        // sanitize: fix last_line BEFORE we fix first_line as we use the 'raw' value of the latter
        // or plan D heuristics to produce a 'sensible' last_line value:
        if (loc.last_line <= 0) {
          if (loc.first_line <= 0) {
            loc.first_line = this.yylloc.first_line;
            loc.last_line = this.yylloc.last_line;
            loc.first_column = this.yylloc.first_column;
            loc.last_column = this.yylloc.last_column;
            loc.range[0] = this.yylloc.range[0];
            loc.range[1] = this.yylloc.range[1];
          } else {
            loc.last_line = this.yylloc.last_line;
            loc.last_column = this.yylloc.last_column;
            loc.range[1] = this.yylloc.range[1];
          }
        }
        if (loc.first_line <= 0) {
          loc.first_line = loc.last_line;
          loc.first_column = 0; // loc.last_column;
          loc.range[1] = loc.range[0];
        }
        if (loc.first_column < 0) {
          loc.first_column = 0;
        }
        if (loc.last_column < 0) {
          loc.last_column = loc.first_column > 0 ? loc.first_column : 80;
        }
        return loc;
      },
      /**
       * return a string which displays the lines & columns of input which are referenced
       * by the given location info range, plus a few lines of context.
       *
       * This function pretty-prints the indicated section of the input, with line numbers
       * and everything!
       *
       * This function is very useful to provide highly readable error reports, while
       * the location range may be specified in various flexible ways:
       *
       * - `loc` is the location info object which references the area which should be
       *   displayed and 'marked up': these lines & columns of text are marked up by `^`
       *   characters below each character in the entire input range.
       *
       * - `context_loc` is the *optional* location info object which instructs this
       *   pretty-printer how much *leading* context should be displayed alongside
       *   the area referenced by `loc`. This can help provide context for the displayed
       *   error, etc.
       *
       *   When this location info is not provided, a default context of 3 lines is
       *   used.
       *
       * - `context_loc2` is another *optional* location info object, which serves
       *   a similar purpose to `context_loc`: it specifies the amount of *trailing*
       *   context lines to display in the pretty-print output.
       *
       *   When this location info is not provided, a default context of 1 line only is
       *   used.
       *
       * Special Notes:
       *
       * - when the `loc`-indicated range is very large (about 5 lines or more), then
       *   only the first and last few lines of this block are printed while a
       *   `...continued...` message will be printed between them.
       *
       *   This serves the purpose of not printing a huge amount of text when the `loc`
       *   range happens to be huge: this way a manageable & readable output results
       *   for arbitrary large ranges.
       *
       * - this function can display lines of input which whave not yet been lexed.
       *   `prettyPrintRange()` can access the entire input!
       *
       * @public
       * @this {RegExpLexer}
       */
      prettyPrintRange: function lexer_prettyPrintRange(loc, context_loc, context_loc2) {
        loc = this.deriveLocationInfo(loc, context_loc, context_loc2);
        const CONTEXT = 3;
        const CONTEXT_TAIL = 1;
        const MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;
        var input = this.matched + this._input;
        var lines = input.split("\n");
        var l0 = Math.max(1, context_loc ? context_loc.first_line : loc.first_line - CONTEXT);
        var l1 = Math.max(1, context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL);
        var lineno_display_width = 1 + Math.log10(l1 | 1) | 0;
        var ws_prefix = new Array(lineno_display_width).join(" ");
        var nonempty_line_indexes = [];
        var rv = lines.slice(l0 - 1, l1 + 1).map(function injectLineNumber(line, index) {
          var lno = index + l0;
          var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);
          var rv = lno_pfx + ": " + line;
          var errpfx = new Array(lineno_display_width + 1).join("^");
          var offset = 2 + 1;
          var len = 0;
          if (lno === loc.first_line) {
            offset += loc.first_column;
            len = Math.max(2, (lno === loc.last_line ? loc.last_column : line.length) - loc.first_column + 1);
          } else if (lno === loc.last_line) {
            len = Math.max(2, loc.last_column + 1);
          } else if (lno > loc.first_line && lno < loc.last_line) {
            len = Math.max(2, line.length + 1);
          }
          if (len) {
            var lead = new Array(offset).join(".");
            var mark = new Array(len).join("^");
            rv += "\n" + errpfx + lead + mark;
            if (line.trim().length > 0) {
              nonempty_line_indexes.push(index);
            }
          }
          rv = rv.replace(/\t/g, " ");
          return rv;
        });

        // now make sure we don't print an overly large amount of error area: limit it
        // to the top and bottom line count:
        if (nonempty_line_indexes.length > 2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT) {
          var clip_start = nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;
          var clip_end = nonempty_line_indexes[nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT] - 1;
          var intermediate_line = new Array(lineno_display_width + 1).join(" ") + "  (...continued...)";
          intermediate_line += "\n" + new Array(lineno_display_width + 1).join("-") + "  (---------------)";
          rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);
        }
        return rv.join("\n");
      },
      /**
       * helper function, used to produce a human readable description as a string, given
       * the input `yylloc` location object.
       *
       * Set `display_range_too` to TRUE to include the string character index position(s)
       * in the description if the `yylloc.range` is available.
       *
       * @public
       * @this {RegExpLexer}
       */
      describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {
        var l1 = yylloc.first_line;
        var l2 = yylloc.last_line;
        var c1 = yylloc.first_column;
        var c2 = yylloc.last_column;
        var dl = l2 - l1;
        var dc = c2 - c1;
        var rv;
        if (dl === 0) {
          rv = "line " + l1 + ", ";
          if (dc <= 1) {
            rv += "column " + c1;
          } else {
            rv += "columns " + c1 + " .. " + c2;
          }
        } else {
          rv = "lines " + l1 + "(column " + c1 + ") .. " + l2 + "(column " + c2 + ")";
        }
        if (yylloc.range && display_range_too) {
          var r1 = yylloc.range[0];
          var r2 = yylloc.range[1] - 1;
          if (r2 <= r1) {
            rv += " {String Offset: " + r1 + "}";
          } else {
            rv += " {String Offset range: " + r1 + " .. " + r2 + "}";
          }
        }
        return rv;
      },
      /**
       * test the lexed token: return FALSE when not a match, otherwise return token.
       *
       * `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`
       * contains the actually matched text string.
       *
       * Also move the input cursor forward and update the match collectors:
       *
       * - `yytext`
       * - `yyleng`
       * - `match`
       * - `matches`
       * - `yylloc`
       * - `offset`
       *
       * @public
       * @this {RegExpLexer}
       */
      test_match: function lexer_test_match(match, indexed_rule) {
        var token, lines, backup, match_str, match_str_len;
        if (this.options.backtrack_lexer) {
          // save context
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.yylloc.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column,
              range: this.yylloc.range.slice(0)
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            //_signaled_error_token: this._signaled_error_token,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
        }
        match_str = match[0];
        match_str_len = match_str.length;

        // if (match_str.indexOf('\n') !== -1 || match_str.indexOf('\r') !== -1) {
        lines = match_str.split(/(?:\r\n?|\n)/g);
        if (lines.length > 1) {
          this.yylineno += lines.length - 1;
          this.yylloc.last_line = this.yylineno + 1;
          this.yylloc.last_column = lines[lines.length - 1].length;
        } else {
          this.yylloc.last_column += match_str_len;
        }

        // }
        this.yytext += match_str;
        this.match += match_str;
        this.matched += match_str;
        this.matches = match;
        this.yyleng = this.yytext.length;
        this.yylloc.range[1] += match_str_len;

        // previous lex rules MAY have invoked the `more()` API rather than producing a token:
        // those rules will already have moved this `offset` forward matching their match lengths,
        // hence we must only add our own match length now:
        this.offset += match_str_len;
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match_str_len);

        // calling this method:
        //
        //   function lexer__performAction(yy, yyrulenumber, YY_START) {...}
        token = this.performAction.call(this, this.yy, indexed_rule, this.conditionStack[this.conditionStack.length - 1] /* = YY_START */);

        // otherwise, when the action codes are all simple return token statements:
        //token = this.simpleCaseActionClusters[indexed_rule];

        if (this.done && this._input) {
          this.done = false;
        }
        if (token) {
          return token;
        } else if (this._backtrack) {
          // recover context
          for (var k in backup) {
            this[k] = backup[k];
          }
          this.__currentRuleSet__ = null;
          return false; // rule action called reject() implying the next rule should be tested instead.
        } else if (this._signaled_error_token) {
          // produce one 'error' token as `.parseError()` in `reject()`
          // did not guarantee a failure signal by throwing an exception!
          token = this._signaled_error_token;
          this._signaled_error_token = false;
          return token;
        }
        return false;
      },
      /**
       * return next match in input
       *
       * @public
       * @this {RegExpLexer}
       */
      next: function lexer_next() {
        if (this.done) {
          this.clear();
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token, match, tempMatch, index;
        if (!this._more) {
          this.clear();
        }
        var spec = this.__currentRuleSet__;
        if (!spec) {
          // Update the ruleset cache as we apparently encountered a state change or just started lexing.
          // The cache is set up for fast lookup -- we assume a lexer will switch states much less often than it will
          // invoke the `lex()` token-producing API and related APIs, hence caching the set for direct access helps
          // speed up those activities a tiny bit.
          spec = this.__currentRuleSet__ = this._currentRules();

          // Check whether a *sane* condition has been pushed before: this makes the lexer robust against
          // user-programmer bugs such as https://github.com/zaach/jison-lex/issues/19
          if (!spec || !spec.rules) {
            var lineno_msg = "";
            if (this.options.trackPosition) {
              lineno_msg = " on line " + (this.yylineno + 1);
            }
            var p = this.constructLexErrorInfo("Internal lexer engine error" + lineno_msg + ': The lex grammar programmer pushed a non-existing condition name "' + this.topState() + '"; this is a fatal error and should be reported to the application programmer team!', false);

            // produce one 'error' token until this situation has been resolved, most probably by parse termination!
            return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
          }
        }
        var rule_ids = spec.rules;
        var regexes = spec.__rule_regexes;
        var len = spec.__rule_count;

        // Note: the arrays are 1-based, while `len` itself is a valid index,
        // hence the non-standard less-or-equal check in the next loop condition!
        for (var i = 1; i <= len; i++) {
          tempMatch = this._input.match(regexes[i]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index = i;
            if (this.options.backtrack_lexer) {
              token = this.test_match(tempMatch, rule_ids[i]);
              if (token !== false) {
                return token;
              } else if (this._backtrack) {
                match = undefined;
                continue; // rule action called reject() implying a rule MISmatch.
              } else {
                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token = this.test_match(match, rule_ids[index]);
          if (token !== false) {
            return token;
          }

          // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
          return false;
        }
        if (!this._input) {
          this.done = true;
          this.clear();
          return this.EOF;
        } else {
          var lineno_msg = "";
          if (this.options.trackPosition) {
            lineno_msg = " on line " + (this.yylineno + 1);
          }
          var p = this.constructLexErrorInfo("Lexical error" + lineno_msg + ": Unrecognized text.", this.options.lexerErrorsAreRecoverable);
          var pendingInput = this._input;
          var activeCondition = this.topState();
          var conditionStackDepth = this.conditionStack.length;
          token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
          if (token === this.ERROR) {
            // we can try to recover from a lexer error that `parseError()` did not 'recover' for us
            // by moving forward at least one character at a time IFF the (user-specified?) `parseError()`
            // has not consumed/modified any pending input or changed state in the error handler:
            if (!this.matches &&
            // and make sure the input has been modified/consumed ...
            pendingInput === this._input &&
            // ...or the lexer state has been modified significantly enough
            // to merit a non-consuming error handling action right now.
            activeCondition === this.topState() && conditionStackDepth === this.conditionStack.length) {
              this.input();
            }
          }
          return token;
        }
      },
      /**
       * return next match that has a token
       *
       * @public
       * @this {RegExpLexer}
       */
      lex: function lexer_lex() {
        var r;

        // allow the PRE/POST handlers set/modify the return token for maximum flexibility of the generated lexer:
        if (typeof this.pre_lex === "function") {
          r = this.pre_lex.call(this, 0);
        }
        if (typeof this.options.pre_lex === "function") {
          // (also account for a userdef function which does not return any value: keep the token as is)
          r = this.options.pre_lex.call(this, r) || r;
        }
        if (this.yy && typeof this.yy.pre_lex === "function") {
          // (also account for a userdef function which does not return any value: keep the token as is)
          r = this.yy.pre_lex.call(this, r) || r;
        }
        while (!r) {
          r = this.next();
        }
        if (this.yy && typeof this.yy.post_lex === "function") {
          // (also account for a userdef function which does not return any value: keep the token as is)
          r = this.yy.post_lex.call(this, r) || r;
        }
        if (typeof this.options.post_lex === "function") {
          // (also account for a userdef function which does not return any value: keep the token as is)
          r = this.options.post_lex.call(this, r) || r;
        }
        if (typeof this.post_lex === "function") {
          // (also account for a userdef function which does not return any value: keep the token as is)
          r = this.post_lex.call(this, r) || r;
        }
        return r;
      },
      /**
       * return next match that has a token. Identical to the `lex()` API but does not invoke any of the
       * `pre_lex()` nor any of the `post_lex()` callbacks.
       *
       * @public
       * @this {RegExpLexer}
       */
      fastLex: function lexer_fastLex() {
        var r;
        while (!r) {
          r = this.next();
        }
        return r;
      },
      /**
       * return info about the lexer state that can help a parser or other lexer API user to use the
       * most efficient means available. This API is provided to aid run-time performance for larger
       * systems which employ this lexer.
       *
       * @public
       * @this {RegExpLexer}
       */
      canIUse: function lexer_canIUse() {
        var rv = {
          fastLex: !(typeof this.pre_lex === "function" || typeof this.options.pre_lex === "function" || this.yy && typeof this.yy.pre_lex === "function" || this.yy && typeof this.yy.post_lex === "function" || typeof this.options.post_lex === "function" || typeof this.post_lex === "function") && typeof this.fastLex === "function"
        };
        return rv;
      },
      /**
       * backwards compatible alias for `pushState()`;
       * the latter is symmetrical with `popState()` and we advise to use
       * those APIs in any modern lexer code, rather than `begin()`.
       *
       * @public
       * @this {RegExpLexer}
       */
      begin: function lexer_begin(condition) {
        return this.pushState(condition);
      },
      /**
       * activates a new lexer condition state (pushes the new lexer
       * condition state onto the condition stack)
       *
       * @public
       * @this {RegExpLexer}
       */
      pushState: function lexer_pushState(condition) {
        this.conditionStack.push(condition);
        this.__currentRuleSet__ = null;
        return this;
      },
      /**
       * pop the previously active lexer condition state off the condition
       * stack
       *
       * @public
       * @this {RegExpLexer}
       */
      popState: function lexer_popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          this.__currentRuleSet__ = null;
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      /**
       * return the currently active lexer condition state; when an index
       * argument is provided it produces the N-th previous condition state,
       * if available
       *
       * @public
       * @this {RegExpLexer}
       */
      topState: function lexer_topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      /**
       * (internal) determine the lexer rule set which is active for the
       * currently active lexer condition state
       *
       * @public
       * @this {RegExpLexer}
       */
      _currentRules: function lexer__currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]];
        } else {
          return this.conditions["INITIAL"];
        }
      },
      /**
       * return the number of states currently on the stack
       *
       * @public
       * @this {RegExpLexer}
       */
      stateStackSize: function lexer_stateStackSize() {
        return this.conditionStack.length;
      },
      options: {
        trackPosition: true
      },
      JisonLexerError: JisonLexerError,
      performAction: function lexer__performAction(yy, yyrulenumber, YY_START) {
        switch (yyrulenumber) {
          case 1:
            /*! Conditions:: INITIAL */
            /*! Rule::       \s+ */
            /* skip whitespace */
            break;
          default:
            return this.simpleCaseActionClusters[yyrulenumber];
        }
      },
      simpleCaseActionClusters: {
        /*! Conditions:: INITIAL */
        /*! Rule::       (--[0-9a-z-A-Z-]*) */
        0: 16,
        /*! Conditions:: INITIAL */
        /*! Rule::       \* */
        2: 5,
        /*! Conditions:: INITIAL */
        /*! Rule::       \/ */
        3: 6,
        /*! Conditions:: INITIAL */
        /*! Rule::       \+ */
        4: 3,
        /*! Conditions:: INITIAL */
        /*! Rule::       - */
        5: 4,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)px\b */
        6: 17,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)cm\b */
        7: 17,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)mm\b */
        8: 17,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)in\b */
        9: 17,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)pt\b */
        10: 17,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)pc\b */
        11: 17,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)deg\b */
        12: 18,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)grad\b */
        13: 18,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)rad\b */
        14: 18,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)turn\b */
        15: 18,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)s\b */
        16: 19,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)ms\b */
        17: 19,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)Hz\b */
        18: 20,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)kHz\b */
        19: 20,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)dpi\b */
        20: 21,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)dpcm\b */
        21: 21,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)dppx\b */
        22: 21,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)em\b */
        23: 22,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)ex\b */
        24: 23,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)ch\b */
        25: 24,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)rem\b */
        26: 25,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)vw\b */
        27: 27,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)vh\b */
        28: 26,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)vmin\b */
        29: 28,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)vmax\b */
        30: 29,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)% */
        31: 30,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)\b */
        32: 14,
        /*! Conditions:: INITIAL */
        /*! Rule::       (calc) */
        33: 9,
        /*! Conditions:: INITIAL */
        /*! Rule::       (var) */
        34: 15,
        /*! Conditions:: INITIAL */
        /*! Rule::       (max) */
        35: 10,
        /*! Conditions:: INITIAL */
        /*! Rule::       (min) */
        36: 12,
        /*! Conditions:: INITIAL */
        /*! Rule::       ([a-z]+) */
        37: 13,
        /*! Conditions:: INITIAL */
        /*! Rule::       \( */
        38: 7,
        /*! Conditions:: INITIAL */
        /*! Rule::       \) */
        39: 8,
        /*! Conditions:: INITIAL */
        /*! Rule::       , */
        40: 11,
        /*! Conditions:: INITIAL */
        /*! Rule::       $ */
        41: 1
      },
      rules: [/*  0: *//^(?:(--[\d\-A-Za-z]*))/, /*  1: *//^(?:\s+)/, /*  2: *//^(?:\*)/, /*  3: *//^(?:\/)/, /*  4: *//^(?:\+)/, /*  5: *//^(?:-)/, /*  6: *//^(?:(\d+(\.\d*)?|\.\d+)px\b)/, /*  7: *//^(?:(\d+(\.\d*)?|\.\d+)cm\b)/, /*  8: *//^(?:(\d+(\.\d*)?|\.\d+)mm\b)/, /*  9: *//^(?:(\d+(\.\d*)?|\.\d+)in\b)/, /* 10: *//^(?:(\d+(\.\d*)?|\.\d+)pt\b)/, /* 11: *//^(?:(\d+(\.\d*)?|\.\d+)pc\b)/, /* 12: *//^(?:(\d+(\.\d*)?|\.\d+)deg\b)/, /* 13: *//^(?:(\d+(\.\d*)?|\.\d+)grad\b)/, /* 14: *//^(?:(\d+(\.\d*)?|\.\d+)rad\b)/, /* 15: *//^(?:(\d+(\.\d*)?|\.\d+)turn\b)/, /* 16: *//^(?:(\d+(\.\d*)?|\.\d+)s\b)/, /* 17: *//^(?:(\d+(\.\d*)?|\.\d+)ms\b)/, /* 18: *//^(?:(\d+(\.\d*)?|\.\d+)Hz\b)/, /* 19: *//^(?:(\d+(\.\d*)?|\.\d+)kHz\b)/, /* 20: *//^(?:(\d+(\.\d*)?|\.\d+)dpi\b)/, /* 21: *//^(?:(\d+(\.\d*)?|\.\d+)dpcm\b)/, /* 22: *//^(?:(\d+(\.\d*)?|\.\d+)dppx\b)/, /* 23: *//^(?:(\d+(\.\d*)?|\.\d+)em\b)/, /* 24: *//^(?:(\d+(\.\d*)?|\.\d+)ex\b)/, /* 25: *//^(?:(\d+(\.\d*)?|\.\d+)ch\b)/, /* 26: *//^(?:(\d+(\.\d*)?|\.\d+)rem\b)/, /* 27: *//^(?:(\d+(\.\d*)?|\.\d+)vw\b)/, /* 28: *//^(?:(\d+(\.\d*)?|\.\d+)vh\b)/, /* 29: *//^(?:(\d+(\.\d*)?|\.\d+)vmin\b)/, /* 30: *//^(?:(\d+(\.\d*)?|\.\d+)vmax\b)/, /* 31: *//^(?:(\d+(\.\d*)?|\.\d+)%)/, /* 32: *//^(?:(\d+(\.\d*)?|\.\d+)\b)/, /* 33: *//^(?:(calc))/, /* 34: *//^(?:(var))/, /* 35: *//^(?:(max))/, /* 36: *//^(?:(min))/, /* 37: *//^(?:([a-z]+))/, /* 38: *//^(?:\()/, /* 39: *//^(?:\))/, /* 40: *//^(?:,)/, /* 41: *//^(?:$)/],
      conditions: {
        INITIAL: {
          rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41],
          inclusive: true
        }
      }
    };
    return lexer;
  }();
  parser.lexer = lexer;
  function Parser() {
    this.yy = {};
  }
  Parser.prototype = parser;
  parser.Parser = Parser;
  return new Parser();
}();
var parser_1 = {
  parser
};

/* with love from shopstory */
const conversions = {
  // length
  px: {
    px: 1,
    cm: 96.0 / 2.54,
    mm: 96.0 / 25.4,
    in: 96,
    pt: 96.0 / 72.0,
    pc: 16
  },
  cm: {
    px: 2.54 / 96.0,
    cm: 1,
    mm: 0.1,
    in: 2.54,
    pt: 2.54 / 72.0,
    pc: 2.54 / 6.0
  },
  mm: {
    px: 25.4 / 96.0,
    cm: 10,
    mm: 1,
    in: 25.4,
    pt: 25.4 / 72.0,
    pc: 25.4 / 6.0
  },
  in: {
    px: 1.0 / 96.0,
    cm: 1.0 / 2.54,
    mm: 1.0 / 25.4,
    in: 1,
    pt: 1.0 / 72.0,
    pc: 1.0 / 6.0
  },
  pt: {
    px: 0.75,
    cm: 72.0 / 2.54,
    mm: 72.0 / 25.4,
    in: 72,
    pt: 1,
    pc: 12
  },
  pc: {
    px: 6.0 / 96.0,
    cm: 6.0 / 2.54,
    mm: 6.0 / 25.4,
    in: 6,
    pt: 6.0 / 72.0,
    pc: 1
  },
  // angle
  deg: {
    deg: 1,
    grad: 0.9,
    rad: 180 / Math.PI,
    turn: 360
  },
  grad: {
    deg: 400 / 360,
    grad: 1,
    rad: 200 / Math.PI,
    turn: 400
  },
  rad: {
    deg: Math.PI / 180,
    grad: Math.PI / 200,
    rad: 1,
    turn: Math.PI * 2
  },
  turn: {
    deg: 1 / 360,
    grad: 1 / 400,
    rad: 0.5 / Math.PI,
    turn: 1
  },
  // time
  s: {
    s: 1,
    ms: 1 / 1000
  },
  ms: {
    s: 1000,
    ms: 1
  },
  // frequency
  Hz: {
    Hz: 1,
    kHz: 1000
  },
  kHz: {
    Hz: 1 / 1000,
    kHz: 1
  },
  // resolution
  dpi: {
    dpi: 1,
    dpcm: 1.0 / 2.54,
    dppx: 1 / 96
  },
  dpcm: {
    dpi: 2.54,
    dpcm: 1,
    dppx: 2.54 / 96.0
  },
  dppx: {
    dpi: 96,
    dpcm: 96.0 / 2.54,
    dppx: 1
  }
};
function convertUnits(value, sourceUnit, targetUnit, precision) {
  if (!conversions.hasOwnProperty(targetUnit)) throw new Error("Cannot convert to " + targetUnit);
  if (!conversions[targetUnit].hasOwnProperty(sourceUnit)) throw new Error("Cannot convert from " + sourceUnit + " to " + targetUnit);
  var converted = conversions[targetUnit][sourceUnit] * value;
  if (precision !== false) {
    precision = Math.pow(10, parseInt(precision) || 5);
    return Math.round(converted * precision) / precision;
  }
  return converted;
}

/* with love from shopstory */

function convertNodes(left, right, precision) {
  switch (left.type) {
    case "LengthValue":
    case "AngleValue":
    case "TimeValue":
    case "FrequencyValue":
    case "ResolutionValue":
      return convertAbsoluteLength(left, right, precision);
    default:
      return {
        left,
        right
      };
  }
}
function convertAbsoluteLength(left, right, precision) {
  if (right.type === left.type) {
    right = {
      type: left.type,
      value: convertUnits(right.value, right.unit, left.unit, precision),
      unit: left.unit
    };
  }
  return {
    left,
    right
  };
}

/* with love from shopstory */

function reduce(node, precision) {
  if (node.type === "MathExpression") return reduceMathExpression(node, precision);
  if (node.type === "Calc") return reduce(node.value, precision);
  return node;
}
function isEqual(left, right) {
  return left.type === right.type && left.value === right.value;
}
function isValueType(type) {
  switch (type) {
    case "LengthValue":
    case "AngleValue":
    case "TimeValue":
    case "FrequencyValue":
    case "ResolutionValue":
    case "EmValue":
    case "ExValue":
    case "ChValue":
    case "RemValue":
    case "VhValue":
    case "VwValue":
    case "VminValue":
    case "VmaxValue":
    case "PercentageValue":
    case "Value":
      return true;
  }
  return false;
}
function convertMathExpression(node, precision) {
  let nodes = convertNodes(node.left, node.right, precision);
  let left = reduce(nodes.left, precision);
  let right = reduce(nodes.right, precision);
  if (left.type === "MathExpression" && right.type === "MathExpression") {
    if (left.operator === "/" && right.operator === "*" || left.operator === "-" && right.operator === "+" || left.operator === "*" && right.operator === "/" || left.operator === "+" && right.operator === "-") {
      if (isEqual(left.right, right.right)) nodes = convertNodes(left.left, right.left, precision);else if (isEqual(left.right, right.left)) nodes = convertNodes(left.left, right.right, precision);
      left = reduce(nodes.left, precision);
      right = reduce(nodes.right, precision);
    }
  }
  node.left = left;
  node.right = right;
  return node;
}
function flip(operator) {
  return operator === "+" ? "-" : "+";
}
function flipValue(node) {
  if (isValueType(node.type)) node.value = -node.value;else if (node.type == "MathExpression") {
    node.left = flipValue(node.left);
    node.right = flipValue(node.right);
  }
  return node;
}
function reduceAddSubExpression(node, precision) {
  const {
    left,
    right,
    operator: op
  } = node;
  if (left.type === "CssVariable" || right.type === "CssVariable") return node;

  // something + 0 => something
  // something - 0 => something
  if (right.value === 0) return left;

  // 0 + something => something
  if (left.value === 0 && op === "+") return right;

  // 0 - something => -something
  if (left.value === 0 && op === "-") return flipValue(right);

  // value + value
  // value - value
  if (left.type === right.type && isValueType(left.type)) {
    node = Object.assign({}, left);
    if (op === "+") node.value = left.value + right.value;else node.value = left.value - right.value;
  }

  // value <op> (expr)
  if (isValueType(left.type) && (right.operator === "+" || right.operator === "-") && right.type === "MathExpression") {
    // value + (value + something) => (value + value) + something
    // value + (value - something) => (value + value) - something
    // value - (value + something) => (value - value) - something
    // value - (value - something) => (value - value) + something
    if (left.type === right.left.type) {
      node = Object.assign({}, node);
      node.left = reduce({
        type: "MathExpression",
        operator: op,
        left: left,
        right: right.left
      }, precision);
      node.right = right.right;
      node.operator = op === "-" ? flip(right.operator) : right.operator;
      return reduce(node, precision);
    }
    // value + (something + value) => (value + value) + something
    // value + (something - value) => (value - value) + something
    // value - (something + value) => (value - value) - something
    // value - (something - value) => (value + value) - something
    else if (left.type === right.right.type) {
      node = Object.assign({}, node);
      node.left = reduce({
        type: "MathExpression",
        operator: op === "-" ? flip(right.operator) : right.operator,
        left: left,
        right: right.right
      }, precision);
      node.right = right.left;
      return reduce(node, precision);
    }
  }

  // (expr) <op> value
  if (left.type === "MathExpression" && (left.operator === "+" || left.operator === "-") && isValueType(right.type)) {
    // (value + something) + value => (value + value) + something
    // (value - something) + value => (value + value) - something
    // (value + something) - value => (value - value) + something
    // (value - something) - value => (value - value) - something
    if (right.type === left.left.type) {
      node = Object.assign({}, left);
      node.left = reduce({
        type: "MathExpression",
        operator: op,
        left: left.left,
        right: right
      }, precision);
      return reduce(node, precision);
    }
    // (something + value) + value => something + (value + value)
    // (something - value1) + value2 => something - (value2 - value1)
    // (something + value) - value => something + (value - value)
    // (something - value) - value => something - (value + value)
    else if (right.type === left.right.type) {
      node = Object.assign({}, left);
      if (left.operator === "-") {
        node.right = reduce({
          type: "MathExpression",
          operator: op === "-" ? "+" : "-",
          left: right,
          right: left.right
        }, precision);
        node.operator = op === "-" ? "-" : "+";
      } else {
        node.right = reduce({
          type: "MathExpression",
          operator: op,
          left: left.right,
          right: right
        }, precision);
      }
      if (node.right.value < 0) {
        node.right.value *= -1;
        node.operator = node.operator === "-" ? "+" : "-";
      }
      return reduce(node, precision);
    }
  }
  return node;
}
function reduceDivisionExpression(node, precision) {
  if (!isValueType(node.right.type)) return node;
  if (node.right.type !== "Value") throw new Error(`Cannot divide by "${node.right.unit}", number expected`);
  if (node.right.value === 0) throw new Error("Cannot divide by zero");

  // (expr) / value
  if (node.left.type === "MathExpression") {
    if (isValueType(node.left.left.type) && isValueType(node.left.right.type)) {
      node.left.left.value /= node.right.value;
      node.left.right.value /= node.right.value;
      return reduce(node.left, precision);
    }
    return node;
  }
  // something / value
  else if (isValueType(node.left.type)) {
    node.left.value /= node.right.value;
    return node.left;
  }
  return node;
}
function reduceMultiplicationExpression(node) {
  // (expr) * value
  if (node.left.type === "MathExpression" && node.right.type === "Value") {
    if (isValueType(node.left.left.type) && isValueType(node.left.right.type)) {
      node.left.left.value *= node.right.value;
      node.left.right.value *= node.right.value;
      return node.left;
    }
  }
  // something * value
  else if (isValueType(node.left.type) && node.right.type === "Value") {
    node.left.value *= node.right.value;
    return node.left;
  }
  // value * (expr)
  else if (node.left.type === "Value" && node.right.type === "MathExpression") {
    if (isValueType(node.right.left.type) && isValueType(node.right.right.type)) {
      node.right.left.value *= node.left.value;
      node.right.right.value *= node.left.value;
      return node.right;
    }
  }
  // value * something
  else if (node.left.type === "Value" && isValueType(node.right.type)) {
    node.right.value *= node.left.value;
    return node.right;
  }
  return node;
}
function reduceMaxExpression(node) {
  if (node.left.type !== "LengthValue" || node.right.type !== "LengthValue") {
    throw new Error("Max function can be reduced only if types are LengthValue");
  }
  node.left.value = Math.max(node.left.value, node.right.value);
  return node.left;
}
function reduceMinExpression(node) {
  if (node.left.type !== "LengthValue" || node.right.type !== "LengthValue") {
    throw new Error("Min function can be reduced only if types are LengthValue");
  }
  node.left.value = Math.min(node.left.value, node.right.value);
  return node.left;
}
function reduceMathExpression(node, precision) {
  node = convertMathExpression(node, precision);
  switch (node.operator) {
    case "+":
    case "-":
      return reduceAddSubExpression(node, precision);
    case "/":
      return reduceDivisionExpression(node, precision);
    case "*":
      return reduceMultiplicationExpression(node);
    case "max":
      return reduceMaxExpression(node);
    case "min":
      return reduceMinExpression(node);
  }
  return node;
}

/* with love from shopstory */

const order = {
  "*": 0,
  "/": 0,
  "+": 1,
  "-": 1
};
function round(value, prec) {
  if (prec !== false) {
    const precision = Math.pow(10, prec);
    return Math.round(value * precision) / precision;
  }
  return value;
}
function stringify(node, prec) {
  switch (node.type) {
    case "MathExpression":
      {
        const {
          left,
          right,
          operator: op
        } = node;
        let str = "";
        if (left.type === "MathExpression" && order[op] < order[left.operator]) str += "(" + stringify(left, prec) + ")";else str += stringify(left, prec);
        str += " " + node.operator + " ";
        if (right.type === "MathExpression" && order[op] < order[right.operator]) {
          str += "(" + stringify(right, prec) + ")";
        } else if (right.type === "MathExpression" && op === "-" && ["+", "-"].includes(right.operator)) {
          // fix #52 : a-(b+c) = a-b-c
          right.operator = flip(right.operator);
          str += stringify(right, prec);
        } else {
          str += stringify(right, prec);
        }
        return str;
      }
    case "Value":
      return round(node.value, prec);
    case "CssVariable":
      if (node.fallback) {
        return `var(${node.value}, ${stringify(node.fallback, prec)})`;
      }
      return `var(${node.value})`;
    case "Calc":
      if (node.prefix) {
        return `-${node.prefix}-calc(${stringify(node.value, prec)})`;
      }
      return `calc(${stringify(node.value, prec)})`;
    default:
      return round(node.value, prec) + node.unit;
  }
}
function stringifier(calc, node, precision) {
  let str = stringify(node, precision);
  if (node.type === "MathExpression") {
    // if calc expression couldn't be resolved to a single value, re-wrap it as
    // a calc()
    str = calc + "(" + str + ")";
  }
  return str;
}

/* with love from shopstory */

const MATCH_CALC = /((?:\-[a-z]+\-)?calc)/;
function calculateAllViewportValues(ast, map) {
  if (typeof ast === "object" && ast !== null) {
    if (ast.type === "VwValue" && ast.unit === "vw" && typeof map.vw === "number") {
      return {
        type: "LengthValue",
        unit: "px",
        value: ast.value / 100 * map.vw
      };
    } else if (ast.type === "PercentageValue" && ast.unit === "%" && typeof map.percent === "number") {
      return {
        type: "LengthValue",
        unit: "px",
        value: ast.value / 100 * map.percent
      };
    } else {
      for (const key in ast) {
        if (typeof ast[key] === "object" && ast[key] !== null) {
          ast[key] = calculateAllViewportValues(ast[key], map);
        }
      }
    }
  }
  return ast;
}
function reduceCSSCalc(value) {
  let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
  let map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return valueParser(value).walk(node => {
    // skip anything which isn't a calc() function
    if (node.type !== "function" || !MATCH_CALC.test(node.value)) return;

    // stringify calc expression and produce an AST
    const contents = valueParser.stringify(node.nodes);

    // skip constant() and env()
    if (contents.indexOf("constant") >= 0 || contents.indexOf("env") >= 0) return;
    const ast = calculateAllViewportValues(parser_1.parser.parse(contents), map);

    // reduce AST to its simplest form, that is, either to a single value
    // or a simplified calc expression
    const reducedAst = reduce(ast, precision);

    // stringify AST and write it back
    node.type = "word";
    node.value = stringifier(node.value, reducedAst, precision);
  }, true).toString();
}

/* with love from shopstory */

function parseSpacing(spacing) {
  if (spacing.endsWith("px")) {
    const value = parseFloat(spacing);
    if (isNaN(value)) {
      throw new Error(`incorrect spacing: ${spacing}`);
    }
    return {
      unit: "px",
      value
    };
  }
  if (spacing.endsWith("vw")) {
    const value = parseFloat(spacing);
    if (isNaN(value)) {
      throw new Error(`incorrect spacing: ${spacing}`);
    }
    return {
      unit: "vw",
      value
    };
  }
  throw new Error(`incorrect spacing: ${spacing}.`);
}
function spacingToPx(spacing, width) {
  const reducedSpacing = reduceCSSCalc(`calc(${spacing})` /* wrapping calc is necessary, otherwise max(10px,20px) doesn't work */, 5, {
    vw: width,
    percent: width
  });
  const parsed = parseSpacing(reducedSpacing);
  if (parsed.unit === "px") {
    return parsed.value;
  }
  throw new Error(`Error while running spacingToPx for spacing: ${spacing} and width: ${width}`);
}

/* with love from shopstory */
function areWidthsFullyDefined(widths, devices) {
  let areWidthsFullyDefined = true;
  devices.forEach(device => {
    if (widths[device.id] === -1) {
      areWidthsFullyDefined = false;
    }
  });
  return areWidthsFullyDefined;
}

/* with love from shopstory */

function linearizeSpace(input, compilationContext, widths) {
  let constant = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  if (!isTrulyResponsiveValue$1(input)) {
    return input;
  }

  /**
   *
   * Important!
   *
   * Although linearizeSpace takes widths into account (it's obvious) we must still remember about responsive tokens.
   *
   * Responsive tokens will be quite rare (like a container margin or a font size).
   * But still we must remember that responsive tokens are defined relative to SCREEN WIDTH.
   * It means that even if our component has "width" that is not a screen width and is very irregular, then responsive tokens relative to screen width takes precedence!
   * So if our component has width 500px on XL and is wider on smaller breakpoint LG (800px), then if responsive token is bigger on XL than LG it will still hold.
   * It makes a total sense. If we broke this rule and somehow applied widths to responsive tokens, then user could see a font that she totally doesn't want for a specific breakpoint.
   * It usually won't hurt at all, because fonts and container margins are responsive by nature. Actually maybe other spacings shouldn't be possible to be responsive at all!
   * That's why first thing below is to fill undefined values with responsive tokens if possible and only then linearize the remaining ones (with widths taken into account).
   *
   */

  // If responsive value has some token that is responsive, then this token should be applied to all surrounding breakpoints.
  // Responsive token kind of "overrides auto".
  // If we want in the future auto for responsive tokens it's not the place for it. Linearizing tokens should happen in creating compilation context.
  const inputAfterResponsiveTokenAuto = applyAutoUsingResponsiveTokens(input, compilationContext);
  const inputWithScalarNonRefValues = {
    $res: true
  };
  compilationContext.devices.forEach(device => {
    if (inputAfterResponsiveTokenAuto[device.id] === undefined) {
      return;
    }
    const refValue = responsiveValueGetDefinedValue(inputAfterResponsiveTokenAuto, device.id, compilationContext.devices, getDevicesWidths(compilationContext.devices));
    if (isTrulyResponsiveValue$1(refValue.value)) {
      inputWithScalarNonRefValues[device.id] = spacingToPx(responsiveValueGetDefinedValue(refValue.value, device.id, compilationContext.devices, getDevicesWidths(compilationContext.devices)), device.w);
    } else {
      inputWithScalarNonRefValues[device.id] = spacingToPx(refValue.value, device.w);
    }
  });
  if (!areWidthsFullyDefined(widths, compilationContext.devices)) {
    return responsiveValueFill(inputAfterResponsiveTokenAuto, compilationContext.devices, getDevicesWidths(compilationContext.devices));
  }

  // Let's run linearize function
  const linearisedCompiledValues = linearizeSpaceWithoutNesting(inputWithScalarNonRefValues, compilationContext, widths, constant);
  compilationContext.devices.forEach(device => {
    if (inputAfterResponsiveTokenAuto[device.id] === undefined) {
      inputAfterResponsiveTokenAuto[device.id] = snapValueToToken(responsiveValueForceGet(linearisedCompiledValues, device.id), responsiveValueGetFirstLowerValue(inputWithScalarNonRefValues, device.id, compilationContext.devices, getDevicesWidths(compilationContext.devices)), responsiveValueGetFirstHigherValue(inputWithScalarNonRefValues, device.id, compilationContext.devices, getDevicesWidths(compilationContext.devices)), compilationContext.theme.space, constant);
    }
  });
  return inputAfterResponsiveTokenAuto;
}
function snapValueToToken(value, lowerDefinedValue, higherDefinedValue, spaces, constant) {
  let currentToken = undefined;
  let minDelta = Number.MAX_VALUE;
  for (const tokenId in spaces) {
    const tokenValue = spaces[tokenId].value;
    if (isTrulyResponsiveValue$1(tokenValue)) {
      // only non-responsive
      continue;
    }
    const parsedValue = parseSpacing(tokenValue);
    if (parsedValue.unit === "vw") {
      continue;
    }
    const tokenPxValue = parsedValue.value;

    // If value smaller than constant then the only possible token is the token equaling the value
    if (value <= constant && tokenPxValue !== value) {
      continue;
    }

    // token value must be within higher and lower limits
    if (higherDefinedValue !== undefined) {
      if (tokenPxValue > higherDefinedValue) {
        continue;
      }
    }
    if (lowerDefinedValue !== undefined) {
      if (tokenPxValue < lowerDefinedValue) {
        continue;
      }
    }
    if (tokenId.split(".").length > 1) {
      // only non-prefixed
      continue;
    }

    // snapped token can never be bigger than our constant
    if (tokenPxValue < constant) {
      continue;
    }
    const delta = Math.abs(value - tokenPxValue);
    if (delta < minDelta || (/* in case of equal deltas, let's take bigger token */currentToken && delta === minDelta && tokenValue > currentToken.value)) {
      minDelta = delta;
      currentToken = {
        tokenId,
        value: tokenValue,
        widgetId: "@easyblocks/space"
      };
    }
  }
  if (!currentToken) {
    return {
      value: `${value}px`
    };
  }
  return currentToken;
}
function linearizeSpaceWithoutNesting(input, compilationContext, widths) {
  let constant = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  if (!isTrulyResponsiveValue$1(input)) {
    return input;
  }

  // // If only 1 value is defined (2 keys, $res and value), then we return
  // if (Object.keys(input).length === 2) {
  //   return responsiveValueFill(input, compilationContext.devices);
  // }

  // Empty object returns 0
  if (Object.keys(input).length === 0) {
    console.warn("linearize Space - empty object input, that shouldn't happen, fallback to 0");
    return 0;
  }

  // For now we just use arrays (from previous implementation). Later they're mapped back to object
  const value = [];
  const referencePoints = [];
  const componentWidths = getDeviceWidthPairs(widths, compilationContext.devices);
  componentWidths.forEach((componentWidth, index) => {
    const breakpointValue = input[componentWidth.deviceId];
    value[index] = breakpointValue;
    if (breakpointValue === null || breakpointValue === undefined) {
      value[index] = null; // null padding and normalization

      let leftIndex;
      let rightIndex;

      // Let's find closest left index
      for (let i = index - 1; i >= 0; i--) {
        const val = input[componentWidths[i].deviceId];
        if (val !== undefined) {
          leftIndex = i;
          break;
        }
      }

      // Let's find closest right index
      for (let i = index + 1; i < componentWidths.length; i++) {
        const val = input[componentWidths[i].deviceId];
        if (val !== undefined) {
          rightIndex = i;
          break;
        }
      }
      if (leftIndex === undefined && rightIndex === undefined) {
        throw new Error("unreachable");
      }
      referencePoints[index] = {
        leftIndex,
        rightIndex
      };
      return;
    }
  });
  referencePoints.forEach((refPoint, index) => {
    if (!refPoint) {
      return;
    }
    const currentX = componentWidths[index].width;

    // Single point linearity
    if (refPoint.leftIndex !== undefined && refPoint.rightIndex === undefined || refPoint.leftIndex === undefined && refPoint.rightIndex !== undefined) {
      const currentRefPoint = refPoint.leftIndex ?? refPoint.rightIndex;
      const refY = value[currentRefPoint];
      const refX = componentWidths[currentRefPoint].width;
      const deltaY = refY - constant;
      if (deltaY <= 0) {
        value[index] = refY;
      } else {
        const a = (refY - constant) / refX;
        value[index] = a * currentX + constant;
      }
    } else if (refPoint.leftIndex !== undefined && refPoint.rightIndex !== undefined) {
      const p1_x = componentWidths[refPoint.leftIndex].width;
      const p1_y = value[refPoint.leftIndex];

      // default a, b (enabled when only p1 is defined)
      let a = 0,
        b = p1_y;
      const p2_x = componentWidths[refPoint.rightIndex].width;
      const p2_y = value[refPoint.rightIndex];
      const deltaX = p1_x - p2_x;
      if (deltaX === 0) {
        // if delta 0 then we take lower for left and higher for right
        value[index] = index < refPoint.leftIndex ? p1_y : p2_y;
      } else {
        a = (p1_y - p2_y) / deltaX;
        b = p2_y - a * p2_x;
        if (a >= 0) {
          // take into account 0 values!!!
          if (p1_y === 0 || p2_y === 0) {
            if (index < refPoint.leftIndex) {
              a = 0;
              b = p1_y;
            } else {
              a = 0;
              b = p2_y;
            }
          }
          value[index] = currentX * a + b;
        } else {
          // We don't linearize descending functions!
          value[index] = index < refPoint.leftIndex ? p1_y : p2_y;
        }
      }
    } else {
      throw new Error("unreachable");
    }
  });
  const output = {
    $res: true
  };
  value.forEach((scalarVal, index) => {
    if (scalarVal === undefined || scalarVal === null) {
      return;
    }
    output[componentWidths[index].deviceId] = scalarVal;
  });
  return output;
}

/* with love from shopstory */

function responsiveValueNormalize(arg, devices) {
  if (!isTrulyResponsiveValue$1(arg)) {
    return arg;
  }
  let previousVal = undefined;
  const ret = {
    $res: true
  };
  let numberOfDefinedValues = 0;
  for (let i = devices.length - 1; i >= 0; i--) {
    const breakpoint = devices[i].id;
    const val = arg[breakpoint];

    // TODO: if values are objects, it's to do
    if (typeof val === "object" && val !== null) {
      if (JSON.stringify(val) !== JSON.stringify(previousVal)) {
        ret[breakpoint] = val;
        previousVal = val;
        numberOfDefinedValues++;
      }
    } else {
      if (val !== undefined && val !== previousVal) {
        ret[breakpoint] = val;
        previousVal = val;
        numberOfDefinedValues++;
      }
    }

    // [x, null, null, y] => [x, y]
    if (i < devices.length - 1) {
      const nextBreakpoint = devices[i + 1].id;
      if (numberOfDefinedValues === 1 && ret[breakpoint] === undefined && ret[nextBreakpoint] !== undefined) {
        ret[breakpoint] = ret[nextBreakpoint];
        delete ret[nextBreakpoint];
      }
    }
  }
  if (numberOfDefinedValues === 1) {
    return ret[devices[0].id];
  }
  return ret;
}

/* with love from shopstory */

/**
 *  Input like: { breakpoint1: sth, breakpoint2: sth, breakpoint3: sth, ... }
 */
function squashCSSResults(scalarValues, devices, disableNesting) {
  // Let's check whether scalarValues represent object (for nesting) or a scalar value.
  let objectsNum = 0;
  let noObjectsNum = 0;
  let arraysNum = 0;
  for (const breakpointName in scalarValues) {
    const val = scalarValues[breakpointName];
    if (Array.isArray(val) && !disableNesting) {
      arraysNum++;
    } else if (typeof val === "object" && val !== null && !Array.isArray(val) && !disableNesting) {
      objectsNum++;
    } else if (val !== null && val !== undefined) {
      noObjectsNum++;
    }
  }

  // Only one flag can be > 0!!! Otherwise breakpoints return incompatible types
  if (objectsNum > 0 && (noObjectsNum > 0 || arraysNum > 0) || arraysNum > 0 && (noObjectsNum > 0 || objectsNum > 0) || noObjectsNum > 0 && (arraysNum > 0 || objectsNum > 0)) {
    throw new Error("This shouldn't happen. Mismatched types for different breakpoints!!!");
  }
  if (arraysNum > 0) {
    let biggestArrayLength = 0;
    for (const breakpoint in scalarValues) {
      biggestArrayLength = Math.max(biggestArrayLength, scalarValues[breakpoint].length); // {...allKeysObject, ...scalarValues[breakpoint]};
    }
    const ret = [];
    for (let i = 0; i < biggestArrayLength; i++) {
      const newScalarValues = {};
      for (const breakpoint in scalarValues) {
        let value = undefined;
        if (scalarValues[breakpoint]) {
          value = scalarValues[breakpoint][i];
        }
        newScalarValues[breakpoint] = value;
      }
      ret[i] = squashCSSResults(newScalarValues, devices);
    }
    return ret;
  }

  // If object -> recursion
  if (objectsNum > 0) {
    // allKeys is the object that has all the keys from all the scalar configs
    let allKeysObject = {};

    /**
     * Scalar values are like:
     *
     * {
     *    b1: { a: 10, b: 20 }
     *    b2: { a: 100, c: 300 }
     * }
     */

    for (const breakpoint in scalarValues) {
      allKeysObject = {
        ...allKeysObject,
        ...scalarValues[breakpoint]
      };
    }

    // scalarValues.forEach(scalarConfig => {
    //     allKeysObject = {...allKeysObject, ...scalarConfig};
    // });

    const allKeys = Object.keys(allKeysObject);
    const ret = {};

    /**
     * All keys are like: ['a', 'b', 'c']
     *
     * All used keys across all breakpoints
     */

    allKeys.forEach(key => {
      const newScalarValues = {};
      for (const breakpoint in scalarValues) {
        let value = undefined;
        if (scalarValues[breakpoint]) {
          value = scalarValues[breakpoint][key];
        }
        newScalarValues[breakpoint] = value;
      }
      /**
       * newScalarValues values are like:
       *
       * For key 'a':
       * {
       *      b1: 10,
       *      b2: 100
       * }
       *
       * For key 'b':
       * {
       *     b1: 20,
       *     b2: undefined
       * }
       *
       */

      /**
       * For fonts we don't want nesting + recursion. We want entire object to be passed to results.
       *
       * Later, renderer must know how to render xfont property :)
       *
       * Otherwise, media query conflicts arise and bad values are set.
       */
      ret[key] = squashCSSResults(newScalarValues, devices, key === "xfont");
    });
    return ret;
  }

  // Here we are sure we have scalar value, not some object to be nested. We must do 2 things:
  // - add "unset" instead of null / undefined
  // - create ResponsiveValue and normalize

  for (const key in scalarValues) {
    if (scalarValues[key] === undefined || scalarValues[key] === null) {
      scalarValues[key] = "unset";
    }
  }

  // Values (non-objects -> no nesting)
  return responsiveValueNormalize({
    ...scalarValues,
    $res: true
  }, devices);
}
function scalarizeNonComponentProp(value, breakpoint, schemaProp) {
  if (schemaProp) {
    // This function should never be called with component type
    if (schemaProp.type.startsWith("component")) {
      throw new Error("unreachable");
    }

    // Text values aren't responsive
    if (schemaProp.type === "text") {
      return value;
    }

    // other props are potentially responsive, so let's run responsiveValueGet
    return responsiveValueForceGet(value, breakpoint);
  }

  // for context props we just treat them as responsive
  return responsiveValueForceGet(value, breakpoint);
}
function scalarizeCollection(configs, breakpoint, devices, itemFieldsSchema) {
  return configs.map(child => {
    const scalarizedChild = {
      ...child
    };
    for (const [key, value] of Object.entries(scalarizedChild)) {
      const schemaProp = itemFieldsSchema.find(itemFieldSchemaProp => {
        return itemFieldSchemaProp.prop === key;
      });
      if (schemaProp) {
        scalarizedChild[schemaProp.prop] = scalarizeNonComponentProp(value, breakpoint, schemaProp);
      } else {
        scalarizedChild[key] = scalarizeNonComponentProp(value, breakpoint);
      }
    }
    return scalarizedChild;
  });
}
function scalarizeConfig(config, breakpoint, devices, schema) {
  const ret = {};

  /**
   * There is a bit of chaos here. To understand what is happening, we must know what "Config" is in context of resop.
   *
   * Config is not a "real" config we're using in the Shopstory in almost all places. We're dealing here with "intermediate compiled config" used during compilation. What it means:
   * 1. It has _component, _id, etc.
   * 2. All the props from schema that are *not* components are compiled and are available.
   * 3. All the props from schema that are components have only _component and _id (exception below)
   * 4. component-collections has child Configs that have item props that are also compiled and are added *to the root level of the config*. They're simply context props. (IMPORTANT! -> localised is already non-localised ;p)
   * 5. context props from compilation are also added to the config.
   *
   * PROBLEM:
   *
   * As long as we know the component "own props" (we have schema) and item props, we have no idea about context props types. It means that we can only blindly apply responsiveValueGet on them.
   *
   * SOLUTION:
   *
   * context props should be typed. Each editable component should have schema of own props and of context props.
   *
   */
  for (const prop in config) {
    const schemaProp = schema.find(x => x.prop === prop);

    // If schemaProp is defined, it means "own prop". Otherwise it must be a context prop (they're not "typed" yet and we don't have any information what types of context props we have)
    if (schemaProp) {
      // subcomponents don't get scalarized
      if (isSchemaPropComponent(schemaProp)) {
        ret[prop] = config[prop];
      }
      // component collection should have item props scalarized. We know the types of item props!
      // component collection localised is already dealing with value that is NON-LOCALISED (it was flattened earlier)
      else if (isSchemaPropCollection(schemaProp)) {
        ret[prop] = scalarizeCollection(config[prop], breakpoint, devices, schemaProp.itemFields || []);
      } else {
        ret[prop] = scalarizeNonComponentProp(config[prop], breakpoint, schemaProp);
      }
    } else {
      // context props automatically get scalarized
      ret[prop] = scalarizeNonComponentProp(config[prop], breakpoint);
    }
  }
  return ret;
}
function getUndefinedBreakpoints(resVal, devices) {
  const undefinedBreakpoints = [];
  devices.forEach(device => {
    if (resVal[device.id] === undefined) {
      undefinedBreakpoints.push(device.id);
    }
  });
  return undefinedBreakpoints;
}
function hasDefinedBreakpoints(resVal, devices) {
  const undefinedBreakpoints = getUndefinedBreakpoints(resVal, devices);
  return undefinedBreakpoints.length < devices.length;
}
function resop2(input, callback, devices, componentDefinition) {
  const schema = componentDefinition?.schema ?? [];

  // Decompose config into scalar configs
  const scalarInputs = {};
  devices.forEach(device => {
    scalarInputs[device.id] = {
      params: scalarizeConfig(input.params, device.id, devices, []),
      values: scalarizeConfig(input.values, device.id, devices, schema)
    };
  });
  const scalarOutputs = {};

  // run callback for scalar configs
  devices.forEach(device => {
    scalarOutputs[device.id] = callback(scalarInputs[device.id], device.id);
  });

  /**
   * Let's first squash all __props, components and item props
   */

  const componentPropNames = {};
  const componentItemPropsNamesAndLength = {};
  const propNames = new Set();

  // Let's add keys
  schema.forEach(schemaProp => {
    if (isSchemaPropComponentOrComponentCollection(schemaProp)) {
      componentPropNames[schemaProp.prop] = new Set();
    }
    if (isSchemaPropCollection(schemaProp)) {
      componentItemPropsNamesAndLength[schemaProp.prop] = {
        lengths: new Set(),
        names: new Set()
      };
    }
  });

  // Let's find all output prop names
  devices.forEach(device => {
    // prop names
    const propsObject = scalarOutputs[device.id].props ?? {};
    if (typeof propsObject !== "object" || propsObject === null) {
      throw new Error(`__props must be object, it is not for breakpoint: ${device.id}`);
    }
    for (const propName in propsObject) {
      propNames.add(propName);
    }

    // component prop names
    schema.forEach(schemaProp => {
      if (isSchemaPropComponentOrComponentCollection(schemaProp)) {
        const componentObject = scalarOutputs[device.id].components?.[schemaProp.prop] ?? {};
        if (typeof componentObject !== "object" || componentObject === null) {
          throw new Error(`resop error: component must be undefined or an object, it is not for device ${device.id} and prop ${schemaProp.prop}. Template: ${componentDefinition?.id}`);
        }
        for (const key in componentObject) {
          if (key === "itemProps") {
            continue;
          }
          componentPropNames[schemaProp.prop].add(key);
        }
        if (isSchemaPropCollection(schemaProp)) {
          const itemPropsArray = componentObject.itemProps ?? [];
          if (!Array.isArray(itemPropsArray)) {
            throw new Error(`resop error: item props must be undefined or an array (${schemaProp.prop}). Template: ${componentDefinition?.id}`);
          }
          itemPropsArray.forEach((itemObject, index) => {
            if (typeof itemObject !== "object" || itemObject === null) {
              throw new Error(`resop error: item in itemProps array must be object (${schemaProp.prop}.itemProps.${index}). Template: ${componentDefinition?.id}`);
            }
            for (const key in itemObject) {
              componentItemPropsNamesAndLength[schemaProp.prop].names.add(key);
            }
          });
          componentItemPropsNamesAndLength[schemaProp.prop].lengths.add(itemPropsArray.length);
        }
      }
    });
  });

  // Let's verify array lengths
  for (const componentName in componentItemPropsNamesAndLength) {
    const lengths = componentItemPropsNamesAndLength[componentName].lengths;
    if (lengths.size > 1) {
      throw new Error(`resop: incompatible item props arrays length for component: ${componentName}. Template: ${componentDefinition?.id}`);
    }
    const length = Array.from(lengths)[0];

    // If non-zero length, then there are extra requirements
    if (length > 0) {
      const itemsLength = input.values[componentName].length;
      if (itemsLength === 0 ? length > 1 : itemsLength !== length) {
        throw new Error(`resop: item props arrays length incompatible with items length for component: ${componentName}. Template: ${componentDefinition?.id}`);
      }
    }
  }

  // Let's compress
  const output = {
    props: {},
    components: {},
    styled: {}
  };

  // squash props
  propNames.forEach(propName => {
    const squashedValue = {
      $res: true
    };
    devices.forEach(device => {
      squashedValue[device.id] = scalarOutputs[device.id]?.props?.[propName];
    });
    if (hasDefinedBreakpoints(squashedValue, devices)) {
      const undefinedBreakpoints = getUndefinedBreakpoints(squashedValue, devices);
      if (undefinedBreakpoints.length > 0) {
        throw new Error(`resop: undefined value (breakpoints: ${undefinedBreakpoints}) for __props.${propName}. Template: ${componentDefinition?.id}`);
      }
      output.props[propName] = responsiveValueNormalize(squashedValue, devices); // props should be normalized
    }
  });

  // Squash components
  for (const componentName in componentPropNames) {
    output.components[componentName] = {};
    componentPropNames[componentName].forEach(componentPropName => {
      const squashedValue = {
        $res: true
      };
      devices.forEach(device => {
        squashedValue[device.id] = scalarOutputs[device.id].components?.[componentName]?.[componentPropName];
      });
      if (hasDefinedBreakpoints(squashedValue, devices)) {
        const undefinedBreakpoints = getUndefinedBreakpoints(squashedValue, devices);
        if (undefinedBreakpoints.length > 0) {
          throw new Error(`resop: undefined value (breakpoints ${undefinedBreakpoints}) for ${componentName}.${componentPropName}. Template: ${componentDefinition?.id}`);
        }
        output.components[componentName][componentPropName] = squashedValue;
      }
    });
  }

  // Squash item props
  for (const componentName in componentItemPropsNamesAndLength) {
    output.components[componentName].itemProps = [];
    const length = Array.from(componentItemPropsNamesAndLength[componentName].lengths)[0];
    for (let i = 0; i < length; i++) {
      output.components[componentName].itemProps[i] = {};
      componentItemPropsNamesAndLength[componentName].names.forEach(itemPropName => {
        const squashedValue = {
          $res: true
        };
        devices.forEach(device => {
          squashedValue[device.id] = scalarOutputs[device.id].components?.[componentName]?.itemProps?.[i]?.[itemPropName];
        });
        if (hasDefinedBreakpoints(squashedValue, devices)) {
          const undefinedBreakpoints = getUndefinedBreakpoints(squashedValue, devices);
          if (undefinedBreakpoints.length > 0) {
            throw new Error(`resop: undefined value (breakpoints ${undefinedBreakpoints}) for ${componentName}.${i}.${itemPropName}. Template: ${componentDefinition?.id}`);
          }
          output.components[componentName].itemProps[i][itemPropName] = squashedValue;
        }
      });
    }
  }
  const styledOnlyScalarOutputs = Object.fromEntries(Object.entries(scalarOutputs).map(_ref => {
    let [deviceId, result] = _ref;
    return [deviceId, result.styled];
  }));
  output.styled = squashCSSResults(styledOnlyScalarOutputs, devices);
  return output;
}

/* with love from shopstory */
function assertDefined$1(value, message) {
  if (value === undefined) {
    throw new Error(message ?? "Value is undefined");
  }
  return value;
}

/* with love from shopstory */

function getCommonFieldProps(schemaProp) {
  const label = schemaProp.label || schemaProp.prop;
  const group = schemaProp.group || "Properties";
  return {
    label,
    name: schemaProp.prop,
    group,
    schemaProp,
    description: schemaProp.description,
    isLabelHidden: schemaProp.isLabelHidden,
    layout: schemaProp.layout,
    params: "params" in schemaProp ? schemaProp.params : undefined
  };
}
const tinaFieldProviders = {
  text: (schemaProp, _, value) => {
    if (!isValueLocalTextReference(value) && typeof value !== "string") {
      return {
        ...getCommonFieldProps(schemaProp),
        component: "external"
      };
    }
    return {
      ...getCommonFieldProps(schemaProp),
      component: "text",
      name: schemaProp.prop,
      normalize: schemaProp.normalize
    };
  },
  number: schemaProp => {
    return {
      ...getCommonFieldProps(schemaProp),
      component: "number",
      step: 1,
      min: schemaProp.params?.min,
      max: schemaProp.params?.max
    };
  },
  string: schemaProp => {
    if (schemaProp.responsive) {
      return {
        ...getCommonFieldProps(schemaProp),
        component: "responsive2",
        subComponent: "text",
        normalize: schemaProp.params?.normalize
      };
    }
    return {
      ...getCommonFieldProps(schemaProp),
      component: "text",
      normalize: schemaProp.params?.normalize
    };
  },
  boolean: schemaProp => {
    if (schemaProp.responsive) {
      return {
        ...getCommonFieldProps(schemaProp),
        component: "responsive2",
        subComponent: "toggle"
      };
    }
    return {
      ...getCommonFieldProps(schemaProp),
      component: "toggle"
    };
  },
  select: schemaProp => {
    if (schemaProp.responsive) {
      return {
        ...getCommonFieldProps(schemaProp),
        component: "responsive2",
        subComponent: "select",
        options: schemaProp.params.options
      };
    }
    return {
      ...getCommonFieldProps(schemaProp),
      component: "select",
      options: schemaProp.params.options
    };
  },
  "radio-group": schemaProp => {
    if (schemaProp.responsive) {
      return {
        ...getCommonFieldProps(schemaProp),
        component: "responsive2",
        subComponent: "radio-group",
        options: schemaProp.params.options
      };
    }
    return {
      ...getCommonFieldProps(schemaProp),
      component: "radio-group",
      options: schemaProp.params.options
    };
  },
  component: schemaProp => {
    return {
      ...getCommonFieldProps(schemaProp),
      component: "block",
      schemaProp
    };
  },
  "component-collection": () => {
    throw new Error("component-collection is not yet supported in sidebar");
  },
  "component-collection-localised": () => {
    throw new Error("component-collection-localised is not yet supported in sidebar");
  },
  component$$$: schemaProp => {
    return {
      ...getCommonFieldProps(schemaProp),
      component: "identity",
      schemaProp
    };
  },
  external: (schemaProp, editorContext) => {
    const externalTypeDefinition = editorContext.types[schemaProp.type];
    if (!externalTypeDefinition) {
      throw new Error(`Can't find definition for type "${schemaProp.type}"`);
    }
    if (schemaProp.responsive) {
      return {
        ...getCommonFieldProps(schemaProp),
        component: "responsive2",
        subComponent: "external"
      };
    }
    return {
      ...getCommonFieldProps(schemaProp),
      component: "external"
    };
  },
  position: schemaProp => {
    return {
      ...getCommonFieldProps(schemaProp),
      component: "responsive2",
      subComponent: "position"
    };
  },
  custom: (schemaProp, editorContext, value) => {
    const customTypeDefinition = editorContext.types[schemaProp.type];
    if (!customTypeDefinition) {
      throw new Error(`Can't find definition for type "${schemaProp.type}"`);
    }
    if (customTypeDefinition.type === "external") {
      return tinaFieldProviders.external(schemaProp, editorContext, value);
    }
    if (customTypeDefinition.type === "token") {
      let tokens = assertDefined$1(editorContext.theme[customTypeDefinition.token], `Missing token values within the Easyblocks config for "${customTypeDefinition.token}"`);
      if ("params" in schemaProp && schemaProp.params && "prefix" in schemaProp.params && typeof schemaProp.params.prefix === "string") {
        // Copy tokens to prevent mutating original tokens
        tokens = {
          ...tokens
        };
        for (const key in tokens) {
          if (!key.startsWith(schemaProp.params.prefix + ".")) {
            delete tokens[key];
          } else {
            tokens[key] = {
              ...tokens[key],
              label: key.split(`${schemaProp.params.prefix}.`)[1]
            };
          }
        }
      }
      const commonTokenFieldProps = {
        tokens,
        allowCustom: !!customTypeDefinition.allowCustom,
        extraValues: "params" in schemaProp && schemaProp.params && "extraValues" in schemaProp.params ? schemaProp.params.extraValues : undefined
      };
      if (customTypeDefinition.responsiveness === "never") {
        return {
          ...getCommonFieldProps(schemaProp),
          component: "token",
          ...commonTokenFieldProps
        };
      }
      return {
        ...getCommonFieldProps(schemaProp),
        // Token fields are always responsive
        component: "responsive2",
        subComponent: "token",
        ...commonTokenFieldProps
      };
    }
    return {
      ...getCommonFieldProps(schemaProp),
      ...(customTypeDefinition.responsiveness === "always" || customTypeDefinition.responsiveness === "optional" && schemaProp.responsive ? {
        component: "responsive2",
        subComponent: "local"
      } : {
        component: "local"
      })
    };
  }
};
function getTinaField(schemaProp, editorContext, value) {
  const fieldProvider = editorContext.types[schemaProp.type] && schemaProp.type !== "text" ? tinaFieldProviders.custom : tinaFieldProviders[schemaProp.type];
  return fieldProvider(schemaProp, editorContext, value);
}
function isValueLocalTextReference(value) {
  if (!(typeof value === "object" && value !== null)) {
    return false;
  }
  if (!("id" in value && typeof value.id === "string" && value.id.startsWith("local."))) {
    return false;
  }
  if (!("value" in value)) {
    return false;
  }
  if (!("widgetId" in value && typeof value.widgetId === "string" && value.widgetId === "@easyblocks/local-text")) {
    return false;
  }
  return true;
}

/* with love from shopstory */
/**
 * Because of how `TrulyResponsiveValue` is typed, if we try to access value at the current breakpoint it would return `true | T | undefined`.
 * The literal type `true` in this type shouldn't be included, because it makes no sense.
 * This comes from definition of `$res` property which is a special property that marks given object as responsive value instead of normal object.
 */
function responsiveValueAt(responsiveValue, breakpointIndex) {
  if (breakpointIndex === "$res") {
    throw new Error("This situation isn't possible! Value of responsive value must be accessed by valid breakpoint name");
  }
  const breakpointValue = responsiveValue[breakpointIndex];
  return breakpointValue;
}

/* with love from shopstory */
function bubbleDown(matcher, items) {
  const originalOrder = [];
  const bubbledDown = [];
  items.forEach(item => {
    if (matcher(item)) {
      bubbledDown.push(item);
    } else {
      originalOrder.push(item);
    }
  });
  return [...originalOrder, ...bubbledDown];
}

/* with love from shopstory */
function raiseError(errorMessage) {
  throw new Error(errorMessage);
}

/* with love from shopstory */

function compileComponent(editableElement, compilationContext, contextProps,
// contextProps are already compiled! They're result of compilation function.
meta, cache, parentComponentEditingInfo) {
  let configPrefix = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : "";
  if (!isComponentConfig(editableElement)) {
    console.error("[compile] wrong input for compileComponent", editableElement);
    throw new Error("[compile] wrong input for compileComponent");
  }
  if (contextProps.$width === undefined || contextProps.$width === -1) {
    throw new Error(`assertion failed: incorrect $width in compileComponent: ${contextProps.$width}, component: ${editableElement._id}, ${editableElement._component}`);
  }
  const cachedResult = cache.get(editableElement._id);
  let componentDefinition = findComponentDefinitionById(editableElement._component, compilationContext);
  if (!componentDefinition) {
    componentDefinition = assertDefined$1(findComponentDefinitionById("@easyblocks/missing-component", compilationContext));
    const error = `Easyblocks can’t find definition for component "${editableElement._component}" in your config. Please contact your developers to resolve this issue.`;
    editableElement = {
      _component: componentDefinition.id,
      _id: uniqueId$1(),
      error
    };
    console.warn(error);
    parentComponentEditingInfo = undefined;
  }
  const ownProps = createOwnComponentProps({
    config: editableElement,
    contextProps,
    componentDefinition,
    compilationContext
  });
  let hasComponentConfigChanged = true;
  let ownPropsAfterAuto;
  let compiled = {
    _component: editableElement._component,
    _id: editableElement._id,
    props: {},
    components: {},
    styled: {}
  };
  let configAfterAuto;
  let editingInfo;
  let compiledValues = {};
  let subcomponentsContextProps = {};
  let editingContextProps;
  if (cachedResult) {
    hasComponentConfigChanged = !deepCompare$1(ownProps, cachedResult.values);
    if (!hasComponentConfigChanged) {
      ownPropsAfterAuto = cachedResult.valuesAfterAuto;
      compiledValues = cachedResult.compiledValues;
      compiled = cachedResult.compiledConfig;
      configAfterAuto = deepClone$1({
        ...cachedResult.valuesAfterAuto.values,
        ...cachedResult.valuesAfterAuto.params
      });
      subcomponentsContextProps = cachedResult.contextProps;
      editingContextProps = cachedResult.editingContextProps;
    }
  }
  addComponentToSerializedComponentDefinitions(editableElement, meta, "components", compilationContext);
  const {
    $width,
    $widthAuto
  } = calculateWidths(compilationContext, contextProps);
  if (hasComponentConfigChanged) {
    // We are going to mutate this object so let's disconnect it from its source object
    ownPropsAfterAuto = deepClone$1(ownProps);

    /**
     * APPLY AUTO
     */

    const DEFAULT_SPACE_AUTO_CONSTANT = 16;

    // linearize space
    componentDefinition.schema.forEach(schemaProp => {
      if (isSchemaPropTokenized(schemaProp)) {
        ownPropsAfterAuto.values[schemaProp.prop] = applyAutoUsingResponsiveTokens(ownPropsAfterAuto.values[schemaProp.prop], compilationContext);
      }
      if (schemaProp.type === "space") {
        ownPropsAfterAuto.values[schemaProp.prop] = linearizeSpace(ownPropsAfterAuto.values[schemaProp.prop], compilationContext, $width, schemaProp.params?.autoConstant ?? DEFAULT_SPACE_AUTO_CONSTANT);
      }
    });
    itemFieldsForEach(ownPropsAfterAuto.values, compilationContext, arg => {
      let value = arg.itemPropValue;
      if (isSchemaPropTokenized(arg.itemSchemaProp)) {
        value = applyAutoUsingResponsiveTokens(value, compilationContext);
      }
      if (arg.itemSchemaProp.type === "space") {
        value = linearizeSpace(value, compilationContext, $width, arg.itemSchemaProp.params?.autoConstant ?? DEFAULT_SPACE_AUTO_CONSTANT);
      }
      dotNotationSet(ownPropsAfterAuto.values, arg.itemPropPath, value);
    });
    const autoFunction = componentDefinition.auto;
    if (autoFunction) {
      const ownValuesAfterAuto = autoFunction({
        values: ownPropsAfterAuto.values,
        params: {
          ...ownPropsAfterAuto.params,
          $width,
          $widthAuto
        },
        devices: compilationContext.devices
      });
      ownPropsAfterAuto.values = ownValuesAfterAuto;
    }

    // Fill all responsive values. We can assume that values after auto for each breakpoint MUST be defined!!!
    // IMPORTANT: For now we make it realtive to device widths, so Webflow way
    for (const prop in ownPropsAfterAuto.values) {
      ownPropsAfterAuto.values[prop] = responsiveValueFill(ownPropsAfterAuto.values[prop], compilationContext.devices, getDevicesWidths(compilationContext.devices));
    }
    for (const prop in ownPropsAfterAuto.params) {
      ownPropsAfterAuto.params[prop] = responsiveValueFill(ownPropsAfterAuto.params[prop], compilationContext.devices, getDevicesWidths(compilationContext.devices));
    }
    itemFieldsForEach(ownPropsAfterAuto.values, compilationContext, arg => {
      dotNotationSet(ownPropsAfterAuto.values, arg.itemPropPath, responsiveValueFill(arg.itemPropValue, compilationContext.devices, getDevicesWidths(compilationContext.devices)));
    });

    // First we compile all the props and store them in compiledValues
    const _compiledValues = compileComponentValues(ownPropsAfterAuto.values, componentDefinition, compilationContext, cache);
    compiledValues = {
      ...deepClone$1(ownPropsAfterAuto.values),
      ..._compiledValues
    };

    // Compile item props
    itemFieldsForEach(ownPropsAfterAuto.values, compilationContext, _ref => {
      let {
        itemPropValue,
        itemIndex,
        itemSchemaProp,
        collectionSchemaProp
      } = _ref;
      const compiledValue = compileFromSchema(itemPropValue, itemSchemaProp, compilationContext, cache, {}, meta);
      compiledValues[collectionSchemaProp.prop][itemIndex][itemSchemaProp.prop] = compiledValue;
    });

    // We want to style block element based on the most common values from all text parts within all lines.
    // Only for this component, we compile nested @easyblocks/rich-text-part components values.
    if (editableElement._component === "@easyblocks/rich-text") {
      if (compiledValues.isListStyleAuto) {
        const {
          mainColor = compiledValues.mainColor,
          mainFont = compiledValues.mainFont
        } = compileRichTextValuesFromRichTextParts(editableElement, compilationContext, cache);
        compiledValues.mainColor = mainColor;
        compiledValues.mainFont = mainFont;
      }
      compiledValues.mainFontSize = mapResponsiveFontToResponsiveFontSize(compiledValues.mainFont);
    }
    compiled = {
      ...compiled,
      components: {},
      styled: {}
    };
    const renderableComponentDefinition = componentDefinition;
    if (compilationContext.isEditing) {
      /**
       * Let's build default editingOutput (fields and component output)
       */

      const editorContext = compilationContext;
      editingInfo = buildDefaultEditingInfo(renderableComponentDefinition, configPrefix, editorContext, compiledValues, editableElement._component);

      /**
       * Let's run custom editing function
       */
      if (renderableComponentDefinition.editing) {
        const scalarizedConfig = scalarizeConfig(compiledValues, editorContext.breakpointIndex, editorContext.devices, renderableComponentDefinition.schema);
        const identityEditingField = assertDefined$1(editingInfo.fields.find(f => f.prop === "$myself"));
        const editingInfoWithoutIdentityField = {
          ...editingInfo,
          // Filter out identity field, since it's not users responsibility to care of it.
          fields: editingInfo.fields.filter(f => f.prop !== "$myself")
        };
        const editingInfoInput = convertInternalEditingInfoToEditingInfo(editingInfoWithoutIdentityField, configPrefix);
        const editingInfoResult = renderableComponentDefinition.editing({
          values: scalarizedConfig,
          params: ownPropsAfterAuto.params,
          editingInfo: editingInfoInput,
          device: editorContext.devices.find(device => device.id === editorContext.breakpointIndex),
          ...(componentDefinition.id === "@easyblocks/rich-text" || componentDefinition.id === "@easyblocks/rich-text-part" ? {
            __SECRET_INTERNALS__: {
              pathPrefix: configPrefix,
              editorContext
            }
          } : {})
        });
        if (editingInfoResult) {
          const internalEditingInfo = convertEditingInfoToInternalEditingInfo(editingInfoResult, editingInfo, componentDefinition, editorContext, configPrefix);
          internalEditingInfo.fields?.unshift(identityEditingField);
          deepObjectMergeWithoutArrays(editingInfo, internalEditingInfo);
        }
      }

      /**
       * Save to __editing
       */

      applyEditingInfoToCompiledConfig(compiled, editingInfo, parentComponentEditingInfo, {
        width: $width,
        auto: $widthAuto
      });
      editingContextProps = editingInfo.components;
    }
    const {
      props,
      components,
      styled
    } = resop2({
      values: compiledValues,
      params: ownPropsAfterAuto.params
    }, (_ref2, breakpointIndex) => {
      let {
        values,
        params
      } = _ref2;
      if (!renderableComponentDefinition.styles) {
        return {};
      }
      const device = assertDefined$1(compilationContext.devices.find(device => device.id === breakpointIndex), `Missing device "${breakpointIndex}"`);
      const stylesInput = {
        values,
        params: {
          ...params,
          $width: assertDefined$1(responsiveValueAt($width, breakpointIndex)),
          $widthAuto: assertDefined$1(responsiveValueAt($widthAuto, breakpointIndex))
        },
        isEditing: !!compilationContext.isEditing,
        device,
        ...(componentDefinition.id === "@easyblocks/rich-text-part" ? {
          __COMPILATION_CONTEXT__: compilationContext
        } : {})
      };
      return renderableComponentDefinition.styles(stylesInput);
    }, compilationContext.devices, renderableComponentDefinition);
    validateStylesProps(props, componentDefinition);
    subcomponentsContextProps = components;

    // Move all the boxes to _compiled
    for (const key in styled) {
      let styles = styled[key];
      if (Array.isArray(styles)) {
        styles = styles.map(v => {
          return {
            ...v,
            __isBox: true
          };
        });
      } else {
        styles = {
          ...styles,
          __isBox: true
        };
      }
      const schemaProp = componentDefinition.schema.find(x => x.prop === key);

      // Context props processed below
      if (schemaProp) {
        continue;
      }

      // If box

      compiled.styled[key] = compileBoxes(styles, compilationContext);
    }
    componentDefinition.schema.forEach(schemaProp => {
      if ("buildOnly" in schemaProp && schemaProp.buildOnly) {
        return;
      }
      if (isExternalSchemaProp(schemaProp, compilationContext.types) || schemaProp.type === "text") {
        // We simply copy ONLY the breakpoints which are defined in the raw data
        compiled.props[schemaProp.prop] = Object.fromEntries(Object.keys(editableElement[schemaProp.prop]).map(deviceId => {
          return [deviceId, compiledValues[schemaProp.prop][deviceId]];
        }));
      } else {
        compiled.props[schemaProp.prop] = responsiveValueNormalize(compiledValues[schemaProp.prop], compilationContext.devices);
      }
    });

    // we also add __props to props
    compiled.props = {
      ...props,
      ...compiled.props
    };

    // We are going to mutate this object so let's disconnect it from its source object
    configAfterAuto = deepClone$1({
      ...ownPropsAfterAuto.values,
      ...ownPropsAfterAuto.params
    });
  }
  if (compilationContext.isEditing) {
    /**
     * Let's build default editingOutput (fields and component output)
     */

    const editorContext = compilationContext;
    const renderableComponentDefinition = componentDefinition;
    editingInfo = buildDefaultEditingInfo(renderableComponentDefinition, configPrefix, editorContext, compiledValues, editableElement._component);

    /**
     * Let's run custom editing function
     */
    if (renderableComponentDefinition.editing) {
      const scalarizedValues = scalarizeConfig(compiledValues, editorContext.breakpointIndex, editorContext.devices, renderableComponentDefinition.schema);
      const identityEditingField = assertDefined$1(editingInfo.fields.find(f => f.prop === "$myself"));
      const editingInfoWithoutIdentityField = {
        ...editingInfo,
        // Filter out identity field, since it's not users responsibility to care of it.
        fields: editingInfo.fields.filter(f => f.prop !== "$myself")
      };
      const editingInfoInput = convertInternalEditingInfoToEditingInfo(editingInfoWithoutIdentityField, configPrefix);
      const editingInfoResult = renderableComponentDefinition.editing({
        values: scalarizedValues,
        params: ownPropsAfterAuto.params,
        editingInfo: editingInfoInput,
        device: editorContext.devices.find(device => device.id === editorContext.breakpointIndex),
        ...(componentDefinition.id === "@easyblocks/rich-text" || componentDefinition.id === "@easyblocks/rich-text-part" ? {
          __SECRET_INTERNALS__: {
            pathPrefix: configPrefix,
            editorContext
          }
        } : {})
      });
      if (editingInfoResult) {
        const internalEditingInfo = convertEditingInfoToInternalEditingInfo(editingInfoResult, editingInfo, componentDefinition, editorContext, configPrefix);
        internalEditingInfo.fields?.unshift(identityEditingField);
        deepObjectMergeWithoutArrays(editingInfo, internalEditingInfo);
      }
    }
    if (editingInfo)
      // Save to __editing
      applyEditingInfoToCompiledConfig(compiled, editingInfo, parentComponentEditingInfo, {
        width: $width,
        auto: $widthAuto
      });
    editingContextProps = editingInfo.components;
  }
  compileSubcomponents(editableElement, contextProps, subcomponentsContextProps, compilationContext, meta, editingContextProps, configPrefix, compiled, configAfterAuto, cache);
  cache.set(ownProps.values._id, {
    values: ownProps,
    valuesAfterAuto: ownPropsAfterAuto,
    compiledValues,
    compiledConfig: compiled,
    contextProps: subcomponentsContextProps,
    editingContextProps
  });
  if (process.env.SHOPSTORY_INTERNAL_COMPILATION_DEBUG === "true") {
    logCompilationDebugOutput({
      cachedResult,
      hasComponentConfigChanged,
      configPrefix,
      ownProps,
      compiled
    });
  }
  return {
    compiledComponentConfig: compiled,
    configAfterAuto
  };
}
function validateStylesProps(props, componentDefinition) {
  for (const key of Object.keys(props)) {
    const schemaProp = componentDefinition.schema.find(s => s.prop === key);
    if (!schemaProp || !("buildOnly" in schemaProp)) {
      continue;
    }
    if (!schemaProp.buildOnly) {
      throw new Error(`You've returned property "${key}" in "props" object that conflicts with the same prop in schema of component "${componentDefinition.id}". You can either change the property name or set the schema property as build-only (\`buildOnly: true\`).`);
    }
  }
}
function logCompilationDebugOutput(_ref3) {
  let {
    cachedResult,
    hasComponentConfigChanged,
    configPrefix,
    ownProps,
    compiled
  } = _ref3;
  if (cachedResult && !hasComponentConfigChanged) {
    console.groupCollapsed("[cache] ", configPrefix ? configPrefix : "root");
  } else {
    console.groupCollapsed("[compiled] ", configPrefix ? configPrefix : "root");
  }
  console.log(ownProps);
  console.log(compiled);
  console.groupEnd();
}
function createOwnComponentProps(_ref4) {
  let {
    config,
    contextProps,
    componentDefinition,
    compilationContext
  } = _ref4;
  // Copy all values and refs defined in schema, for component fields copy only _id, _component and its _itemProps but flattened
  const values = Object.fromEntries(componentDefinition.schema.map(schemaProp => {
    if (isSchemaPropComponentOrComponentCollection(schemaProp)) {
      let configValue = config[schemaProp.prop];
      if (configValue.length === 0) {
        return [schemaProp.prop, []];
      }
      if (isSchemaPropComponent(schemaProp)) {
        return [schemaProp.prop, [{
          _id: configValue[0]._id,
          _component: configValue[0]._component
        }]];
      }
      if (isSchemaPropComponentCollectionLocalised(schemaProp)) {
        configValue = resolveLocalisedValue$1(config[schemaProp.prop], compilationContext)?.value ?? [];
      }
      const configValuesWithFlattenedItemProps = configValue.map(config => {
        if (schemaProp.itemFields) {
          const flattenedItemProps = flattenItemProps(config, componentDefinition, schemaProp, schemaProp.itemFields);
          return {
            _id: config._id,
            _component: config._component,
            ...flattenedItemProps
          };
        }
        return {
          _id: config._id,
          _component: config._component
        };
      });
      return [schemaProp.prop, configValuesWithFlattenedItemProps];
    }
    return [schemaProp.prop, config[schemaProp.prop]];
  }));
  const ownValues = {
    // Copy id and component which uniquely identify component.
    _id: config._id,
    _component: config._component,
    ...values
  };
  return {
    values: ownValues,
    params: contextProps
  };
}
function flattenItemProps(config, componentDefinition, collectionSchemaProp, itemsSchemas) {
  const itemProps = Object.fromEntries(itemsSchemas.map(itemSchemaProp => {
    return [itemSchemaProp.prop, config._itemProps[componentDefinition.id][collectionSchemaProp.prop][itemSchemaProp.prop]];
  }));
  return itemProps;
}
function addComponentToSerializedComponentDefinitions(component, meta, componentType, compilationContext) {
  const definitions = meta.vars.definitions[componentType];
  if (definitions.find(def => def.id === component._component)) {
    return;
  }
  const internalDefinition = findComponentDefinition(component, compilationContext);
  const newDef = {
    id: internalDefinition.id,
    label: internalDefinition.label,
    schema: internalDefinition.schema,
    type: internalDefinition.type
  };
  if (compilationContext.isEditing) {
    newDef.pasteSlots = internalDefinition.pasteSlots ?? [];
  }
  definitions.push(newDef);
}
function compileSubcomponents(editableElement, contextProps, subcomponentsContextProps, compilationContext, meta, editingInfoComponents, configPrefix, compiledComponentConfig, configAfterAuto,
// null means that we don't want auto
cache) {
  const componentDefinition = findComponentDefinition(editableElement, compilationContext);
  componentDefinition.schema.forEach(schemaProp => {
    if (isSchemaPropComponentOrComponentCollection(schemaProp)) {
      // Currently these are processed outside of compileSubcomponents
      if (isSchemaPropActionTextModifier(schemaProp) || isSchemaPropTextModifier(schemaProp)) {
        return;
      }
      const childContextProps = subcomponentsContextProps[schemaProp.prop] || {};

      // Subcomponents must always have $width and $widthAuto defined. If wasn't set explicitly then parent's one is used.
      childContextProps.$width = childContextProps.$width ?? contextProps.$width;
      childContextProps.$widthAuto = childContextProps.$widthAuto ?? contextProps.$widthAuto;
      if (schemaProp.type === "component-collection" || schemaProp.type === "component-collection-localised") {
        childContextProps.itemProps = childContextProps.itemProps ?? [];
        let value;
        if (schemaProp.type === "component-collection") {
          value = editableElement[schemaProp.prop];
        } else {
          const resolvedValue = resolveLocalisedValue$1(editableElement[schemaProp.prop], compilationContext);
          if (!resolvedValue) {
            throw new Error(`Can't resolve localised value for prop "${schemaProp.prop}" of component ${editableElement._component}`);
          }
          value = resolvedValue.value;
        }
        value.forEach((_, index) => {
          childContextProps.itemProps[index] = childContextProps.itemProps[index] ?? {};
          const itemPropContextProps = childContextProps.itemProps[index];
          itemPropContextProps.$width = itemPropContextProps.$width ?? contextProps.$width;
          itemPropContextProps.$widthAuto = itemPropContextProps.$widthAuto ?? contextProps.$widthAuto;
        });
      }
      const compilationOutput = compileFromSchema(editableElement[schemaProp.prop], schemaProp, compilationContext, cache, childContextProps, meta, editingInfoComponents?.[schemaProp.prop], `${configPrefix}${configPrefix === "" ? "" : "."}${schemaProp.prop}`);
      compiledComponentConfig.components[schemaProp.prop] = compilationOutput.map(compilationOutput => compilationOutput.compiledComponentConfig);

      // Merge config after auto
      if (compilationContext.isEditing && configAfterAuto !== null) {
        if (schemaProp.type === "component") {
          configAfterAuto[schemaProp.prop] = [compilationOutput[0]?.configAfterAuto ?? []];
        } else if (schemaProp.type === "component-collection" || schemaProp.type === "component-collection-localised") {
          const configsAfterAuto = compilationOutput.map((compilationOutput, index) => {
            if (schemaProp.itemFields) {
              const itemPropsCollectionPath = `_itemProps.${editableElement._component}.${schemaProp.prop}`;
              const itemProps = Object.fromEntries(schemaProp.itemFields.map(itemSchemaProp => {
                const itemPropValue = configAfterAuto[schemaProp.prop][index][itemSchemaProp.prop];
                return [itemSchemaProp.prop, itemPropValue];
              }));
              dotNotationSet(compilationOutput.configAfterAuto, itemPropsCollectionPath, itemProps);
            }
            return compilationOutput.configAfterAuto;
          });
          if (schemaProp.type === "component-collection-localised") {
            // We store after auto config within context of current locale only
            configAfterAuto[schemaProp.prop] = {
              [compilationContext.contextParams.locale]: configsAfterAuto
            };
          } else {
            configAfterAuto[schemaProp.prop] = configsAfterAuto;
          }
        }
      }
    }
  });
}
function calculateWidths(compilationContext, contextProps) {
  const $width = {
    $res: true
  };
  const $widthAuto = {
    $res: true
  };
  compilationContext.devices.forEach(device => {
    $width[device.id] = contextProps.$width?.[device.id] ?? -1;
    $widthAuto[device.id] = contextProps.$widthAuto?.[device.id] ?? ($width[device.id] === -1 ? true : false);
  });
  return {
    $width,
    $widthAuto
  };
}
function itemFieldsForEach(config, compilationContext, callback) {
  const componentDefinition = findComponentDefinition(config, compilationContext);
  componentDefinition.schema.forEach(schemaProp => {
    if (isSchemaPropCollection(schemaProp)) {
      const itemFields = schemaProp.itemFields;
      let path = schemaProp.prop;
      if (schemaProp.type === "component-collection-localised") {
        const localizedValue = resolveLocalisedValue$1(config[schemaProp.prop], compilationContext);
        if (localizedValue) {
          path = `${path}.${localizedValue.locale}`;
        } else {
          path = `${path}.${compilationContext.contextParams.locale}`;
        }
      }
      const value = dotNotationGet$1(config, path) ?? [];
      value.forEach((_, index) => {
        if (itemFields) {
          itemFields.forEach(itemSchemaProp => {
            const itemPath = `${path}.${index}.${itemSchemaProp.prop}`;
            const itemValue = dotNotationGet$1(config, itemPath);
            callback({
              collectionSchemaProp: schemaProp,
              itemIndex: index,
              itemSchemaProp,
              itemPropPath: itemPath,
              itemPropValue: itemValue
            });
          });
        }
      });
    }
  });
}
function resolveLocalisedValue$1(localisedValue, compilationContext) {
  const locale = compilationContext.contextParams.locale;
  if (localisedValue[locale] !== undefined) {
    return {
      value: localisedValue[locale],
      locale
    };
  }
  const fallbackLocale = getFallbackLocaleForLocale(locale, compilationContext.locales);
  if (!fallbackLocale) {
    return;
  }
  return {
    value: localisedValue[fallbackLocale],
    locale: fallbackLocale
  };
}
function buildDefaultEditingInfo(definition, configPrefix, editorContext, compiledValues, templateId) {
  const scalarizedConfig = scalarizeConfig(compiledValues, editorContext.breakpointIndex, editorContext.devices, definition.schema);
  const schema = [...definition.schema];
  let defaultFields = schema
  // Right now, component-collection schema prop isn't shown in the sidebar
  .filter(schemaProp => !isSchemaPropCollection(schemaProp)).filter(schemaProp => {
    if (compiledValues.noTrace && schemaProp.prop.startsWith("trace")) {
      return false;
    }
    return true;
  }).map(schemaProp => getDefaultFieldDefinition(schemaProp, configPrefix, definition, editorContext, scalarizedConfig));

  // noAction is a special property
  if (compiledValues.noAction) {
    defaultFields = defaultFields.filter(field => field.path !== "action");
  }
  const pathInfo = parsePath(configPrefix, editorContext.form);
  const parentInfo = pathInfo.parent;
  if (parentInfo) {
    const parentDefinition = findComponentDefinitionById(parentInfo.templateId, editorContext);
    if (!parentDefinition) {
      throw new Error(`Can't find parent definition: ${parentInfo.templateId}`);
    }
    const parentSchemaProp = parentDefinition.schema.find(schemaProp => schemaProp.prop === parentInfo.fieldName);
    if (!parentSchemaProp) {
      throw new Error(`Can't find parent schemaProp: ${parentInfo.templateId} > ${parentInfo.fieldName}`);
    }
    let required;
    if (parentSchemaProp.type === "component") {
      required = !!parentSchemaProp.required;
    } else {
      required = false;
    }
    const headerSchemaProp = {
      prop: "$myself",
      label: "Component type",
      type: "component$$$",
      picker: parentSchemaProp.picker,
      definition: parentDefinition,
      required,
      group: "Component"
    };
    const headerField = {
      component: "identity",
      hidden: false,
      label: "Component type",
      name: configPrefix,
      prop: "$myself",
      schemaProp: headerSchemaProp
    };
    defaultFields.unshift(headerField);
  } else {
    const rootComponentDefinition = assertDefined$1(findComponentDefinitionById(dotNotationGet$1(editorContext.form.values, "")._component, editorContext));
    const headerSchemaProp = {
      prop: "$myself",
      label: "Component type",
      type: "component$$$",
      definition: rootComponentDefinition,
      required: true,
      group: "Component"
    };
    const headerField = {
      component: "identity",
      hidden: false,
      label: "Component type",
      name: "",
      prop: "$myself",
      schemaProp: headerSchemaProp
    };
    defaultFields.unshift(headerField);
  }
  const fields = bubbleDown(x => x.prop === "Analytics", defaultFields);
  const editingInfo = {
    fields,
    components: {}
  };
  definition.schema.forEach(schemaProp => {
    if (isSchemaPropCollection(schemaProp)) {
      editingInfo.components[schemaProp.prop] = {
        items: scalarizedConfig[schemaProp.prop].map((x, index) => ({
          fields: (schemaProp.itemFields ?? []).map(itemSchemaProp => getDefaultFieldDefinition(itemSchemaProp, `${configPrefix}${configPrefix === "" ? "" : "."}${schemaProp.prop}.${index}._itemProps.${definition.id}.${schemaProp.prop}`, definition, editorContext, scalarizedConfig))
        }))
      };
    } else if (isSchemaPropComponent(schemaProp)) {
      editingInfo.components[schemaProp.prop] = {
        fields: []
      };
    }
  });
  return editingInfo;
}
function applyEditingInfoToCompiledConfig(compiledComponentConfig, editingInfo, parentEditingInfo, widthInfo) {
  const headerFields = editingInfo.fields.filter(field => field.prop === "$myself");
  const nonHeaderFields = editingInfo.fields.filter(field => field.prop !== "$myself");
  const fields = [...headerFields, ...(parentEditingInfo && "fields" in parentEditingInfo ? parentEditingInfo.fields : []), ...nonHeaderFields];
  compiledComponentConfig.__editing = {
    ...parentEditingInfo,
    fields,
    components: {},
    widthInfo
  };
  for (const fieldName in editingInfo.components) {
    compiledComponentConfig.__editing.components[fieldName] = {};
    const childComponentEditingInfo = editingInfo.components[fieldName];

    // Here we copy only noInline. It's the only flag we need in parent component. It's only because we need noInline info even if there is no component in array (to know that we shouldn't render placeholder)
    if ("noInline" in childComponentEditingInfo && childComponentEditingInfo.noInline !== undefined) {
      compiledComponentConfig.__editing.components[fieldName].noInline = childComponentEditingInfo.noInline;
    }
  }
}
const deepObjectMergeWithoutArrays = (target, source) => {
  // Iterate through `source` properties and if an `Object` set property to merge of `target` and `source` properties
  for (const key of Object.keys(source)) {
    if (source[key] instanceof Object && !Array.isArray(source[key])) Object.assign(source[key], deepObjectMergeWithoutArrays(target[key], source[key]));
  }

  // Join `target` and modified `source`
  Object.assign(target || {}, source);
  return target;
};
function compileRichTextValuesFromRichTextParts(richTextConfig, compilationContext, cache) {
  const mainColor = getMostCommonValueFromRichTextParts(richTextConfig, "color", compilationContext, cache);
  const mainFont = getMostCommonValueFromRichTextParts(richTextConfig, "font", compilationContext, cache);
  return {
    mainColor,
    mainFont
  };
}
function mapResponsiveFontToResponsiveFontSize(responsiveFontValue) {
  return Object.fromEntries(entries(responsiveFontValue).map(_ref5 => {
    let [breakpoint, fontValue] = _ref5;
    if (breakpoint === "$res") {
      return [breakpoint, fontValue];
    }
    return [breakpoint, fontValue.fontSize];
  }));
}
function addStylesHash(styles) {
  if ("__hash" in styles) {
    delete styles["__hash"];
  }
  const hash = xxHash32(JSON.stringify(styles));
  styles.__hash = hash.toString();
  return styles;
}
function compileBoxes(value, compilationContext) {
  if (Array.isArray(value)) {
    return value.map(x => compileBoxes(x, compilationContext));
  } else if (typeof value === "object" && value !== null) {
    if (value.__isBox) {
      return addStylesHash(compileBox(value, compilationContext.devices));
    }
    const ret = {};
    for (const key in value) {
      ret[key] = compileBoxes(value[key], compilationContext);
    }
    return ret;
  }
  return value;
}
function getDefaultFieldDefinition(schemaProp, configPrefix, definition, editorContext, compiledValues, templateId) {
  const tinaField = getTinaField({
    ...schemaProp,
    definition
  }, editorContext, compiledValues[schemaProp.prop]);
  let visible = !isSchemaPropComponentOrComponentCollection(schemaProp);
  if (typeof schemaProp.visible === "boolean") {
    visible = schemaProp.visible;
  } else if (typeof schemaProp.visible === "function") {
    visible = schemaProp.visible(compiledValues, {
      editorContext
    });
  }
  return {
    ...tinaField,
    prop: schemaProp.prop,
    name: createFieldName(schemaProp, configPrefix),
    hidden: !visible
  };
}
function createFieldName(schemaProp, configPrefix) {
  return schemaProp.prop === "$myself" ? configPrefix : `${configPrefix}${configPrefix === "" ? "" : "."}${schemaProp.prop}`;
}
function convertInternalEditingInfoToEditingInfo(editingInfo, configPrefix) {
  const fields = editingInfo.fields.map(f => {
    return convertInternalEditingFieldToEditingInfoField(f, configPrefix);
  });
  const components = Object.fromEntries(Object.entries(editingInfo.components).map(_ref6 => {
    let [name, childEditingInfo] = _ref6;
    if ("items" in childEditingInfo) {
      const adaptedChildEditingInfo = childEditingInfo.items.map(item => {
        return {
          fields: item.fields.map(f => convertInternalEditingFieldToEditingInfoField(f, configPrefix)),
          direction: item.direction,
          selectable: item.noInline
        };
      });
      return [name, adaptedChildEditingInfo];
    }
    return [name, {
      fields: childEditingInfo.fields.map(f => convertInternalEditingFieldToEditingInfoField(f, configPrefix)),
      direction: childEditingInfo.direction,
      selectable: childEditingInfo.noInline
    }];
  }));
  return {
    fields,
    components
  };
}
function convertInternalEditingFieldToEditingInfoField(field, configPrefix) {
  const path = field.schemaProp.prop === "$myself" ? field.schemaProp.prop : toRelativeFieldPath(field.name, configPrefix);
  return {
    path,
    type: "field",
    visible: typeof field.hidden === "boolean" ? !field.hidden : true,
    group: field.group,
    label: field.label
  };
}
function toRelativeFieldPath(path, configPrefix) {
  let adjustedPath = path;
  if (path.includes("_itemProps")) {
    const pathFragments = path.split(".");
    const itemPropsFragmentIndex = pathFragments.indexOf("_itemProps");
    const adjustedPathFragments = [...pathFragments.slice(0, itemPropsFragmentIndex), pathFragments.at(-1)];
    adjustedPath = adjustedPathFragments.join(".");
  }
  return configPrefix ? adjustedPath.replace(`${configPrefix}.`, "") : adjustedPath;
}
function convertEditingInfoToInternalEditingInfo(editingInfo, internalEditingInfo, componentDefinition, editorContext, configPrefix) {
  let internalEditingInfoFields;
  if (editingInfo.fields) {
    if (!internalEditingInfoFields) {
      internalEditingInfoFields = [];
    }
    for (const field of editingInfo.fields) {
      const internalEditingInfoField = convertEditingFieldToInternalEditingField(field, internalEditingInfo, componentDefinition, editorContext, configPrefix);
      internalEditingInfoFields.push(internalEditingInfoField);
    }
  }
  let internalEditingInfoComponents;
  if (editingInfo.components) {
    internalEditingInfoComponents = {};
    for (const [name, childEditingInfo] of Object.entries(editingInfo.components)) {
      const sourceInternalEditingInfoComponent = internalEditingInfo.components[name];
      if (!sourceInternalEditingInfoComponent) {
        throw new Error(`Found component at path ${configPrefix} but it's not defined in the schema`);
      }
      if (Array.isArray(childEditingInfo)) {
        internalEditingInfoComponents[name] = {
          items: childEditingInfo.map((editingInfoItem, index) => {
            const sourceInternalFields = sourceInternalEditingInfoComponent.items[index].fields;
            const internalFields = editingInfoItem.fields?.map(field => {
              const internalEditingInfoField = convertEditingFieldToInternalEditingField(field, internalEditingInfo, componentDefinition, editorContext, configPrefix);
              return internalEditingInfoField;
            });
            const result = {
              fields: internalFields ?? sourceInternalFields
            };
            if (editingInfoItem.direction) {
              result.direction = editingInfoItem.direction;
            }
            if (editingInfoItem.selectable !== undefined) {
              result.noInline = !editingInfoItem.selectable;
            }
            return result;
          })
        };
      } else {
        const result = {};
        if (childEditingInfo.fields) {
          result.fields = childEditingInfo.fields.map(field => {
            const internalEditingInfoField = convertEditingFieldToInternalEditingField(field, internalEditingInfo, componentDefinition, editorContext, configPrefix);
            return internalEditingInfoField;
          });
        }
        if (childEditingInfo.direction) {
          result.direction = childEditingInfo.direction;
        }
        if (childEditingInfo.selectable !== undefined) {
          result.noInline = !childEditingInfo.selectable;
        }
        internalEditingInfoComponents[name] = result;
      }
    }
  }
  const result = {};
  if (internalEditingInfoFields) {
    result.fields = internalEditingInfoFields;
  }
  if (internalEditingInfoComponents) {
    result.components = internalEditingInfoComponents;
  }
  return result;
}
function convertEditingFieldToInternalEditingField(field, internalEditingInfo, componentDefinition, editorContext, configPrefix) {
  if (componentDefinition.id === "@easyblocks/rich-text" || componentDefinition.id === "@easyblocks/rich-text-part") {
    // This is a special case. Rich text components have a really nasty `editing` function implementation
    // relying on `editorContext`, absolute paths and multi field portals. Ideally it would best to address this,
    // but right now let's keep it as it is and treat it like an exception

    // Even though the type definition for field doesn't allow `path` to be an array, $richText component
    // returns an array of paths.
    if (Array.isArray(field.path)) {
      const fieldName = field.path[0]?.split(".").at(-1) ?? raiseError("Expected field name to be present");
      const sources = field.path.map(p => p.split(".").slice(0, -1).join("."));
      return {
        portal: "multi-field",
        fieldName,
        sources
      };
    }
    const isAbsolutePath = isFieldPathAbsolutePath(field, editorContext);
    if (isAbsolutePath) {
      if (field.type === "fields") {
        const groups = field.filters?.group ? toArray$1(field.filters.group) : undefined;
        return {
          portal: "component",
          source: field.path,
          groups
        };
      }
      const pathFragments = field.path.split(".");
      const fieldName = pathFragments.at(-1) ?? raiseError("Expected field name to be present");
      const source = pathFragments.slice(0, -1).join(".");
      return {
        portal: "field",
        source,
        fieldName
      };
    }
  }
  if (field.type === "field") {
    let sourceInternalEditingInfoField = internalEditingInfo.fields.find(f => {
      return f.name === toAbsolutePath(field.path, configPrefix) || field.path === "$myself";
    });
    if (!sourceInternalEditingInfoField) {
      const pathFragments = field.path.split(".");
      const isPathToComponentField = pathFragments.length > 1;
      if (isPathToComponentField) {
        const componentSchemaProp = componentDefinition.schema.find(isSchemaPropComponentOrComponentCollection);
        if (componentSchemaProp) {
          if (isSchemaPropCollection(componentSchemaProp)) {
            const itemField = componentSchemaProp.itemFields?.find(f => f.prop === pathFragments.at(-1));
            if (itemField) {
              const componentItemIndex = +pathFragments[1];
              sourceInternalEditingInfoField = internalEditingInfo.components[componentSchemaProp.prop].items[componentItemIndex].fields.find(f => f.prop === itemField.prop);
            }
          }
          if (componentSchemaProp.type === "component" && componentSchemaProp.required) {
            const absoluteFieldPath = toAbsolutePath(pathFragments.slice(0, -1).join("."), configPrefix);
            const overrides = {};
            if (field.label !== undefined) {
              overrides.label = field.label;
            }
            if (field.group !== undefined) {
              overrides.group = field.group;
            }
            return {
              portal: "field",
              fieldName: pathFragments.at(-1),
              source: absoluteFieldPath,
              overrides
            };
          }
        }
      }
      if (!sourceInternalEditingInfoField) {
        throw new Error(`Field "${field.path}" for component "${componentDefinition.id}" not found.`);
      }
    }
    return {
      ...sourceInternalEditingInfoField,
      label: field.label,
      group: field.group,
      hidden: !field.visible
    };
  }
  if (field.type === "fields") {
    const absoluteFieldPath = toAbsolutePath(field.path, configPrefix);
    return {
      portal: "component",
      source: absoluteFieldPath,
      ...(field.filters?.group !== undefined && {
        groups: toArray$1(field.filters.group)
      })
    };
  }
  throw new Error(`Unknown field type`);
}
function isFieldPathAbsolutePath(field, editorContext) {
  const pathFragments = field.path.split(".");
  const rootValue = dotNotationGet$1(editorContext.form.values, "");
  let currentPathFragmentIndex = 0;
  let currentValue = dotNotationGet$1(rootValue, pathFragments[currentPathFragmentIndex]);
  while (currentValue !== undefined) {
    if (pathFragments.length - 1 === currentPathFragmentIndex) {
      return true;
    }
    currentValue = dotNotationGet$1(currentValue, pathFragments[++currentPathFragmentIndex]);
  }
  return false;
}
function toAbsolutePath(path, configPrefix) {
  if (configPrefix) {
    return `${configPrefix}.${path}`;
  }
  return path;
}
function isSchemaPropTokenized(schemaProp) {
  return schemaProp.type === "color" || schemaProp.type === "space" || schemaProp.type === "font" || schemaProp.type === "aspectRatio" || schemaProp.type === "boxShadow" || schemaProp.type === "containerWidth";
}

/* with love from shopstory */

// Flattens recursively (max 2 levels)
function responsiveValueFlatten(resVal, devices) {
  if (!isTrulyResponsiveValue$1(resVal)) {
    return resVal;
  }
  const result = {
    $res: true
  };
  let activeNestedValue = undefined;

  // resValCopy has maximum breakpoint always set correctly, otherwise if we have b1, ..., b5 and responsive value is set to b4, then values ABOVE b4 won't be set.
  const resValCopy = {
    ...resVal
  };
  const maxDeviceInValue = responsiveValueGetHighestDefinedDevice(resValCopy, devices);
  const maxBreakpoint = devices[devices.length - 1].id;

  // Important condition. Sometimes if b5 is missing, b3 can be responsive and have b5 inside. Then b5 is defined.
  if (!resValCopy[maxBreakpoint] && isTrulyResponsiveValue$1(resValCopy[maxDeviceInValue.id])) {
    activeNestedValue = resValCopy[maxDeviceInValue.id];
  }
  for (let i = devices.length - 1; i >= 0; i--) {
    const breakpoint = devices[i].id;
    const value = resValCopy[breakpoint];
    if (value === undefined) {
      // If active nested value, we take from nested value;
      if (activeNestedValue !== undefined && activeNestedValue[breakpoint] !== undefined) {
        result[breakpoint] = responsiveValueGetDefinedValue(activeNestedValue, breakpoint, devices, getDevicesWidths(devices) /** FOR NOW TOKENS ARE ALWAYS RELATIVE TO SCREEN WIDTH */);
      }
      continue;
    } else if (!isTrulyResponsiveValue$1(value)) {
      activeNestedValue = undefined;
      result[breakpoint] = value;
    } else {
      activeNestedValue = value;
      result[breakpoint] = responsiveValueGetDefinedValue(activeNestedValue, breakpoint, devices, getDevicesWidths(devices) /** FOR NOW TOKENS ARE ALWAYS RELATIVE TO SCREEN WIDTH */);
    }
  }
  return result;
}

/* with love from shopstory */

const textProvider = (schemaProp, compilationContext) => {
  const checkIfValid = x => {
    if (typeof x !== "object" || x === null) {
      return false;
    }
    if (typeof x.id === "string") {
      if (x.id.startsWith("local.")) {
        // for local values "value" must be object
        if (typeof x.value !== "object" || x.value === null) {
          return false;
        }
      }
    }
    return true;
  };
  return {
    normalize: x => {
      if (x === undefined || x === null) {
        return {
          id: "local." + uniqueId$1(),
          value: {
            [compilationContext.contextParams.locale]: schemaProp.defaultValue ?? "Lorem ipsum"
          },
          widgetId: "@easyblocks/local-text"
        };
      }
      if (checkIfValid(x)) {
        return x;
      }
      throw new Error(`incorrect text type: ${x}`);
    },
    compile: x => {
      if ("value" in x) {
        const value = x.value[compilationContext.contextParams.locale];

        // Let's apply fallback
        if (typeof value !== "string") {
          const fallbackValue = getFallbackForLocale(x.value, compilationContext.contextParams.locale, compilationContext.locales) ?? "";
          return {
            id: x.id,
            value: fallbackValue,
            widgetId: "@easyblocks/local-text"
          };
        }
        return {
          id: x.id,
          value,
          widgetId: "@easyblocks/local-text"
        };
      }
      return {
        id: x.id,
        widgetId: x.widgetId,
        ...(x.id !== null && {
          key: x.key
        })
      };
    },
    getHash: value => {
      // TODO: those conditions will be removed after we merge external-local texts update
      if (typeof value === "string") {
        return value;
      }
      if (value === null) {
        return undefined;
      }
      return value.id ?? undefined;
    }
  };
};
const schemaPropDefinitions = {
  text: textProvider,
  number: (schemaProp, compilationContext) => {
    const normalize = getNormalize(compilationContext, schemaProp.defaultValue, 0, x => typeof x === "number" ? x : undefined);
    return {
      normalize,
      compile: x => x,
      getHash: value => {
        return value.toString();
      }
    };
  },
  string: (schemaProp, compilationContext) => {
    const normalize = schemaProp.responsive ? getResponsiveNormalize(compilationContext, schemaProp.defaultValue, "", x => typeof x === "string" ? x : undefined) : getNormalize(compilationContext, schemaProp.defaultValue, "", x => typeof x === "string" ? x : undefined);
    return {
      normalize,
      compile: x => x,
      getHash: (value, breakpointIndex) => {
        if (isTrulyResponsiveValue$1(value)) {
          return responsiveValueAt(value, breakpointIndex);
        }
        return value;
      }
    };
  },
  boolean: (schemaProp, compilationContext) => {
    const normalize = schemaProp.responsive ? getResponsiveNormalize(compilationContext, schemaProp.defaultValue, false, x => typeof x === "boolean" ? x : undefined) : getNormalize(compilationContext, schemaProp.defaultValue, false, x => typeof x === "boolean" ? x : undefined);
    return {
      normalize,
      compile: x => x,
      getHash: (value, breakpointIndex) => {
        if (isTrulyResponsiveValue$1(value)) {
          const breakpointValue = responsiveValueAt(value, breakpointIndex);
          return breakpointValue?.toString();
        }
        return value.toString();
      }
    };
  },
  select: getSelectSchemaPropDefinition(),
  "radio-group": getSelectSchemaPropDefinition(),
  component: (schemaProp, compilationContext) => {
    // Here:
    // 1. if non-fixed => block field.
    // 2. if fixed => block field with "fixed" flag (no component picker).
    const normalize = x => {
      if (!Array.isArray(x) || x.length === 0) {
        let componentDefinition;
        for (const componentIdOrType of schemaProp.accepts) {
          componentDefinition = findComponentDefinitionById(componentIdOrType, compilationContext);
          if (!componentDefinition) {
            const componentDefinitionsByType = findComponentDefinitionsByType(componentIdOrType, compilationContext);
            if (componentDefinitionsByType.length > 0) {
              componentDefinition = componentDefinitionsByType[0];
              break;
            }
          } else {
            break;
          }
        }
        if (schemaProp.required) {
          if (!componentDefinition) {
            throw new Error(`Missing component definition for prop "${schemaProp.prop}" for specified accepted types: [${schemaProp.accepts.join(", ")}]`);
          }
          return [normalizeComponent({
            _component: componentDefinition.id
          }, compilationContext)];
        }
        return [];
      }
      return [normalizeComponent(x[0], compilationContext)];
    };
    return {
      normalize,
      compile: (arg, contextProps, serializedDefinitions, editingInfoComponent, configPrefix, cache) => {
        if (arg.length === 0) {
          return [];
        }

        // FIXME: ?????
        const {
          configAfterAuto,
          compiledComponentConfig
        } = compileComponent(arg[0], compilationContext, contextProps, serializedDefinitions || {
          components: []
        }, cache, editingInfoComponent, `${configPrefix}.0`);
        return [{
          configAfterAuto,
          compiledComponentConfig
        }];
      },
      getHash: value => {
        if (value.length > 0) {
          // For now, if the block's value contains elements, it will only contain single element
          if (process.env.NODE_ENV === "development") {
            console.assert(value.length === 1, "component prop should have only one element");
          }
          return value[0]._component;
        }
        return "__BLOCK_EMPTY__";
      }
    };
  },
  "component-collection": (_, compilationContext) => {
    const normalize = x => {
      if (!Array.isArray(x)) {
        return [];
      }
      const ret = (x || []).map(item => normalizeComponent(item, compilationContext));
      return ret;
    };
    return {
      normalize,
      compile: (arr, contextProps, serializedDefinitions, editingInfoComponents, configPrefix, cache) => {
        return arr.map((componentConfig, index) => compileComponent(componentConfig, compilationContext, (contextProps.itemProps || [])[index] || {}, serializedDefinitions, cache, editingInfoComponents?.items?.[index], `${configPrefix}.${index}`));
      },
      getHash: value => {
        return value.map(v => v._component).join(";");
      }
    };
  },
  "component-collection-localised": (schemaProp, compilationContext) => {
    const collectionSchemaPropDefinition = schemaPropDefinitions["component-collection"]({
      ...schemaProp,
      type: "component-collection"
    }, compilationContext);
    return {
      normalize: x => {
        if (x === undefined) {
          return {};
        }
        const normalized = {};
        for (const locale in x) {
          if (locale === "__fallback") {
            continue;
          }
          normalized[locale] = collectionSchemaPropDefinition.normalize(x[locale]);
        }
        return normalized;
      },
      compile: (value, contextProps, serializedDefinitions, editingInfoComponents, configPrefix, cache) => {
        const resolvedLocalisedValue = resolveLocalisedValue(value, compilationContext);
        return collectionSchemaPropDefinition.compile(resolvedLocalisedValue?.value ?? [], contextProps, serializedDefinitions, editingInfoComponents, `${configPrefix}.${resolvedLocalisedValue?.locale ?? compilationContext.contextParams.locale}`, cache);
      },
      getHash: (value, breakpoint, devices) => {
        return collectionSchemaPropDefinition.getHash(value[compilationContext.contextParams.locale] ?? [], breakpoint, devices);
      }
    };
  },
  component$$$: () => {
    return {
      normalize: x => x,
      compile: x => x,
      getHash: x => x._component
    };
  },
  // external: (schemaProp, compilationContext) => {
  //   if (schemaProp.responsive) {
  //     const defaultValue: ExternalReferenceEmpty = {
  //       id: null,
  //       widgetId: compilationContext.isEditing
  //         ? compilationContext.types[schemaProp.type]?.widgets[0]?.id
  //         : "",
  //     };

  //     const normalize = getResponsiveNormalize<ExternalReference>(
  //       compilationContext,
  //       defaultValue,
  //       defaultValue,
  //       externalNormalize(schemaProp.type)
  //     );

  //     return {
  //       normalize,
  //       compile: (x) => x,
  //       getHash: externalReferenceGetHash,
  //     };
  //   }

  //   return {
  //     normalize: (value) => {
  //       const normalized = externalNormalize(schemaProp.type)(
  //         value,
  //         compilationContext
  //       );

  //       if (!normalized) {
  //         return {
  //           id: null,
  //           widgetId: compilationContext.types[schemaProp.type]?.widgets[0]?.id,
  //         };
  //       }

  //       return normalized;
  //     },
  //     compile: (value) => {
  //       return value;
  //     },
  //     getHash: (value) => {
  //       if (value.id === null) {
  //         return `${schemaProp.type}.${value.widgetId}`;
  //       }

  //       return `${schemaProp.type}.${value.widgetId}.${value.id}`;
  //     },
  //   };
  // },
  position: (schemaProp, compilationContext) => {
    return {
      normalize: getResponsiveNormalize(compilationContext, schemaProp.defaultValue, "top-left", x => {
        return typeof x === "string" ? x : "top-left";
      }),
      compile: x => x,
      getHash: (value, currentBreakpoint) => {
        if (isTrulyResponsiveValue$1(value)) {
          const breakpointValue = responsiveValueAt(value, currentBreakpoint);
          return breakpointValue?.toString();
        }
        return value;
      }
    };
  },
  custom: (schemaProp, compilationContext) => {
    const customTypeDefinition = compilationContext.types[schemaProp.type];
    return {
      normalize: value => {
        if (customTypeDefinition.type === "inline") {
          const defaultValue = schemaProp.defaultValue ?? customTypeDefinition.defaultValue;
          const normalizeScalar = v => {
            if (isLocalValue(v)) {
              if (customTypeDefinition.validate) {
                const isValueValid = customTypeDefinition.validate(v.value);
                if (isValueValid) {
                  return v;
                }
                return {
                  value: defaultValue,
                  widgetId: v.widgetId
                };
              }
              return {
                value: v.value ?? defaultValue,
                widgetId: v.widgetId
              };
            }
            return {
              value: v ?? defaultValue,
              widgetId: customTypeDefinition.widget.id
            };
          };
          if (customTypeDefinition.responsiveness === "optional" && schemaProp.responsive || customTypeDefinition.responsiveness === "always") {
            const normalize = getResponsiveNormalize(compilationContext, defaultValue, defaultValue, normalizeScalar);
            return normalize(value);
          }
          if (customTypeDefinition.responsiveness === "never" && schemaProp.responsive) {
            console.warn(`Custom type "${schemaProp.type}" is marked as "never" responsive, but schema prop is marked as responsive. This is not supported and the value for this field is going to stay not responsive. Please change custom type definition or schema prop definition.`);
          }
          const result = normalizeScalar(value);
          if (result) {
            return result;
          }
          const defaultLocalValue = {
            value: defaultValue,
            widgetId: customTypeDefinition.widget.id
          };
          return defaultLocalValue;
        }
        if (customTypeDefinition.type === "token") {
          const themeValues = compilationContext.theme[customTypeDefinition.token];
          const defaultThemeValueEntry = Object.entries(themeValues).find(_ref => {
            let [, v] = _ref;
            return v.isDefault;
          });
          const defaultValue = (() => {
            if (schemaProp.defaultValue) {
              return schemaProp.defaultValue;
            } else if (defaultThemeValueEntry) {
              return {
                tokenId: defaultThemeValueEntry[0]
              };
            } else {
              return customTypeDefinition.defaultValue;
            }
          })();
          const defaultWidgetId = customTypeDefinition.widget?.id;
          const createTokenNormalizer = normalizeScalar => {
            return customTypeDefinition.responsiveness === "always" || customTypeDefinition.responsiveness === "optional" && schemaProp.responsive ? getResponsiveNormalize(compilationContext, schemaProp.defaultValue, customTypeDefinition.defaultValue, x => {
              return normalizeTokenValue(x, themeValues, defaultValue, defaultWidgetId, normalizeScalar ?? (x => x));
            }) : getNormalize(compilationContext, schemaProp.defaultValue, customTypeDefinition.defaultValue, x => {
              return normalizeTokenValue(x, themeValues, defaultValue, defaultWidgetId, normalizeScalar ?? (x => x));
            });
          };
          if (customTypeDefinition.token === "space") {
            const normalizeSpace = createTokenNormalizer(x => {
              if (typeof x === "number") {
                return `${x}px`;
              }
              const isValidSpacing = customTypeDefinition.validate?.(x) ?? true;
              if (!isValidSpacing) {
                return;
              }
              return x;
            });
            return normalizeSpace(value);
          }
          if (customTypeDefinition.token === "icons") {
            const scalarValueNormalize = x => {
              if (typeof x === "string" && x.trim().startsWith("<svg")) {
                return x;
              }
              return;
            };
            const iconDefaultValue = normalizeTokenValue(schemaProp.defaultValue, themeValues, customTypeDefinition.defaultValue, defaultWidgetId, scalarValueNormalize) ?? customTypeDefinition.defaultValue;
            return normalizeTokenValue(value, themeValues, iconDefaultValue, defaultWidgetId, scalarValueNormalize) ?? value;
          }
          const defaultTokenNormalizer = createTokenNormalizer();
          return defaultTokenNormalizer(value);
        }
        if (customTypeDefinition.type === "external") {
          if (schemaProp.responsive) {
            const defaultValue = {
              id: null,
              widgetId: compilationContext.isEditing ? customTypeDefinition.widgets[0]?.id : ""
            };
            const normalize = getResponsiveNormalize(compilationContext, defaultValue, defaultValue, externalNormalize(schemaProp.type));
            return normalize(value);
          }
          const normalized = externalNormalize(schemaProp.type)(value, compilationContext);
          if (!normalized) {
            return {
              id: null,
              widgetId: customTypeDefinition.widgets[0]?.id
            };
          }
          return normalized;
        }
        throw new Error("Unknown type definition");
      },
      compile: x => {
        const val = responsiveValueMap(x, y => {
          if ("value" in y) {
            return y.value;
          }
          return y;
        });
        const flattened = responsiveValueFlatten(val, compilationContext.devices);
        return responsiveValueFill(flattened, compilationContext.devices, getDevicesWidths(compilationContext.devices));
      },
      getHash: (value, breakpointIndex) => {
        function getTokenValue(value) {
          if (value.tokenId) {
            return value.tokenId;
          }
          if (typeof value.value === "object") {
            return JSON.stringify(value.value);
          }
          const scalarVal = value.value;
          if (scalarVal.toString) {
            return scalarVal.toString();
          }
          throw new Error("unreachable");
        }
        if (customTypeDefinition.type === "external") {
          return externalReferenceGetHash(value, breakpointIndex);
        }
        if (isTrulyResponsiveValue$1(value)) {
          const breakpointValue = responsiveValueAt(value, breakpointIndex);
          if (!breakpointValue) {
            return;
          }
          if ("tokenId" in breakpointValue) {
            return getTokenValue(breakpointValue);
          }
          return typeof breakpointValue.value === "object" ? JSON.stringify(breakpointValue.value) : breakpointValue.value;
        }
        if ("tokenId" in value) {
          return getTokenValue(value);
        }
        return typeof value.value === "object" ? JSON.stringify(value.value) : value.value;
      }
    };
  }
};
function getNormalize(compilationContext, defaultValue, fallbackDefaultValue) {
  let normalize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : x => x;
  return val => {
    const normalizedVal = normalize(val, compilationContext);
    if (normalizedVal !== undefined) {
      return normalizedVal;
    }
    const normalizedDefaultVal = normalize(defaultValue, compilationContext);
    if (normalizedDefaultVal !== undefined) {
      return normalizedDefaultVal;
    }
    return normalize(fallbackDefaultValue, compilationContext);
  };
}
function getResponsiveNormalize(compilationContext, defaultValue, fallbackDefaultValue) {
  let normalize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : x => x;
  if (isTrulyResponsiveValue$1(defaultValue)) {
    /**
     * Here we must decide how this behaves. It's not obvious. If default is responsive, we cannot easily use default breakpoints.
     * It's because auto might be different. Changing one breakpoint changes "context" for others.
     */
    throw new Error("default responsive values not yet supported");
  }
  return val => {
    const scalarNormalize = getNormalize(compilationContext, defaultValue, fallbackDefaultValue, normalize);

    // if value is not really responsive
    if (!isTrulyResponsiveValue$1(val)) {
      return {
        $res: true,
        [compilationContext.mainBreakpointIndex]: scalarNormalize(val)
      };
    }
    const responsiveVal = responsiveValueMap(val, x => {
      return normalize(x, compilationContext);
    });

    // main breakpoint always set
    if (responsiveVal[compilationContext.mainBreakpointIndex] === undefined) {
      responsiveVal[compilationContext.mainBreakpointIndex] = scalarNormalize(undefined);
    }
    return responsiveVal;
  };
}
function getSelectSchemaPropDefinition() {
  return (schemaProp, compilationContext) => {
    return {
      normalize: schemaProp.responsive ? getResponsiveNormalize(compilationContext, schemaProp.defaultValue, getFirstOptionValue(schemaProp), x => {
        return isSelectValueCorrect(x, schemaProp.params.options) ? x : undefined;
      }) : getNormalize(compilationContext, schemaProp.defaultValue, getFirstOptionValue(schemaProp), x => {
        return isSelectValueCorrect(x, schemaProp.params.options) ? x : undefined;
      }),
      compile: x => x,
      getHash: (value, currentBreakpoint) => {
        if (isTrulyResponsiveValue$1(value)) {
          const breakpointValue = responsiveValueAt(value, currentBreakpoint);
          return breakpointValue?.toString();
        }
        return value;
      }
    };
  };
}
function isSelectValueCorrect(value, options) {
  if (typeof value !== "string") {
    return false;
  }
  return options.map(getSelectValue).indexOf(value) > -1;
}
function getSelectValue(arg) {
  if (typeof arg === "string") {
    return arg;
  }
  return arg.value;
}
function getFirstOptionValue(schemaProp) {
  if (schemaProp.params.options.length === 0) {
    throw new Error("Select field can't have 0 options");
  }
  const firstOption = schemaProp.params.options[0];
  const firstOptionValue = typeof firstOption === "object" ? firstOption.value : firstOption;
  return firstOptionValue;
}
function normalizeTokenValue(x, themeValues, defaultValue, defaultWidgetId) {
  let scalarValueNormalize = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : x => undefined;
  const input = x ?? defaultValue;
  const widgetId = input.widgetId ?? defaultWidgetId;

  // if (typeof input !== "object" && "value" in defaultValue) {
  //   const normalizedVal = scalarValueNormalize(defaultValue.value);

  //   if (normalizedVal !== undefined) {
  //     return {
  //       value: normalizedVal,
  //       widgetId,
  //     };
  //   }

  //   return;
  // }

  const hasTokenId = "tokenId" in input && typeof input.tokenId === "string";
  if (hasTokenId) {
    const val = themeValues[input.tokenId];
    if (val !== undefined) {
      return {
        value: val.value,
        tokenId: input.tokenId,
        widgetId
      };
    }
  }
  if ("value" in input) {
    const normalizedVal = scalarValueNormalize(input.value);
    if (normalizedVal !== undefined) {
      return {
        tokenId: hasTokenId ? input.tokenId : undefined,
        value: normalizedVal,
        widgetId
      };
    }
  }
  return;
}
function externalNormalize(externalType) {
  return (x, compilationContext) => {
    if (typeof x === "object" && x !== null) {
      if ("id" in x && x.id !== null) {
        const normalized = {
          id: x.id,
          widgetId: x.widgetId,
          key: x.key
        };
        return normalized;
      }
      const normalized = {
        id: null,
        widgetId: typeof x.widgetId === "string" ? x.widgetId : compilationContext.types[externalType]?.widgets[0]?.id
      };
      return normalized;
    }
  };
}
function externalReferenceGetHash(value, breakpointIndex) {
  if (isTrulyResponsiveValue$1(value)) {
    const breakpointValue = responsiveValueAt(value, breakpointIndex);
    if (breakpointValue) {
      return externalReferenceGetHash(breakpointValue, breakpointIndex);
    }
    return;
  }
  if (value.id) {
    return `${value.id}.${value.widgetId}`;
  }
}
function normalizeComponent(configComponent, compilationContext) {
  const ret = {
    _id: configComponent._id ?? uniqueId$1(),
    _component: configComponent._component
  };

  // Normalize itemProps (before own props). If component definition is missing, we still normalize item props
  if (configComponent._itemProps) {
    ret._itemProps = {};
    for (const templateId in configComponent._itemProps) {
      ret._itemProps[templateId] = {};
      for (const fieldName in configComponent._itemProps[templateId]) {
        ret._itemProps[templateId][fieldName] = {};
        const values = configComponent._itemProps[templateId][fieldName];
        const ownerDefinition = findComponentDefinitionById(templateId, compilationContext);
        const ownerSchemaProp = ownerDefinition.schema.find(x => x.prop === fieldName);
        if (!ownerSchemaProp) {
          continue;
        }
        (ownerSchemaProp.itemFields || []).forEach(itemFieldSchemaProp => {
          ret._itemProps[templateId][fieldName][itemFieldSchemaProp.prop] = getSchemaDefinition(itemFieldSchemaProp, compilationContext).normalize(values[itemFieldSchemaProp.prop]);
        });
      }
    }
  }
  const componentDefinition = findComponentDefinitionById(configComponent._component, compilationContext);
  if (!componentDefinition) {
    console.warn(`[normalize] Unknown _component ${configComponent._component}`);
    return ret;
  }
  componentDefinition.schema.forEach(schemaProp => {
    ret[schemaProp.prop] = getSchemaDefinition(schemaProp, compilationContext).normalize(configComponent[schemaProp.prop]);
  });

  // RichText is a really specific component. It must have concrete shape to work properly.
  // When using prop of type `component` with `accepts: ["@easyblocks/rich-text"]` it's going to be initialized with empty
  // `elements` property which in result will cause RichText to not work properly. To fix this, we're going
  // to initialize `elements` with default template - the same that's being added when user adds RichText to Stack manually.
  if (ret._component === "@easyblocks/rich-text") {
    if (Object.keys(ret.elements).length === 0 || ret.elements[compilationContext.contextParams.locale]?.length === 0) {
      const richTextConfig = buildRichTextNoCodeEntry({
        locale: compilationContext.contextParams.locale,
        color: Object.entries(compilationContext.theme.colors ?? {}).find(_ref2 => {
          let [, value] = _ref2;
          return value.isDefault;
        })?.[0],
        font: Object.entries(compilationContext.theme.fonts ?? {}).find(_ref3 => {
          let [, value] = _ref3;
          return value.isDefault;
        })?.[0]
      });
      ret.elements = richTextConfig.elements;
    }
  }
  return ret;
}
function getSchemaDefinition(schemaProp, compilationContext) {
  const provider = compilationContext.types[schemaProp.type] && schemaProp.type !== "text" ? schemaPropDefinitions.custom : schemaPropDefinitions[schemaProp.type];
  return provider(schemaProp, compilationContext);
}
function resolveLocalisedValue(localisedValue, compilationContext) {
  const locale = compilationContext.contextParams.locale;
  if (localisedValue[locale] !== undefined) {
    return {
      value: localisedValue[locale],
      locale
    };
  }
  const fallbackLocale = getFallbackLocaleForLocale(locale, compilationContext.locales);
  if (!fallbackLocale) {
    return;
  }
  return {
    value: localisedValue[fallbackLocale],
    locale: fallbackLocale
  };
}

/* with love from shopstory */

function normalize(configComponent, compilationContext) {
  return normalizeComponent(configComponent, compilationContext);
}

function last(collection) {
  return collection[collection.length - 1];
}

// eslint-disable-next-line @typescript-eslint/ban-types
function toArray(scalarOrCollection) {
  if (Array.isArray(scalarOrCollection)) {
    return scalarOrCollection;
  }
  return [scalarOrCollection];
}

const takeNumbers = path => path.split(".").map(x => parseInt(x, 10)).filter(x => !Number.isNaN(x));
const preOrderPathComparator = function () {
  let direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "ascending";
  return (pathA, pathB) => {
    const order = direction === "ascending" ? 1 : -1;
    const numbersA = takeNumbers(pathA);
    const numbersB = takeNumbers(pathB);
    const numberALength = numbersA.length;
    const numberBLength = numbersB.length;
    if (numberALength === 0 || numberBLength === 0) {
      throw new Error(`Cannot compare paths '${pathA}' and '${pathB}'.`);
    }
    const shorterLength = Math.min(numberALength, numberBLength);
    let index = 0;
    while (index < shorterLength) {
      const valueA = numbersA[index];
      const valueB = numbersB[index];
      if (valueA !== valueB) {
        return order * Math.sign(valueA - valueB);
      }
      index++;
    }
    return order * Math.sign(numberBLength - numberALength);
  };
};

function includesAny(a, b) {
  return a.some(i => b.includes(i));
}

function deepClone(source) {
  return JSON.parse(JSON.stringify(source));
}

function deepCompare() {
  for (let index = 0; index < arguments.length - 1; index++) {
    const currentObject = sortObject(index < 0 || arguments.length <= index ? undefined : arguments[index]);
    const nextObject = sortObject(index + 1 < 0 || arguments.length <= index + 1 ? undefined : arguments[index + 1]);
    const areObjectsHashesEqual = JSON.stringify(currentObject) === JSON.stringify(nextObject);
    if (!areObjectsHashesEqual) {
      return false;
    }
  }
  return true;
}
function sortObject(value) {
  if (typeof value !== "object") {
    return value;
  }
  if (Array.isArray(value)) {
    return [...value].sort();
  }
  if (value === null) {
    return null;
  }
  const sortedObject = {};
  const objectKeys = Object.keys(value).sort();
  objectKeys.forEach(key => {
    sortedObject[key] = sortObject(value[key]);
  });
  return sortedObject;
}

function useForceRerender() {
  const [, setDummyState] = useState({});
  const forceRerender = useRef(() => {
    setDummyState({});
  }).current;
  return {
    forceRerender
  };
}

function dotNotationGet(obj, path) {
  if (path === "") {
    return obj;
  }
  return path.split(".").reduce((acc, curVal) => acc && acc[curVal], obj);
}

function serialize(value) {
  if (value instanceof Error) {
    return JSON.parse(JSON.stringify(value, Object.getOwnPropertyNames(value)));
  }
  return JSON.parse(JSON.stringify(value));
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function uniqueId() {
  const id = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    const r = Math.random() * 16 | 0,
      v = c == "x" ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
  return id;
}

function assertDefined(value, message) {
  if (value === undefined) {
    throw new Error(message ?? "Value is undefined");
  }
  return value;
}

const ConfigAfterAutoContext = /*#__PURE__*/React__default.createContext(null);
function useConfigAfterAuto() {
  const configAfterAutoContext = useContext(ConfigAfterAutoContext);
  if (!configAfterAutoContext) {
    throw new Error("CompiledConfigContext is required for Responsive field");
  }
  return configAfterAutoContext;
}

const ExternalDataContext = /*#__PURE__*/createContext({});
function EditorExternalDataProvider(_ref) {
  let {
    children,
    externalData
  } = _ref;
  return /*#__PURE__*/React__default.createElement(ExternalDataContext.Provider, {
    value: externalData
  }, children);
}
function useEditorExternalData() {
  return useContext(ExternalDataContext);
}

let ExtraKeys = /*#__PURE__*/function (ExtraKeys) {
  ExtraKeys["ALT_KEY"] = "altKey";
  ExtraKeys["CTRL_KEY"] = "ctrlKey";
  ExtraKeys["META_KEY"] = "metaKey";
  ExtraKeys["SHIFT_KEY"] = "shiftKey";
  return ExtraKeys;
}({});
const actionKeys = [ExtraKeys.ALT_KEY, ExtraKeys.CTRL_KEY, ExtraKeys.META_KEY, ExtraKeys.SHIFT_KEY];
const useWindowKeyDown = function (key, callback) {
  let {
    extraKeys,
    isDisabled
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    extraKeys: [],
    isDisabled: false
  };
  const downHandler = event => {
    const isExtraKeysPressed = extraKeys.every(k => event[k]);
    const extraKeysSet = new Set([...extraKeys]);
    const isOtherExtraKeysPressed = actionKeys.filter(k => !extraKeysSet.has(k)).some(k => event[k]);
    if (event.key === key && isExtraKeysPressed && !isOtherExtraKeysPressed) {
      event.preventDefault();
      callback();
    }
  };
  useEffect(() => {
    if (!isDisabled) {
      document.getElementsByTagName("iframe")[0].contentWindow.window.document.body.addEventListener("keydown", downHandler);
      window.addEventListener("keydown", downHandler);
      return () => {
        window.removeEventListener("keydown", downHandler);
      };
    }
  }, [isDisabled]);
};

function EditorIframe(_ref) {
  let {
    onEditorHistoryRedo,
    onEditorHistoryUndo,
    width,
    height,
    transform,
    containerRef
  } = _ref;
  const [isIframeReady, setIframeReady] = useState(false);
  const handleIframeLoaded = () => {
    setIframeReady(true);
  };
  useWindowKeyDown("z", onEditorHistoryUndo, {
    extraKeys: [ExtraKeys.META_KEY],
    isDisabled: !isIframeReady
  });
  useWindowKeyDown("z", onEditorHistoryRedo, {
    extraKeys: [ExtraKeys.META_KEY, ExtraKeys.SHIFT_KEY],
    isDisabled: !isIframeReady
  });
  useWindowKeyDown("z", onEditorHistoryUndo, {
    extraKeys: [ExtraKeys.CTRL_KEY],
    isDisabled: !isIframeReady
  });
  useWindowKeyDown("y", onEditorHistoryRedo, {
    extraKeys: [ExtraKeys.CTRL_KEY],
    isDisabled: !isIframeReady
  });
  return /*#__PURE__*/React__default.createElement(IframeContainer, {
    ref: containerRef
  }, /*#__PURE__*/React__default.createElement(IframeInnerContainer, null, /*#__PURE__*/React__default.createElement(Iframe, {
    id: "shopstory-canvas",
    src: window.location.href,
    onLoad: handleIframeLoaded,
    style: {
      // These properties will change a lot during resizing, so we don't pass it to styled component to prevent
      // class name recalculations
      width,
      height,
      transform
    }
  })));
}
const IframeContainer = styled.div.withConfig({
  displayName: "EditorIframe__IframeContainer",
  componentId: "sc-1k2h6r-0"
})(["position:relative;flex:1 1 auto;background:", ";"], Colors.black100);
const IframeInnerContainer = styled.div.withConfig({
  displayName: "EditorIframe__IframeInnerContainer",
  componentId: "sc-1k2h6r-1"
})(["position:absolute;top:0;left:0;width:100%;height:100%;display:grid;justify-content:center;align-items:center;"]);
const Iframe = styled.iframe.withConfig({
  displayName: "EditorIframe__Iframe",
  componentId: "sc-1k2h6r-2"
})(["background:white;border:none;transform-origin:center;"]);

function pathToCompiledPath(path, editorContext) {
  const pathInfo = parsePath(path, editorContext.form);
  if (pathInfo.parent) {
    const definition = findComponentDefinitionById(pathInfo.parent.templateId, editorContext);
    const schemaProp = definition.schema.find(schemaProp => schemaProp.prop === pathInfo.parent.fieldName);
    const result = `${pathToCompiledPath(pathInfo.parent.path, editorContext)}.${getPropertyNameFromSchemaProp(schemaProp)}.${pathInfo.parent.fieldName}.${pathInfo.index}`;
    if (result.startsWith(".")) {
      return result.substring(1);
    }
    return result;
  }
  return "";
}
function getPropertyNameFromSchemaProp(schemaProp) {
  if (isSchemaPropTextModifier(schemaProp) || isSchemaPropActionTextModifier(schemaProp)) {
    return "textModifiers";
  }
  return "components";
}

function isFieldPortal(x) {
  return "portal" in x;
}
function buildTinaFields(path, editorContext) {
  return internalBuildTinaFields(path, editorContext);
}
function internalBuildTinaFields(path, editorContext, fieldsFilter) {
  const compiledPath = pathToCompiledPath(stripRichTextPartSelection(path), editorContext);
  const compiledComponent = dotNotationGet(editorContext.compiledComponentConfig, compiledPath);
  let allFields = [];
  (compiledComponent.__editing?.fields ?? []).filter(field => fieldsFilter ? fieldsFilter(field) : true).forEach(item => {
    if (isFieldPortal(item)) {
      let fields = [];
      if (item.portal === "component") {
        const portalComponentFields = internalBuildTinaFields(item.source, editorContext);
        fields.push(...portalComponentFields);
        if (!item.includeHeader) {
          fields = fields.filter(x => x.prop !== "$myself");
        }
        const groups = item.groups;
        if (groups) {
          fields = fields.filter(x => x.prop === "$myself" || groups.includes(x.group || "___doesn't matter___"));
        }
      } else if (item.portal === "field") {
        if (item.hidden) {
          return;
        }
        const portalFieldFields = internalBuildTinaFields(item.source, editorContext, field => !isFieldPortal(field) && field.prop === item.fieldName);
        if (portalFieldFields.length === 0) {
          console.warn(`Missing field "${item.fieldName}" at path "${item.source}" in portal for component ${compiledComponent._component}`);
          return;
        }
        const portalField = {
          ...portalFieldFields[0],
          ...item.overrides
        };
        fields.push(portalField);
      } else if (item.portal === "multi-field") {
        if (item.sources.length === 0) {
          if (item.hidden) {
            return;
          }
          throw new Error(`Missing sources for multi field portal of component "${compiledComponent._component}" at path "${path}". Set "hidden" to "true" for this portal if sources are empty`);
        }
        const portalFieldFields = item.sources.flatMap(source => internalBuildTinaFields(source, editorContext, field => !isFieldPortal(field) && field.prop === item.fieldName));
        const firstField = portalFieldFields[0];
        const combinedField = {
          ...firstField,
          ...item.overrides,
          name: portalFieldFields.flatMap(field => field.name)
        };
        fields.push(combinedField);
      }
      allFields = [...allFields, ...fields];
    } else {
      allFields.push(item);
    }
  });

  // Analytics fields should always go to the bottom (later they'll be in separate tab)

  const nonAnalyticsFields = allFields.filter(x => x.group !== "Analytics");
  const analyticsFields = allFields.filter(x => x.group === "Analytics");
  return [...nonAnalyticsFields, ...analyticsFields];
}

const IdWrapper = styled.div.withConfig({
  displayName: "SidebarFooter__IdWrapper",
  componentId: "sc-17xf0ak-0"
})(["display:block;padding:16px;", " color:", ";"], Fonts.body, Colors.black40);
function SidebarFooter(props) {
  const editorContext = useEditorContext();
  const {
    form,
    isAdminMode
  } = editorContext;
  if (props.paths.length === 0) {
    return null;
  }
  const path = stripRichTextPartSelection(props.paths[0]);
  const value = dotNotationGet(form.values, path);
  if (!value) {
    return null;
  }
  const compiledPath = pathToCompiledPath(path, editorContext);
  const compiledValue = dotNotationGet(editorContext.compiledComponentConfig, compiledPath);
  const widthInfo = compiledValue.__editing?.widthInfo;
  const width = widthInfo?.width?.xl;
  const widthAuto = widthInfo?.auto?.xl;
  const definition = findComponentDefinition(value, editorContext);
  const isSaveable = !!definition?.allowSave;
  const showSaveAsTemplate = isSaveable && !editorContext.readOnly && !editorContext.disableCustomTemplates;
  return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(IdWrapper, null, /*#__PURE__*/React.createElement("div", null, "Id: ", value._id), /*#__PURE__*/React.createElement("br", null), showSaveAsTemplate && /*#__PURE__*/React.createElement(ButtonSecondary, {
    onClick: () => {
      editorContext.actions.openTemplateModal({
        mode: "create",
        config: value,
        width,
        widthAuto
      });
    }
  }, "Save as template"), isAdminMode && /*#__PURE__*/React.createElement("div", {
    style: {
      paddingTop: 16
    }
  }, /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(ButtonPrimary, {
    onClick: () => {
      navigator.clipboard.writeText(JSON.stringify(value)).then(() => {
        console.log("copied!", value);
      }, () => {
        alert("Copy error");
      });
    }
  }, "Copy entry")), value._master && /*#__PURE__*/React.createElement("div", {
    style: {
      paddingTop: 16
    }
  }, "Master: ", value._master))));
}

const Toggle = _ref => {
  let {
    input,
    field,
    disabled = false
  } = _ref;
  const checked = !!(input.value || input.checked);
  const toggleProps = {
    ...input,
    labels: null,
    name: field.name,
    disabled,
    value: checked,
    checked
  };
  return /*#__PURE__*/React__default.createElement(ToggleFieldWrapper, null, /*#__PURE__*/React__default.createElement(Toggle$1, toggleProps));
};
const ToggleFieldWrapper = styled.div.withConfig({
  displayName: "Toggle__ToggleFieldWrapper",
  componentId: "sc-1ldymt4-0"
})(["display:flex;justify-content:flex-end;"]);

const MIXED_VALUE = "__MIXED__";
const COMPONENTS_SUPPORTING_MIXED_VALUES = ["block", "radio-group", "select", "token"];

function isMixedFieldValue(value) {
  return typeof value === "object" && value !== null && "__mixed__" in value && value.__mixed__;
}

const SelectFieldComponent = _ref => {
  let {
    input,
    field,
    options
  } = _ref;
  const {
    value,
    onChange
  } = input;
  const isMixedValue = isMixedFieldValue(value);
  const selectOptions = options || field.options;
  const normalizedSelectOptions = selectOptions.map(toProps);
  if (isMixedValue) {
    normalizedSelectOptions.unshift({
      label: "Mixed",
      value: MIXED_VALUE
    }, {
      isDivider: true
    });
  }
  const inputValue = isMixedValue ? MIXED_VALUE : value;
  const handleChange = value => {
    onChange(value);
  };
  return /*#__PURE__*/React__default.createElement(Select, {
    value: inputValue,
    onChange: handleChange
  }, normalizedSelectOptions.map(toComponent));
};
function toProps(option) {
  if (typeof option === "object") return option;
  return {
    value: option,
    label: option
  };
}
function toComponent(option) {
  if ("isDivider" in option) {
    return /*#__PURE__*/React__default.createElement(SelectSeparator, {
      key: "divider"
    });
  }
  return /*#__PURE__*/React__default.createElement(SelectItem, {
    key: option.value,
    value: option.value,
    isDisabled: option.value === MIXED_VALUE
  }, option.label);
}

const RadioGroup = _ref => {
  let {
    input,
    field,
    options
  } = _ref;
  const {
    value
  } = input;
  const radioOptions = options || field.options;
  const toggleButtonValue = isMixedFieldValue(value) ? undefined : value;
  const toProps = option => {
    if (typeof option === "object") return option;
    return {
      value: option,
      label: option
    };
  };
  const radioOptionsMapped = radioOptions ? radioOptions.map(toProps) : [];
  return radioOptionsMapped && /*#__PURE__*/React__default.createElement(SelectInline, _extends({}, input, {
    value: toggleButtonValue
  }), radioOptionsMapped.map(option => {
    let Icon = undefined;
    if (typeof option.icon === "string" && option.icon in Icons) {
      Icon = Icons[option.icon];
    }
    if (typeof option.icon === "function") {
      Icon = option.icon;
    }
    return /*#__PURE__*/React__default.createElement(ToggleButton, {
      key: option.value,
      icon: Icon,
      value: option.value,
      hideLabel: option.hideLabel
    }, option.label ?? option.value);
  }));
};

const NumberInput = _ref => {
  let {
    onChange,
    value,
    step,
    min,
    max
  } = _ref;
  return /*#__PURE__*/React.createElement(Input, {
    type: "number"
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    ,
    step: step,
    value: value,
    onChange: onChange,
    min: min,
    max: max
  });
};

const Tooltip = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    children,
    style = {},
    ...rest
  } = _ref;
  return /*#__PURE__*/createPortal(/*#__PURE__*/React__default.createElement("div", _extends({
    style: {
      ...style,
      zIndex: 100100
    },
    ref: ref
  }, rest), children), document.body);
});
const TooltipBody = styled.div.withConfig({
  displayName: "Tooltip__TooltipBody",
  componentId: "sc-tkogle-0"
})(["position:relative;top:6px;display:flex;flex-direction:row;justify-content:center;align-items:center;padding:6px 4px;background:#333333;border-radius:2px;", " color:#fff;"], Fonts.body);
const TooltipArrow = styled.div.withConfig({
  displayName: "Tooltip__TooltipArrow",
  componentId: "sc-tkogle-1"
})(["width:12px;height:6px;margin:0 auto;background:#333333;clip-path:polygon(50% 0%,0% 100%,100% 100%);"]);

function useTooltip() {
  let {
    isDisabled,
    onClick
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const [isOpen, setIsOpen] = useState(false);
  const [triggerElement, setTriggerElement] = useState(null);
  const [tooltipElement, setTooltipElement] = useState(null);
  const [arrowElement, setArrowElement] = useState(null);
  const {
    styles,
    attributes
  } = usePopper(triggerElement, tooltipElement, {
    strategy: "absolute",
    placement: "bottom",
    modifiers: [{
      name: "arrow",
      options: {
        element: arrowElement,
        padding: 6
      }
    }]
  });
  const tooltipTrigger = useTooltipTrigger({
    isDisabled,
    delay: 0
  }, {
    isOpen,
    open: () => {
      setIsOpen(true);
    },
    close: () => {
      setIsOpen(false);
    }
  }, {
    current: triggerElement
  });
  const triggerProps = {
    ref: setTriggerElement,
    ...tooltipTrigger.triggerProps,
    onClick: onClick === undefined ? tooltipTrigger.tooltipProps.onClick : event => {
      tooltipTrigger.tooltipProps.onClick?.(event);
      onClick();
    }
  };
  const tooltipProps = {
    ref: setTooltipElement,
    style: styles.popper,
    ...attributes.popper,
    ...tooltipTrigger.tooltipProps
  };
  const arrowProps = {
    ref: setArrowElement,
    style: styles.arrow
  };
  return {
    isOpen,
    triggerProps,
    tooltipProps,
    arrowProps
  };
}

// Wraps the Field component in labels describing the field's meta state
// Add any other fields that the Field component should expect onto the ExtraFieldProps generic type

function FieldMetaWrapper(_ref) {
  let {
    children,
    field,
    input,
    noWrap,
    layout = "row",
    renderLabel,
    isLabelHidden
  } = _ref;
  const editorContext = useEditorContext();
  const configAfterAuto = useConfigAfterAuto();
  const externalData = useEditorExternalData();
  const {
    isOpen,
    tooltipProps,
    triggerProps,
    arrowProps
  } = useTooltip({
    isDisabled: field.description === undefined
  });
  const {
    actions: {
      runChange
    },
    form,
    focussedField
  } = editorContext;
  const isMixedValueSupported = isMixedValueSupportedByComponent(isResponsiveField(field) ? field.subComponent : field.component);
  const isMixedValue = isMixedFieldValue(input.value);
  const fieldNames = toArray(field.name);
  function handleButtonMixedClick() {
    runChange(() => {
      fieldNames.forEach((fieldName, _, names) => {
        const firstFieldValue = dotNotationGet(form.values, names[0]);
        form.change(fieldName, firstFieldValue);
      });
    });
  }
  const resolvedLayout = field.layout ?? layout;
  const content = /*#__PURE__*/React__default.createElement("div", {
    style: {
      width: "100%",
      display: "flex",
      alignItems: resolvedLayout === "row" ? "flex-end" : "flex-start",
      flexDirection: "column"
    }
  }, !isMixedValue || isMixedValue && isMixedValueSupported ? children : /*#__PURE__*/React__default.createElement(TextButton, {
    component: "button",
    variant: "label",
    color: "black40",
    onClick: handleButtonMixedClick
  }, "Mixed"));
  if (noWrap) {
    return content;
  }
  const label = field.label || input.name;
  const {
    schemaProp
  } = field;
  const isExternalField = isExternalSchemaProp(schemaProp, editorContext.types) || schemaProp.type === "text" && !input.value.id?.startsWith("local.");
  const componentPaths = fieldNames.map(fieldName => fieldName[0].split(".").slice(0, -1).join("."));
  const fieldValues = fieldNames.map(f => dotNotationGet(configAfterAuto, f));
  const configs = componentPaths.map(c => dotNotationGet(configAfterAuto, c));
  const externalValues = isExternalField ? configs.map(c => externalData[getExternalReferenceLocationKey$1(focussedField.length === 0 ? "$" : c._id, schemaProp.prop, isTrulyResponsiveValue$2(input.value) ? responsiveValueFindDeviceWithDefinedValue$1(input.value, editorContext.breakpointIndex, editorContext.devices)?.id : undefined)]) : undefined;
  const currentBreakpointFieldValues = fieldValues.map(v => responsiveValueForceGet$2(v, editorContext.breakpointIndex));
  const isLoadingExternalValue = isExternalField && externalValues?.length === 0 && currentBreakpointFieldValues.every(v => !isEmptyExternalReference(v) && !isIdReferenceToDocumentExternalValue(v.id));
  return /*#__PURE__*/React__default.createElement(FieldWrapper$1, {
    margin: false,
    layout: resolvedLayout
  }, !isLabelHidden && /*#__PURE__*/React__default.createElement(FieldLabelWrapper, {
    isFullWidth: resolvedLayout === "column"
  }, renderLabel?.({
    label
  }) ?? /*#__PURE__*/React__default.createElement(FieldLabel, _extends({
    htmlFor: toArray(field.name).join(","),
    isError: externalValues !== undefined && "error" in externalValues
  }, triggerProps), /*#__PURE__*/React__default.createElement("span", {
    style: {
      lineHeight: "100%",
      overflow: "hidden",
      textOverflow: "ellipsis"
    }
  }, label), isOpen && /*#__PURE__*/React__default.createElement(Tooltip, tooltipProps, /*#__PURE__*/React__default.createElement(TooltipArrow, arrowProps), /*#__PURE__*/React__default.createElement(TooltipBody, null, field.description))), isLoadingExternalValue && /*#__PURE__*/React__default.createElement("div", {
    style: {
      marginLeft: "6px"
    }
  }, /*#__PURE__*/React__default.createElement(Loader, null)), resolvedLayout === "column" && (isExternalSchemaProp(schemaProp, editorContext.types) || schemaProp.type === "text") && !isMixedValue && /*#__PURE__*/React__default.createElement(WidgetsSelect, {
    schemaProp: schemaProp,
    value: currentBreakpointFieldValues[0],
    onChange: widgetId => {
      if (widgetId === "@easyblocks/local-text") {
        const newFieldValue = {
          id: `local.${uniqueId()}`,
          value: {},
          widgetId
        };
        input.onChange(newFieldValue);
        return;
      }
      if (isTrulyResponsiveValue$2(input.value)) {
        const newFieldValue = {
          ...input.value,
          [editorContext.breakpointIndex]: {
            id: null,
            widgetId
          }
        };
        input.onChange(newFieldValue);
      } else {
        const newFieldValue = {
          id: null,
          widgetId
        };
        input.onChange(newFieldValue);
      }
    },
    isRootComponent: fieldNames.some(f => f.split(".").length === 1)
  })), /*#__PURE__*/React__default.createElement(FieldInputWrapper, {
    layout: resolvedLayout
  }, content), !isMixedFieldValue && isExternalField && externalValues.length > 0 && "error" in externalValues[0] && /*#__PURE__*/React__default.createElement(FieldError, null, externalValues[0].error.message));
}
function WidgetsSelect(_ref2) {
  let {
    value,
    onChange,
    schemaProp,
    isRootComponent
  } = _ref2;
  const editorContext = useEditorContext();
  const [selectedWidgetId, setSelectedWidgetId] = useState(value.widgetId);
  const widgets = editorContext.types[schemaProp.type].widgets;
  const availableWidgets = isRootComponent ? widgets.filter(w => {
    return w.id !== "@easyblocks/document-data";
  }) : [...widgets];
  if (schemaProp.type === "text") {
    availableWidgets.unshift({
      id: "@easyblocks/local-text",
      label: "Local text",
      component: () => {
        return null;
      }
    });
  }
  if (availableWidgets.length <= 1) {
    return null;
  }
  return /*#__PURE__*/React__default.createElement(FieldLabelIconWrapper, null, /*#__PURE__*/React__default.createElement(Select, {
    value: selectedWidgetId,
    onChange: widgetId => {
      setSelectedWidgetId(widgetId);
      onChange(widgetId);
    }
  }, availableWidgets.map(widget => {
    return /*#__PURE__*/React__default.createElement(SelectItem, {
      value: widget.id,
      key: widget.id
    }, widget.label ?? widget.id);
  })));
}
function isResponsiveField(field) {
  return typeof field.component === "string" && field.component === "responsive2";
}
function isMixedValueSupportedByComponent(component) {
  if (typeof component === "string") {
    return COMPONENTS_SUPPORTING_MIXED_VALUES.includes(component);
  }
  return false;
}
const TextButton = styled(Typography).withConfig({
  displayName: "wrapFieldWithMeta__TextButton",
  componentId: "sc-1asy4oy-0"
})(["padding:0;margin:0;background:transparent;border:0;font-weight:500;&:hover{color:black;cursor:pointer;text-decoration:underline;}"]);
function wrapFieldsWithMeta(Field, extraProps) {
  return props => {
    return /*#__PURE__*/React__default.createElement(FieldMetaWrapper, _extends({}, props, extraProps), /*#__PURE__*/React__default.createElement(Field, props));
  };
}
const FieldWrapper$1 = styled.div.withConfig({
  displayName: "wrapFieldWithMeta__FieldWrapper",
  componentId: "sc-1asy4oy-1"
})(["display:flex;flex-direction:", ";gap:", ";justify-content:space-between;align-items:flex-start;", " position:relative;padding:4px 16px;"], _ref3 => {
  let {
    layout
  } = _ref3;
  return layout;
}, _ref4 => {
  let {
    layout
  } = _ref4;
  return layout === "row" ? "10px" : "4px";
}, _ref5 => {
  let {
    layout
  } = _ref5;
  return layout === "column" && css(["flex-grow:1;"]);
});
const FieldLabelWrapper = styled.div.withConfig({
  displayName: "wrapFieldWithMeta__FieldLabelWrapper",
  componentId: "sc-1asy4oy-2"
})(["all:unset;position:relative;display:flex;flex-direction:row;align-items:center;", " min-height:28px;overflow:hidden;"], _ref6 => {
  let {
    isFullWidth
  } = _ref6;
  return isFullWidth && {
    width: "100%"
  };
});
const FieldLabel = styled.label.withConfig({
  displayName: "wrapFieldWithMeta__FieldLabel",
  componentId: "sc-1asy4oy-3"
})(["all:unset;", ";color:", ";text-overflow:ellipsis;overflow:hidden;cursor:default;"], Fonts.body, _ref7 => {
  let {
    isError
  } = _ref7;
  return isError ? "red" : "#000";
});
const FieldLabelIconWrapper = styled.span.withConfig({
  displayName: "wrapFieldWithMeta__FieldLabelIconWrapper",
  componentId: "sc-1asy4oy-4"
})(["display:flex;font-size:14px;line-height:1;margin-left:auto;padding-left:8px;svg{width:14px;height:14px;flex-shrink:0;}"]);
const FieldError = styled.span.withConfig({
  displayName: "wrapFieldWithMeta__FieldError",
  componentId: "sc-1asy4oy-5"
})(["display:block;color:red;font-size:var(--tina-font-size-1);margin-top:8px;font-weight:var(--tina-font-weight-regular);"]);
const FieldInputWrapper = styled.div.withConfig({
  displayName: "wrapFieldWithMeta__FieldInputWrapper",
  componentId: "sc-1asy4oy-6"
})(["display:flex;justify-content:flex-end;align-items:center;", ";min-height:28px;"], _ref8 => {
  let {
    layout
  } = _ref8;
  return layout === "row" ? css(["flex-grow:1;"]) : css(["width:100%;"]);
});

const parse$1 = value => value && +value;

const NumberField = wrapFieldsWithMeta(_ref => {
  let {
    input,
    field
  } = _ref;
  return /*#__PURE__*/React__default.createElement(NumberInput, _extends({}, input, {
    step: field.step,
    min: field.min,
    max: field.max
  }));
});
const NumberFieldPlugin = {
  name: "number",
  Component: NumberField,
  parse: parse$1
};

const parse = value => value || "";

const SelectField = wrapFieldsWithMeta(SelectFieldComponent);
const SelectFieldPlugin = {
  name: "select",
  type: "select",
  Component: SelectField,
  parse
};

const RadioGroupField = wrapFieldsWithMeta(RadioGroup);
const RadioGroupFieldPlugin = {
  name: "radio-group",
  Component: RadioGroupField
};

function TextField(_ref) {
  let {
    input,
    field,
    noWrap
  } = _ref;
  const editorContext = useEditorContext();
  const {
    value,
    onChange,
    ...restInputProperties
  } = input;
  const inputProps = useTextValue(value, onChange, editorContext.contextParams.locale, editorContext.locales, field.placeholder, field.normalize);
  const isTextSchemaProp = field.schemaProp.type === "text";
  return /*#__PURE__*/React__default.createElement(FieldMetaWrapper, {
    input: input,
    field: field,
    layout: isTextSchemaProp ? "column" : "row",
    noWrap: noWrap
  }, /*#__PURE__*/React__default.createElement(Input, _extends({}, restInputProperties, inputProps, {
    controlSize: "full-width",
    align: !isTextSchemaProp ? "right" : "left",
    withBorder: isTextSchemaProp
  })));
}
const TextFieldPlugin = {
  name: "text",
  Component: TextField,
  parse
};

const ToggleField = wrapFieldsWithMeta(Toggle);
const ToggleFieldPlugin = {
  name: "toggle",
  type: "checkbox",
  Component: ToggleField
};

const CUSTOM_OPTION_VALUE = "__custom__";
function extraValuesIncludes(extraValues, value) {
  for (let i = 0; i < extraValues.length; i++) {
    const extraValue = extraValues[i];
    if (typeof extraValue === "string") {
      if (extraValue === value) {
        return true;
      }
    } else {
      if (extraValue.value === value) {
        return true;
      }
    }
  }
  return false;
}
function useTokenTypes() {
  const editorContext = useEditorContext();
  const tokenTypes = Object.fromEntries(Object.entries(editorContext.types).filter(typeDefinitionEntry => {
    return typeDefinitionEntry[1].type === "token";
  }));
  return tokenTypes;
}
function TokenFieldComponent(_ref) {
  let {
    input,
    field
  } = _ref;
  const editorContext = useEditorContext();
  const tokenTypes = useTokenTypes();
  const tokenTypeDefinition = tokenTypes[field.schemaProp.type];
  const normalizeCustomValue = field.normalizeCustomValue || (x => x);
  const allowCustom = field.allowCustom ?? false;
  const extraValues = field.extraValues ?? [];
  const [inputValue, setInputValue] = useState(isMixedFieldValue(input.value) ? "" : input.value?.value.toString() ?? "");
  const customValueTextFieldRef = useRef(null);
  const options = Object.entries(field.tokens).map(_ref2 => {
    let [tokenId, tokenValue] = _ref2;
    if (tokenTypeDefinition.token === "fonts") {
      const fontTokenLabel = getFontTokenLabel(tokenId, tokenValue, editorContext);
      return {
        id: tokenId,
        label: fontTokenLabel
      };
    }
    return {
      id: tokenId,
      label: tokenValue.label ?? tokenId
    };
  });

  // Extra values are displayed in select
  if (field.extraValues) {
    field.extraValues.forEach(extraValue => {
      if (typeof extraValue === "string") {
        options.push({
          id: extraValue,
          label: extraValue
        });
      } else {
        options.push({
          id: extraValue.value,
          label: extraValue.label
        });
      }
    });
  }

  // If token exist but is removed from a theme -> let's add special option for this
  if (!isMixedFieldValue(input.value) && typeof input.value.tokenId === "string" && !field.tokens[input.value.tokenId]) {
    options.unshift({
      id: input.value.tokenId,
      label: `(removed) ${input.value.tokenId}`
    });
  }
  const isExtraValueSelected = !isMixedFieldValue(input.value) && !input.value.tokenId && extraValuesIncludes(extraValues, responsiveValueGetDefinedValue$1(input.value.value, editorContext.breakpointIndex, editorContext.devices, getDevicesWidths$1(editorContext.devices) /** FOR NOW TOKENS ARE RELATIVE TO SCREEN **/));
  const shouldShowCustomValueInput = !isMixedFieldValue(input.value) && !(input.value.tokenId || isExtraValueSelected) && allowCustom;
  const selectValue = isMixedFieldValue(input.value) ? MIXED_VALUE : input.value.tokenId ?? (isExtraValueSelected ? input.value.value : CUSTOM_OPTION_VALUE);
  const onSelectChange = selectedValue => {
    if (selectedValue === CUSTOM_OPTION_VALUE) {
      if (isMixedFieldValue(input.value)) {
        input.onChange({
          value: "",
          widgetId: tokenTypeDefinition.widget?.id
        });
        setInputValue("");
        return;
      }
      let value = input.value.value;

      // responsive token values are transformed into value from current breakpoint
      if (isTrulyResponsiveValue$2(value)) {
        value = responsiveValueGetDefinedValue$1(
        // Not sure about usage of responsiveValueGet without widths
        value, editorContext.breakpointIndex, editorContext.devices, getDevicesWidths$1(editorContext.devices) /** FOR NOW TOKENS ARE RELATIVE TO SCREEN **/);
      }
      input.onChange({
        value,
        widgetId: input.value.widgetId
      });
      setInputValue(value);
      queueMicrotask(() => {
        customValueTextFieldRef.current?.focus();
      });
    } else if (extraValuesIncludes(extraValues, selectedValue)) {
      input.onChange({
        value: selectedValue,
        widgetId: tokenTypeDefinition.widget?.id
      });
    } else {
      input.onChange({
        tokenId: selectedValue,
        value: field.tokens[selectedValue].value,
        widgetId: tokenTypeDefinition.widget?.id
      });
    }
  };
  const CustomInputWidgetComponent = tokenTypeDefinition?.widget?.component;
  const customInputElement = shouldShowCustomValueInput ? /*#__PURE__*/React__default.createElement("div", null, /*#__PURE__*/React__default.createElement("div", {
    style: {
      height: 4
    }
  }), CustomInputWidgetComponent ? /*#__PURE__*/React__default.createElement(CustomInputWidgetComponent, {
    value: inputValue,
    onChange: value => {
      input.onChange({
        value,
        widgetId: tokenTypeDefinition.widget?.id
      });
    },
    params: "params" in field.schemaProp ? field.schemaProp.params : undefined
  }) : /*#__PURE__*/React__default.createElement(Input, {
    value: inputValue,
    onChange: e => {
      setInputValue(e.target.value);
    },
    onBlur: () => {
      const normalizedValue = normalizeCustomValue(inputValue);
      setInputValue(normalizedValue);
      input.onChange({
        value: normalizedValue
      });
    },
    ref: customValueTextFieldRef,
    align: "right"
  })) : null;
  if (tokenTypeDefinition.token === "colors") {
    return /*#__PURE__*/React__default.createElement(Fragment, null, /*#__PURE__*/React__default.createElement(Select, {
      value: selectValue,
      onChange: onSelectChange
    }, isMixedFieldValue(input.value) && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(SelectColorTokenItem, {
      value: MIXED_VALUE,
      isDisabled: true
    }, "Mixed"), /*#__PURE__*/React__default.createElement(SelectSeparator, null)), /*#__PURE__*/React__default.createElement(Fragment, null, options.map(o => {
      return /*#__PURE__*/React__default.createElement(SelectColorTokenItem, {
        key: o.id,
        value: o.id
        // Color tokens are always strings
        ,
        previewColor: field.tokens[o.id]?.value ?? o.id
      }, o.label);
    }), allowCustom && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(SelectSeparator, null), /*#__PURE__*/React__default.createElement(SelectColorTokenItem, {
      value: CUSTOM_OPTION_VALUE,
      previewColor: selectValue === CUSTOM_OPTION_VALUE ? input.value.value : undefined
    }, "Custom")))), customInputElement);
  }
  return /*#__PURE__*/React__default.createElement(Root, null, /*#__PURE__*/React__default.createElement(Select, {
    value: selectValue,
    onChange: onSelectChange
  }, isMixedFieldValue(input.value) && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(SelectItem, {
    value: MIXED_VALUE,
    isDisabled: true
  }, "Mixed"), /*#__PURE__*/React__default.createElement(SelectSeparator, null)), selectValue === CUSTOM_OPTION_VALUE && !allowCustom && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(SelectItem, {
    value: CUSTOM_OPTION_VALUE,
    isDisabled: true
  }, "Custom"), /*#__PURE__*/React__default.createElement(SelectSeparator, null)), /*#__PURE__*/React__default.createElement(Fragment, null, options.map(o => {
    return /*#__PURE__*/React__default.createElement(SelectItem, {
      key: o.id,
      value: o.id
    }, o.label);
  }), allowCustom && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(SelectSeparator, null), /*#__PURE__*/React__default.createElement(SelectItem, {
    value: CUSTOM_OPTION_VALUE
  }, "Custom")))), customInputElement);
}
function getFontTokenLabel(name, token, editorContext) {
  const filledResponsiveFontValue = responsiveValueFill$1(token.value, editorContext.devices, getDevicesWidths$1(editorContext.devices));
  const currentDeviceFontValue = responsiveValueForceGet$2(filledResponsiveFontValue, editorContext.breakpointIndex);
  if (isValidFontTokenValue(currentDeviceFontValue)) {
    return `${token.label ?? name} (${stripPxUnit(currentDeviceFontValue.fontSize)}/${stripPxUnit(currentDeviceFontValue.lineHeight)})`;
  }
  return token.label ?? name;
}
function stripPxUnit(value) {
  if (typeof value === "number") {
    return value;
  }
  return value.replace(new RegExp("px"), "");
}
function isValidFontTokenValue(value) {
  return typeof value === "object" && value !== null && "fontSize" in value && "lineHeight" in value;
}
const Root = styled.div.withConfig({
  displayName: "TokenFieldPlugin__Root",
  componentId: "sc-1hbwipe-0"
})(["display:flex;flex-direction:column;align-items:flex-end;"]);
const TokenFieldPlugin = {
  name: "token",
  type: "token",
  Component: wrapFieldsWithMeta(TokenFieldComponent)
};
const SelectColorTokenItem = /*#__PURE__*/forwardRef((props, ref) => {
  return /*#__PURE__*/React__default.createElement(SelectItem, {
    value: props.value,
    isDisabled: props.isDisabled,
    ref: ref
  }, /*#__PURE__*/React__default.createElement("span", {
    style: {
      display: "flex",
      alignItems: "center",
      gap: "6px"
    }
  }, /*#__PURE__*/React__default.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "15",
    height: "16",
    viewBox: "0 0 15 16",
    fill: "none"
  }, /*#__PURE__*/React__default.createElement("circle", {
    cx: "7.28931",
    cy: "8.00024",
    r: "6.78931",
    fill: props.previewColor ?? "#fff",
    stroke: Colors.black100
  })), /*#__PURE__*/React__default.createElement("span", null, props.children)));
});

const RICH_TEXT_PART_CONFIG_PATH_REGEXP = /\.elements\.[a-z(\-_A-Z)?]+\.\d+(\.elements\.\d+){2,3}(\.\{\d+,\d+\})?$/;
function isConfigPathRichTextPart(configPath) {
  return RICH_TEXT_PART_CONFIG_PATH_REGEXP.test(configPath);
}

/**
 *
 * @param collection Array of values
 * @param mapper Optional callback function that will be invoked for each item of given array to map it into comparable string
 */
function getUniqueValues(collection, mapper) {
  if (mapper) {
    const uniqueValues = new Set();
    const uniqueItems = [];
    collection.forEach((item, index) => {
      const mappedItem = mapper(item, index);
      if (!uniqueValues.has(mappedItem)) {
        uniqueValues.add(mappedItem);
        uniqueItems.push(item);
      }
    });
    return uniqueItems;
  }
  return Array.from(new Set(collection));
}

function mergeCommonFields(_ref) {
  let {
    fields
  } = _ref;
  const mergedCommonFields = [];
  const fieldsGroupedByProperty = groupFieldsByPropertyName(fields.flat());
  for (const currentFields of Object.values(fieldsGroupedByProperty)) {
    if (currentFields.length < fields.length) {
      continue;
    }

    /**
     * Some fields can be hidden depending on the context of usage
     * ex. margin bottom is not applicable to the last element in stack
     */
    const visibleFields = currentFields.filter(field => {
      return !field.hidden;
    });
    if (visibleFields.length === 0) {
      continue;
    }
    const fieldDefinitionIds = visibleFields.map(field => getFieldSchemaWithDefinition(field).definition.id);

    /**
     * All fields for given property have to be defined within the same schema, because ex.
     * field can have the same prop name in schema A, but different meaning in schema B
     */
    const uniqueDefinitionIds = getUniqueValues(fieldDefinitionIds);

    // It's common when interacting with $richText to pass fields of parent or ancestor down to @easyblocks/rich-text-part.
    // Verify if the all unique ids aren't fields of $richText components.
    if (uniqueDefinitionIds.length > 1 && !uniqueDefinitionIds.every(id => id.startsWith("@easyblocks/rich-text"))) {
      continue;
    }
    const firstVisibleField = visibleFields[0];
    mergedCommonFields.push({
      ...firstVisibleField,
      name: visibleFields.length === 1 ? firstVisibleField.name : getUniqueValues(visibleFields.flatMap(field => field.name))
    });
  }
  return mergedCommonFields;
}
function groupFieldsByPropertyName(fields) {
  return fields.reduce((repeatedFields, field) => {
    const currentFieldPropertyName = getPropertyName(field.schemaProp.prop);
    const fields = repeatedFields[currentFieldPropertyName];
    repeatedFields[currentFieldPropertyName] = fields !== undefined ? [...fields, field] : [field];
    return repeatedFields;
  }, {});
}
function getPropertyName(fieldName) {
  const fieldNameParts = fieldName.split(".");
  let lastPart = last(fieldNameParts);

  // If property name starts with `$` sign it's a special property of fake field.
  if (lastPart.startsWith("$")) {
    lastPart = lastPart.slice(1);
  }
  if (fieldNameParts[0] === "$previous") {
    return `${fieldNameParts[0]}.${lastPart}`;
  }
  return lastPart;
}
function getFieldSchemaWithDefinition(field) {
  return field.schemaProp;
}

const BlockField = _ref => {
  let {
    field,
    input,
    isLabelHidden
  } = _ref;
  const [isSubcomponentPanelExpanded, setIsSubcomponentPanelExpanded] = React__default.useState(false);
  const editorContext = useEditorContext();
  const {
    actions
  } = editorContext;
  const {
    openComponentPicker
  } = actions;
  const isMixed = isMixedFieldValue(input.value);
  const config = (() => {
    if (isMixed) {
      return null;
    }

    // @ts-expect-error We can safely ignore the error since we know the value is not mixed
    return input.value[0] || null;
  })();
  const normalizedName = toArray(field.name);
  // Let's create paths
  const paths = normalizedName.map(x => `${x}.0`);
  const componentPickerPath = normalizedName[0];
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, !isLabelHidden && /*#__PURE__*/React__default.createElement("div", {
    style: {
      display: "flex",
      alignItems: "center",
      padding: "4px 16px",
      minHeight: "28px"
    }
  }, /*#__PURE__*/React__default.createElement(Typography, null, field.label || field.name)), /*#__PURE__*/React__default.createElement("div", {
    style: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      padding: "4px 16px"
    }
  }, config !== null && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("div", {
    style: {
      flex: "1 1 auto",
      minWidth: 0
    }
  }, /*#__PURE__*/React__default.createElement(SubComponentPanelButton, {
    paths: paths,
    isExpanded: isSubcomponentPanelExpanded,
    onExpand: () => {
      setIsSubcomponentPanelExpanded(true);
    },
    onCollapse: () => {
      setIsSubcomponentPanelExpanded(false);
    }
  })), !field.schemaProp.required && /*#__PURE__*/React__default.createElement("div", {
    style: {
      flex: "0 0 auto",
      minWidth: 0
    }
  }, /*#__PURE__*/React__default.createElement(ButtonGhost, {
    onClick: () => {
      if (editorContext.focussedField.some(isConfigPathRichTextPart)) {
        input.onChange([]);
      } else {
        actions.removeItems(paths);
      }
    },
    icon: Icons.Remove,
    "aria-label": "Remove"
  }))), config === null && (isMixed ? /*#__PURE__*/React__default.createElement(ThumbnailButton, {
    label: "Mixed",
    disabled: true
  }) : /*#__PURE__*/React__default.createElement(AddButton$1, {
    onAdd: () => {
      openComponentPicker({
        path: componentPickerPath
      }).then(newConfig => {
        if (newConfig) {
          if (editorContext.focussedField.some(isConfigPathRichTextPart)) {
            input.onChange([newConfig]);
          } else {
            actions.replaceItems(paths, newConfig);
          }
          setIsSubcomponentPanelExpanded(true);
        }
      });
    }
  }))));
};
function AddButton$1(_ref2) {
  let {
    onAdd
  } = _ref2;
  return /*#__PURE__*/React__default.createElement(ButtonGhost, {
    style: {
      width: "100%",
      paddingLeft: "0"
    },
    onClick: onAdd,
    height: "32px",
    noPadding: true
  }, /*#__PURE__*/React__default.createElement("div", {
    style: {
      display: "flex",
      alignItems: "center",
      gap: "8px",
      width: "100%"
    }
  }, /*#__PURE__*/React__default.createElement("div", {
    style: {
      display: "grid",
      placeItems: "center",
      width: "32px",
      height: "32px",
      marginLeft: "-1px",
      border: `1px dashed ${Colors.black20}`,
      borderRadius: "2px"
    }
  }, /*#__PURE__*/React__default.createElement(Icons.Add, {
    size: 16
  })), "Add"));
}
const SubComponentPanelButton = _ref3 => {
  let {
    paths,
    isExpanded,
    onExpand,
    onCollapse
  } = _ref3;
  const sidebarPanelsRoot = document.getElementById("sidebar-panels-root");
  const editorContext = useEditorContext();
  const externalData = useEditorExternalData();
  const entryAfterAuto = useConfigAfterAuto();
  const config = dotNotationGet(editorContext.form.values, paths[0]);
  const componentDefinition = findComponentDefinition(config, editorContext);
  const label = componentDefinition?.label ?? componentDefinition?.id ?? `Can’t find custom component with id: ${config._component} in your project. Please contact your developers to resolve this issue.`;
  const showError = componentDefinition === undefined;
  const sidebarPreview = componentDefinition ? getSidebarPreview(componentDefinition, dotNotationGet(entryAfterAuto, paths[0]), externalData, editorContext) : undefined;
  const defaultThumbnail = componentDefinition?.thumbnail ? {
    type: "image",
    src: componentDefinition.thumbnail
  } : undefined;
  const thumbnail = sidebarPreview?.thumbnail ?? defaultThumbnail;
  const description = sidebarPreview?.description;
  return showError ? /*#__PURE__*/React__default.createElement(Error$2, null, label) : /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(ThumbnailButton, {
    onClick: onExpand,
    label: label,
    description: description,
    thumbnail: thumbnail
  }), sidebarPanelsRoot && /*#__PURE__*/ReactDOM.createPortal(/*#__PURE__*/React__default.createElement(Panel, {
    isExpanded: isExpanded,
    onCollapse: onCollapse,
    paths: paths
  }), sidebarPanelsRoot));
};
function getSidebarPreview(componentDefinition, entryAfterAuto, externalData, editorContext) {
  const previewValues = Object.fromEntries(componentDefinition.schema.map(s => {
    const value = responsiveValueForceGet$2(entryAfterAuto[s.prop], editorContext.breakpointIndex);
    if (isExternalSchemaProp(s, editorContext.types)) {
      const externalDataValue = resolveExternalValue$1(value, entryAfterAuto._id, s, externalData);
      return [s.prop, externalDataValue];
    }
    if (s.type === "text") {
      return [s.prop, resolveLocalisedValue$2(value.value, editorContext)?.value];
    }
    return [s.prop, value];
  }));
  return componentDefinition.preview?.({
    values: previewValues,
    externalData
  });
}
const Error$2 = styled.div.withConfig({
  displayName: "BlockFieldPlugin__Error",
  componentId: "sc-5mryxt-0"
})(["", " padding:7px 6px 7px;color:hsl(0deg 0% 50% / 0.8);white-space:normal;background:hsl(0deg 100% 50% / 0.2);margin-right:10px;border-radius:2px;"], Fonts.body);
const PanelContext = /*#__PURE__*/React__default.createContext(undefined);
function Panel(_ref4) {
  let {
    onCollapse,
    isExpanded,
    paths
  } = _ref4;
  const editorContext = useEditorContext();
  const fields = React__default.useMemo(() => {
    if (!isExpanded) {
      return [];
    }
    const fieldsPerName = toArray(paths).map(path => {
      return buildTinaFields(path, editorContext);
    });
    const mergedFields = mergeCommonFields({
      fields: fieldsPerName
    });
    return mergedFields;
  }, [isExpanded, paths]);
  return /*#__PURE__*/React__default.createElement(PanelContext.Provider, {
    value: {
      onClose: onCollapse
    }
  }, /*#__PURE__*/React__default.createElement(GroupPanel, {
    isExpanded: isExpanded
  }, /*#__PURE__*/React__default.createElement(PanelBody, null, isExpanded ? /*#__PURE__*/React__default.createElement("div", null, /*#__PURE__*/React__default.createElement(FieldsBuilder, {
    form: editorContext.form,
    fields: fields
  }), /*#__PURE__*/React__default.createElement(SidebarFooter, {
    paths: paths
  })) : null)));
}
const BlockFieldPlugin = {
  __type: "field",
  name: "block",
  Component: BlockField
};
const PanelBody = styled.div.withConfig({
  displayName: "BlockFieldPlugin__PanelBody",
  componentId: "sc-5mryxt-1"
})(["background:white;position:relative;height:100%;overflow-y:auto;"]);
const GroupPanelKeyframes = keyframes(["0%{transform:translate3d( 100%,0,0 );}100%{transform:translate3d( 0,0,0 );}"]);
const GroupPanel = styled.div.withConfig({
  displayName: "BlockFieldPlugin__GroupPanel",
  componentId: "sc-5mryxt-2"
})(["position:absolute;width:100%;top:0;bottom:0;left:0;overflow:hidden;pointer-events:", ";> *{", ";", ";}"], p => p.isExpanded ? "all" : "none", p => p.isExpanded && css(["animation-name:", ";animation-duration:150ms;animation-delay:0ms;animation-iteration-count:1;animation-timing-function:ease-out;animation-fill-mode:backwards;"], GroupPanelKeyframes), p => !p.isExpanded && css(["transition:transform 150ms ease-out;transform:translate3d(100%,0,0);"]));

function IdentityField(_ref) {
  let {
    input,
    field
  } = _ref;
  const editorContext = useEditorContext();
  const panelContext = useContext(PanelContext);
  const isMixed = isMixedFieldValue(input.value);
  const config = isMixed ? null : input.value;
  if (config == null) {
    return null;
  }
  const componentDefinition = findComponentDefinitionById(config._component, editorContext);
  const configPaths = toArray(field.name);
  const {
    parent
  } = parsePath(configPaths[0], editorContext.form);
  const isWithinNestedPanel = panelContext !== undefined;
  const parentComponentDefinition = parent ? findComponentDefinitionById(parent.templateId, editorContext) : undefined;
  const parentSchemaProp = parentComponentDefinition?.schema.find(schemaProp => schemaProp.prop === parent.fieldName);
  const isNonRemovable = componentDefinition?.id.startsWith("@easyblocks/rich-text") && componentDefinition.id !== "@easyblocks/rich-text" || (parentSchemaProp ? parentSchemaProp.type === "component" && parentSchemaProp.required : true);
  const isNonChangable = componentDefinition?.id === "@easyblocks/rich-text-part" || componentDefinition?.id === editorContext.rootComponent.id;
  function handleChangeComponentType() {
    if (isNonChangable) {
      return;
    }
    if (!parent) {
      return;
    }
    const componentPickerPath = parent.path + "." + parent.fieldName;
    editorContext.actions.openComponentPicker({
      path: componentPickerPath
    }).then(selectedConfig => {
      if (!selectedConfig) {
        return;
      }
      editorContext.actions.replaceItems(configPaths, selectedConfig);
    });
  }
  function handleRemove() {
    if (isNonRemovable) {
      return;
    }
    editorContext.actions.removeItems(configPaths);
  }
  const titleContent = /*#__PURE__*/React__default.createElement("div", {
    style: {
      display: "flex",
      alignItems: "center",
      gap: "2px"
    }
  }, /*#__PURE__*/React__default.createElement(Typography, {
    style: {
      lineHeight: "14px",
      fontWeight: "700"
    }
  }, componentDefinition?.label ?? componentDefinition?.id), !isNonChangable && /*#__PURE__*/React__default.createElement(Icons.ChevronDown, {
    size: 16
  }));
  return /*#__PURE__*/React__default.createElement("div", {
    style: {
      display: "flex",
      gap: "8px",
      minHeight: "28px",
      padding: "10px"
    }
  }, /*#__PURE__*/React__default.createElement("div", {
    style: {
      display: "flex",
      alignItems: "center",
      flex: "1 0"
    }
  }, isWithinNestedPanel && /*#__PURE__*/React__default.createElement(ButtonGhost, {
    icon: Icons.ChevronLeft,
    onClick: () => {
      panelContext.onClose();
    },
    style: {
      marginRight: "auto"
    }
  }), isNonChangable && /*#__PURE__*/React__default.createElement("div", {
    style: {
      padding: "7px 6px"
    }
  }, titleContent), !isNonChangable && /*#__PURE__*/React__default.createElement(ButtonGhost, {
    onClick: handleChangeComponentType
  }, titleContent), /*#__PURE__*/React__default.createElement(ButtonGhost, {
    "aria-label": "Remove component",
    icon: Icons.Remove,
    onClick: handleRemove,
    style: {
      marginLeft: "auto",
      opacity: isNonRemovable ? 0 : 1,
      pointerEvents: isNonRemovable ? "none" : "auto"
    }
  })));
}
const IdentityFieldPlugin = {
  name: "identity",
  Component: IdentityField
};

function MissingWidget(props) {
  return /*#__PURE__*/React__default.createElement(Typography, null, "Missing widget for type \"", props.type, "\".");
}

const ExternalFieldComponent = props => {
  const {
    tinaForm,
    field,
    input,
    input: {
      value
    }
  } = props;
  const editorContext = useEditorContext();
  const externalData = useEditorExternalData();
  const fieldNames = toArray(field.name);
  const isSchemaPropRootParam = field.schemaProp.type.startsWith("param__");
  const ExternalField = !isMixedFieldValue(input.value) ? isSchemaPropRootParam ? getWidgetComponentForRootParam(input.value, editorContext) : getWidgetComponentByType(input.value, field.schemaProp.type, editorContext) : undefined;
  const path = fieldNames[0].split(".").slice(0, -1).join(".");
  const configId = dotNotationGet(editorContext.form.values, path)._id;
  const externalReferenceLocationKey = getExternalReferenceLocationKey$1(configId, field.schemaProp.prop, field.schemaProp.responsive ? editorContext.breakpointIndex : undefined);
  const externalValue = externalReferenceLocationKey ? externalData[externalReferenceLocationKey] : undefined;
  const isExternalValueResolvedCompoundExternalDataValue = !isMixedFieldValue(value) && !isEmptyExternalReference(value) && externalValue !== undefined && isResolvedCompoundExternalDataValue(externalValue);
  const basicResources = isExternalValueResolvedCompoundExternalDataValue ? getBasicResourcesOfType(externalValue.value, field.schemaProp.type) : [];
  const isCompoundResourceValueSelectVisible = isExternalValueResolvedCompoundExternalDataValue && !isIdReferenceToDocumentExternalValue(value.id) && basicResources.length > 1;
  useLayoutEffect(() => {
    if (isExternalValueResolvedCompoundExternalDataValue && basicResources.length === 1 && !value.key) {
      // We perform form change manually to avoid storing this change in editor's history
      editorContext.form.change(fieldNames[0], {
        ...value,
        key: basicResources[0].key
      });
    }
  });
  return /*#__PURE__*/React__default.createElement(FieldMetaWrapper, _extends({}, props, {
    form: tinaForm,
    layout: "column"
  }), /*#__PURE__*/React__default.createElement("div", {
    style: {
      width: "100%"
    }
  }, isMixedFieldValue(value) ? "Mixed" : /*#__PURE__*/React__default.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      alignItems: "flex-start",
      gap: "8px"
    }
  }, ExternalField ? /*#__PURE__*/React__default.createElement(ExternalField, {
    id: value.id,
    resourceKey: "key" in value ? value.key : undefined,
    onChange: (newId, newKey) => {
      const newValue = {
        id: newId,
        widgetId: value.widgetId
      };
      if (newKey && newValue.id !== null) {
        newValue.key = newKey;
      }
      input.onChange(newValue);
    },
    path: fieldNames[0],
    params: field.schemaProp.params
  }) : /*#__PURE__*/React__default.createElement(MissingWidget, {
    type: field.schemaProp.type
  }), isCompoundResourceValueSelectVisible && /*#__PURE__*/React__default.createElement(CompoundResourceValueSelect, {
    options: basicResources.map(r => ({
      id: externalReferenceLocationKey,
      key: r.key,
      label: r.label ?? r.key
    })),
    resource: {
      id: externalReferenceLocationKey,
      key: value.key
    },
    onResourceKeyChange: (_, key) => {
      input.onChange({
        ...value,
        key
      });
    }
  }))));
};
const ExternalFieldPlugin = {
  name: "external",
  Component: ExternalFieldComponent
};
function getWidgetComponentByType(externalReference, type, editorContext) {
  return editorContext.types[type].widgets.find(w => w.id === externalReference.widgetId)?.component;
}
function getWidgetComponentForRootParam(externalReference, editorContext) {
  return Object.values(editorContext.types).filter(t => t.type === "external").flatMap(t => t.widgets).find(w => w.id === externalReference.widgetId)?.component;
}
function getBasicResourcesOfType(compoundResourceValues, type) {
  return Object.entries(compoundResourceValues).filter(_ref => {
    let [, r] = _ref;
    return r.type === type;
  }).map(_ref2 => {
    let [key, r] = _ref2;
    return {
      key,
      ...r
    };
  });
}
function CompoundResourceValueSelect(props) {
  return /*#__PURE__*/React__default.createElement(Select, {
    onChange: value => {
      const selectedOption = JSON.parse(value);
      props.onResourceKeyChange(selectedOption.id, selectedOption.key);
    },
    value: props.resource.id !== null && props.resource.key !== undefined ? JSON.stringify({
      id: props.resource.id,
      key: props.resource.key
    }) : "",
    placeholder: "Select source..."
  }, props.options.map(r => {
    return /*#__PURE__*/React__default.createElement(SelectItem, {
      key: `${r.id}.${r.key}`,
      value: JSON.stringify({
        id: r.id,
        key: r.key
      })
    }, r.label);
  }));
}

function getSavedValue(value, previousValue, editorContext) {
  const breakpointIndex = editorContext.breakpointIndex;
  if (typeof value === "string" && value.startsWith("##")) ;

  // Responsiveness is not enabled for this field
  if (!isTrulyResponsiveValue$2(previousValue)) {
    if (value === undefined || value === null) {
      return null;
    }
    return value;
  }
  const result = {
    ...previousValue
  };
  result[breakpointIndex] = value;
  return result;
}
function responsiveFieldController(config) {
  const {
    field,
    formValues,
    onChange,
    editorContext,
    valuesAfterAuto
  } = config;
  function originalFormat(value, fieldName) {
    return field.format?.(value, fieldName, field) ?? value;
  }
  function originalParse(value, fieldName) {
    return field.parse?.(value, fieldName, field) ?? value;
  }
  const normalizedFieldName = toArray(field.name);
  const fieldValues = normalizedFieldName.map(fieldName => dotNotationGet(formValues, fieldName));
  const isResponsive = fieldValues.every(fieldValue => isTrulyResponsiveValue$2(fieldValue));
  const isSet = isResponsive && fieldValues.every(fieldValue => fieldValue[editorContext.breakpointIndex] !== undefined);
  const format = (value, name) => {
    const valueAfterFormat = originalFormat(value, name);
    const displayedValue = (isTrulyResponsiveValue$2(valueAfterFormat) ? valueAfterFormat[editorContext.breakpointIndex] : valueAfterFormat) ?? null;
    return displayedValue;
  };
  const parse = (value, name) => {
    if (value === null) {
      throw new Error("parse in ResponsiveController has null value which should be impossible (null values should disappear once other value is picked!");
    }
    const fieldValue = originalFormat(dotNotationGet(formValues, name), name);
    const savedValue = getSavedValue(value, fieldValue, editorContext);
    return originalParse(savedValue, name);
  };
  const reset = () => {
    if (!isResponsive) {
      throw new Error("should never happen");
    }
    const nextValues = normalizedFieldName.map(fieldName => {
      const previousValue = originalFormat(dotNotationGet(formValues, fieldName), fieldName);
      const newValue = {
        ...previousValue
      };
      delete newValue[editorContext.breakpointIndex];
      if (Object.keys(newValue).length <= 1) {
        return field.defaultValue;
      }
      return originalParse(newValue, fieldName);
    });
    onChange(nextValues);
  };
  const toggleOffAuto = () => {
    const currentBreakpointValues = fieldValues.map(fieldValue => fieldValue[editorContext.breakpointIndex]);
    let areAllFieldValuesAuto = true;
    let isAnyFieldValueAuto = false;
    currentBreakpointValues.forEach(value => {
      if (value === undefined) {
        if (!isAnyFieldValueAuto) {
          isAnyFieldValueAuto = true;
        }
      } else {
        if (areAllFieldValuesAuto) {
          areAllFieldValuesAuto = false;
        }
      }
    });
    const newFieldsValues = normalizedFieldName.map(fieldName => {
      const fieldValue = dotNotationGet(formValues, fieldName);
      const nextFieldValue = areAllFieldValuesAuto ? dotNotationGet(valuesAfterAuto, normalizedFieldName[0]) : isAnyFieldValueAuto ? fieldValues.find(value => value[editorContext.breakpointIndex] !== undefined) : fieldValue;
      const newFieldValue = {
        ...fieldValue,
        [editorContext.breakpointIndex]: responsiveValueForceGet$2(
        // next field comes from auto, so value is defined
        nextFieldValue, editorContext.breakpointIndex)
      };
      return newFieldValue;
    });
    onChange(newFieldsValues);
  };
  const valueField = {
    ...field,
    component: field.subComponent,
    format,
    parse
  };
  return {
    field: valueField,
    isResponsive,
    isSet,
    reset,
    toggleOffAuto
  };
}

const ResponsiveField = props => {
  const {
    tinaForm,
    field,
    input
  } = props;
  const editorContext = useEditorContext();
  const configAfterAuto = useConfigAfterAuto();
  const normalizedFieldName = toArray(field.name);
  const fieldValues = normalizedFieldName.map(fieldName => dotNotationGet(configAfterAuto, fieldName));
  const scalarFieldValues = fieldValues.map(fieldValue => {
    return responsiveValueForceGet$2(
    // value from auto, so it's safe
    fieldValue, editorContext.breakpointIndex);
  });
  const uniqueValues = getUniqueValues(scalarFieldValues, value => typeof value === "object" ? JSON.stringify(value) : value);
  const isMixedValue = uniqueValues.length > 1;
  const value = isMixedValue ? MIXED_VALUE : uniqueValues[0];
  const controller = responsiveFieldController({
    field,
    onChange: newValues => {
      input.onChange(...newValues);
    },
    formValues: tinaForm.values,
    editorContext,
    valuesAfterAuto: configAfterAuto
  });
  const isValueDifferentFromMainBreakpoint = controller.isSet && editorContext.breakpointIndex !== editorContext.mainBreakpointIndex;
  const isFieldVisible = !controller.isResponsive || controller.isSet || editorContext.breakpointIndex === editorContext.mainBreakpointIndex;
  const uniqueFieldValues = getUniqueValues(scalarFieldValues);
  const autoLabelChildren = uniqueFieldValues.length > 1 && uniqueFieldValues.includes(undefined) ? "Mixed" : getAutoLabelButtonLabel(value);
  const isExternalField = field.subComponent === "external";
  const {
    isOpen,
    arrowProps,
    tooltipProps,
    triggerProps
  } = useTooltip({
    isDisabled: !isValueDifferentFromMainBreakpoint,
    onClick: () => {
      controller.reset();
    }
  });
  return /*#__PURE__*/React__default.createElement(FieldMetaWrapper, _extends({}, props, {
    layout: isExternalField ? "column" : "row",
    renderLabel: isValueDifferentFromMainBreakpoint ? _ref => {
      let {
        label
      } = _ref;
      return /*#__PURE__*/React__default.createElement(ResetButton, _extends({
        "aria-label": "Revert to auto"
      }, triggerProps), /*#__PURE__*/React__default.createElement(Icons.Reset, null), /*#__PURE__*/React__default.createElement(ResetButtonLabel, null, label), isOpen && /*#__PURE__*/React__default.createElement(Tooltip, tooltipProps, /*#__PURE__*/React__default.createElement(TooltipArrow, arrowProps), /*#__PURE__*/React__default.createElement(TooltipBody, null, "Revert to auto")));
    } : undefined
  }), /*#__PURE__*/React__default.createElement("div", {
    style: {
      width: "100%"
    }
  }, isFieldVisible ? /*#__PURE__*/React__default.createElement(FieldBuilder, {
    form: tinaForm,
    field: controller.field,
    noWrap: true
  }) : /*#__PURE__*/React__default.createElement(AutoLabel, {
    align: isExternalField ? "left" : "right",
    onClick: () => {
      controller.toggleOffAuto();
    }
  }, autoLabelChildren)));
};
const ResponsiveFieldPlugin = {
  name: "responsive2",
  Component: ResponsiveField
};
const AutoLabel = styled.div.withConfig({
  displayName: "ResponsiveFieldPlugin__AutoLabel",
  componentId: "sc-1m7fdh0-0"
})(["", ";color:", ";text-align:", ";&:hover{color:black;cursor:pointer;text-decoration:underline;}"], Fonts.body, Colors.black40, props => props.align);
const ResetButton = styled.button.withConfig({
  displayName: "ResponsiveFieldPlugin__ResetButton",
  componentId: "sc-1m7fdh0-1"
})(["display:flex;align-items:center;gap:4px;background-color:transparent;border:0;padding:0;color:", ";cursor:pointer;"], Colors.purple);
const ResetButtonLabel = styled.span.withConfig({
  displayName: "ResponsiveFieldPlugin__ResetButtonLabel",
  componentId: "sc-1m7fdh0-2"
})(["", ";line-height:16px;"], Fonts.body);
function getAutoLabelButtonLabel(value) {
  if (value === MIXED_VALUE) {
    return "auto: Mixed";
  }

  /**
   * This piece of code is crap
   */
  if (typeof value === "object") {
    if (value.tokenId !== undefined && value.value !== undefined) {
      const refNameParts = value.tokenId.split(".");
      return `auto: ${refNameParts[refNameParts.length - 1]}`;
    } else if (value.value !== undefined && value.id === undefined) {
      // just value field -> token
      return `auto: ${typeof value.value === "number" ? Math.round(value.value * 100) / 100 : value.value}`;
    }
    return "auto";
  }
  if (typeof value === "boolean") {
    return `auto: ${JSON.stringify(value)}`;
  }
  return `auto: ${value}`;
}

function transformStrokeAndFill(node) {
  const fill = node.getAttribute("fill");
  const stroke = node.getAttribute("stroke");
  if (fill && fill !== "none") {
    node.setAttribute("fill", "currentColor");
  }
  if (stroke && stroke !== "none") {
    node.setAttribute("stroke", "currentColor");
  }
  Array.from(node.children).forEach(child => transformStrokeAndFill(child));
}
const SVGPicker = wrapFieldsWithMeta(_ref => {
  let {
    input,
    meta,
    field
  } = _ref;
  const svgString = input.value.value;
  const inputRef = useRef(null);
  useEffect(() => {
    function readFileAsString() {
      // @ts-ignore
      const files = this.files;
      if (files.length === 0) {
        return;
      }
      const reader = new FileReader();
      reader.onload = function (event) {
        // @ts-ignore to explore
        const trimmed = event.target?.result.trim();
        const emptyDiv = document.createElement("div");
        emptyDiv.innerHTML = trimmed;
        const svg = emptyDiv.children[0];
        svg.removeAttribute("width");
        svg.removeAttribute("height");
        svg.setAttribute("style", "position: absolute; width: 100%;height: 100%;");
        transformStrokeAndFill(svg);
        if (svg.tagName.toLowerCase() !== "svg") {
          alert("incorrect file");
          return;
        }
        input.onChange({
          value: emptyDiv.innerHTML
        });
      };
      reader.readAsText(files[0]);
    }
    inputRef.current.addEventListener("change", readFileAsString);
    return () => {
      inputRef.current.removeEventListener("change", readFileAsString);
    };
  }, []);
  return /*#__PURE__*/React__default.createElement("div", null, /*#__PURE__*/React__default.createElement("div", {
    style: {
      width: 24,
      height: 24,
      position: "relative",
      color: "black",
      marginBottom: 16
    }
  }, /*#__PURE__*/React__default.createElement("div", {
    dangerouslySetInnerHTML: {
      __html: svgString
    }
  })), /*#__PURE__*/React__default.createElement("input", {
    type: "file",
    id: "upload",
    accept: ".svg",
    ref: inputRef
  }));
});
const SVGPickerFieldPlugin = {
  __type: "field",
  name: "icon",
  Component: SVGPicker
};

const Slider = wrapFieldsWithMeta(_ref => {
  let {
    input,
    field
  } = _ref;
  return /*#__PURE__*/React__default.createElement(RangeSlider, _extends({}, input, {
    max: field.max,
    min: field.min,
    step: field.step
  }));
});
const SliderFieldPlugin = {
  __type: "field",
  name: "slider",
  Component: Slider
};

function useInlineTypes() {
  const editorContext = useEditorContext();
  const tokenTypes = Object.fromEntries(Object.entries(editorContext.types).filter(typeDefinitionEntry => {
    return typeDefinitionEntry[1].type === "inline";
  }));
  return tokenTypes;
}
const LocalFieldPlugin = {
  name: "local",
  Component: wrapFieldsWithMeta(function LocalField(_ref) {
    let {
      field,
      input
    } = _ref;
    const inlineTypes = useInlineTypes();
    const inlineTypeDefinition = inlineTypes[field.schemaProp.type];
    const WidgetComponent = inlineTypeDefinition?.widget.component;
    if (!WidgetComponent) {
      return /*#__PURE__*/React__default.createElement(MissingWidget, {
        type: field.schemaProp.type
      });
    }
    return /*#__PURE__*/React__default.createElement(WidgetComponent, {
      value: input.value.value,
      onChange: value => {
        input.onChange({
          value,
          widgetId: input.value.widgetId
        });
      },
      params: "params" in field.schemaProp ? field.schemaProp.params : undefined
    });
  })
};

const StyledRadioItem = styled(RadixRadioGroup.Item).withConfig({
  displayName: "PositionPickerInput__StyledRadioItem",
  componentId: "sc-1uvtpi7-0"
})(["all:unset;position:relative;display:flex;justify-content:", ";align-items:", ";box-sizing:border-box;width:20px;height:20px;padding:8px;&:hover > div{opacity:", ";}"], props => horizontalPositionToFlexJustifyContentValue(props.horizontal), props => verticalPositionToFlexAlignItemsValue(props.vertical), props => props.p.value === props.position ? 1 : 0.5);
const positions = [{
  label: "Top Left",
  value: "top-left"
}, {
  label: "Top Center",
  value: "top-center"
}, {
  label: "Top Right",
  value: "top-right"
}, {
  label: "Center Left",
  value: "center-left"
}, {
  label: "Center Center",
  value: "center-center"
}, {
  label: "Center Right",
  value: "center-right"
}, {
  label: "Bottom Left",
  value: "bottom-left"
}, {
  label: "Bottom Center",
  value: "bottom-center"
}, {
  label: "Bottom Right",
  value: "bottom-right"
}];
function horizontalPositionToFlexJustifyContentValue(position) {
  switch (position) {
    case "left":
      return "flex-start";
    case "center":
      return "center";
    case "right":
      return "flex-end";
  }
}
function verticalPositionToFlexAlignItemsValue(position) {
  switch (position) {
    case "top":
      return "flex-start";
    case "center":
      return "center";
    case "bottom":
      return "flex-end";
  }
}
function PositionPickerInput(_ref) {
  let {
    position,
    onPositionChange
  } = _ref;
  return /*#__PURE__*/React__default.createElement(RadixRadioGroup.Root, {
    value: position,
    onValueChange: newPosition => {
      onPositionChange(newPosition);
    },
    style: {
      display: "grid",
      gridTemplateRows: "repeat(3, 1fr)",
      gridTemplateColumns: "repeat(3, 1fr)",
      gap: "0",
      borderRadius: "2px",
      border: `1px solid ${Colors.black10}`
    }
  }, positions.map(p => {
    const [vertical, horizontal] = p.value.split("-");
    return /*#__PURE__*/React__default.createElement(StyledRadioItem, {
      value: p.value,
      key: p.value,
      "aria-label": p.label,
      horizontal: horizontal,
      vertical: vertical,
      p: p,
      position: position
    }, /*#__PURE__*/React__default.createElement("div", {
      style: {
        width: "2px",
        height: "2px",
        backgroundColor: "#d9d9d9"
      }
    }), /*#__PURE__*/React__default.createElement("div", {
      style: {
        position: "absolute",
        top: "2px",
        left: "2px",
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: horizontalPositionToFlexJustifyContentValue(horizontal),
        gap: "2px",
        width: "16px",
        height: "16px",
        opacity: p.value === position ? 1 : 0
      }
    }, /*#__PURE__*/React__default.createElement(PositionIndicator, {
      $size: vertical === "top" ? "full" : "normal"
    }), /*#__PURE__*/React__default.createElement(PositionIndicator, {
      $size: vertical === "center" ? "full" : "normal"
    }), /*#__PURE__*/React__default.createElement(PositionIndicator, {
      $size: vertical === "bottom" ? "full" : "normal"
    })));
  }));
}
const PositionIndicator = styled.div.withConfig({
  displayName: "PositionPickerInput__PositionIndicator",
  componentId: "sc-1uvtpi7-1"
})(["width:", ";height:4px;background-color:#202123;"], p => p.$size === "full" ? "100%" : "75%");

function PositionField(props) {
  return /*#__PURE__*/React__default.createElement(PositionPickerInput, {
    position: props.input.value,
    onPositionChange: position => {
      props.input.onChange(position);
    }
  });
}
const PositionFieldPlugin = {
  name: "position",
  Component: wrapFieldsWithMeta(PositionField)
};

// "any" here is on purpose (although doesn't make sense from TS perspective).
// It suggests that in onChange you can pass event OR any value. It's a bit confusing and should be cleaned up in the future.

function createFieldController(_ref) {
  let {
    field,
    editorContext,
    format = v => v,
    parse = v => v
  } = _ref;
  const {
    actions,
    contextParams,
    form,
    locales,
    focussedField
  } = editorContext;
  const normalizedFieldName = toArray(field.name);
  return {
    onChange(mainNewValue) {
      for (var _len = arguments.length, extraNewValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        extraNewValues[_key - 1] = arguments[_key];
      }
      /**
       * There are 2 modes of onChange: single param and multiple params
       *
       * 1. single param mode is when onChange is given ONE value (1 parameter). It means: "apply this value for all selected fields"
       * 2. multiple param mode is when onChange is given more than one value. It means: "apply each value for respective selected field".
       */

      const newValue = extraNewValues.length === 0 ? mainNewValue : [mainNewValue, ...extraNewValues];
      if (!Array.isArray(mainNewValue) && Array.isArray(newValue) && newValue.length !== normalizedFieldName.length) {
        throw new Error("onChange in multiple param mode was given wrong number of values");
      }
      if (focussedField.some(isConfigPathRichTextPart)) {
        // For editor selection we can safely pick a first field name because:
        // * we only can select fields that are children of @easyblocks/rich-text-part
        // * we only can update only single property
        const {
          templateId
        } = parsePath(normalizedFieldName[0], form);
        invalidateCache(normalizedFieldName[0], editorContext);
        if (templateId === "@easyblocks/rich-text-part") {
          const schemaPropNameToUpdate = last(normalizedFieldName[0].split("."));
          const canvasIframe = document.getElementById("shopstory-canvas");
          if (canvasIframe === null || canvasIframe.contentWindow === null) {
            throw new Error("No Shopstory canvas");
          }
          if (extraNewValues.length > 0) {
            const parsedValues = newValue.map(value => parse(getValue(value), normalizedFieldName[0], field));
            canvasIframe.contentWindow.postMessage(richTextChangedEvent({
              prop: schemaPropNameToUpdate,
              schemaProp: field.schemaProp,
              values: parsedValues
            }), "*");
          } else {
            const parsedValue = parse(getValue(newValue), normalizedFieldName[0], field);
            canvasIframe.contentWindow.postMessage(richTextChangedEvent({
              prop: schemaPropNameToUpdate,
              schemaProp: field.schemaProp,
              values: [parsedValue]
            }), "*");
          }
          return;
        }
      }
      actions.runChange(() => {
        normalizedFieldName.forEach((path, fieldIndex) => {
          const inputValue = Array.isArray(newValue) ? getValue(newValue[fieldIndex]) : getValue(newValue);
          const customTypeDefinition = editorContext.types[field.schemaProp.type];
          if (customTypeDefinition && "validate" in customTypeDefinition && customTypeDefinition.validate && "value" in inputValue && (customTypeDefinition.type === "token" ? !("tokenId" in inputValue) : true)) {
            const isInputValueValid = customTypeDefinition.validate(inputValue.value);
            if (!isInputValueValid) {
              return;
            }
          }
          let parsedValue = parse(inputValue, path, field);

          // If path has locale token [locale] (component-collection-localised) then we must first replace it with correct token
          if (hasLocaleToken(path)) {
            const currentLocaleFieldName = replaceLocaleToken(path, contextParams.locale);
            const currentLocaleValue = dotNotationGet(form.values, currentLocaleFieldName);
            parsedValue = parse(inputValue, currentLocaleFieldName, field);

            // If the path doesn't exist it means that there is no config for path for current locale. It means we must create it!
            if (currentLocaleValue === undefined) {
              const fallbackLocale = getFallbackLocaleForLocale$1(contextParams.locale, locales);
              const fieldNameSegments = path.split(".");
              const localeTokenIndex = fieldNameSegments.indexOf("[locale]");
              const localisedConfigPath = [...fieldNameSegments.slice(0, localeTokenIndex + 1), "0"].join(".");
              const fallbackLocaleFieldName = replaceLocaleToken(localisedConfigPath, fallbackLocale);
              const localeConfigPath = replaceLocaleToken(localisedConfigPath, contextParams.locale);
              form.change(localeConfigPath, duplicateConfig(dotNotationGet(form.values, fallbackLocaleFieldName), editorContext));
            }
            path = currentLocaleFieldName;
          }
          invalidateCache(path, editorContext);

          // At this point we have correct fieldName and correct parsedValue after all [locale] issues solved

          /**
           * Below we're trying to see whether there is a custom change function for specific EditableComponent
           */

          const split = path.split(".");
          const propName = last(split);

          // TODO: here we can have either a component or component field. parsePath should take this into account!
          const componentPath = split.slice(0, split.length - 1).join(".");
          const {
            templateId
          } = parsePath(componentPath, editorContext.form);
          const parentDefinition = findComponentDefinitionById(templateId, editorContext);
          const config = dotNotationGet(editorContext.form.values, componentPath);
          if (parentDefinition && parentDefinition.change) {
            const values = {};
            const closestDefinedValues = {};
            parentDefinition.schema.forEach(schemaProp => {
              const val = config[schemaProp.prop];
              values[schemaProp.prop] = isTrulyResponsiveValue$2(val) ? val[editorContext.breakpointIndex] : val;
              closestDefinedValues[schemaProp.prop] = responsiveValueGetDefinedValue$1(val, editorContext.breakpointIndex, editorContext.devices, getDevicesWidths$1(editorContext.devices));
            });
            const inputValue = isTrulyResponsiveValue$2(parsedValue) ? parsedValue[editorContext.breakpointIndex] : parsedValue;
            const result = parentDefinition.change({
              newValue: inputValue,
              prop: propName,
              values,
              /**
               * IMPORTANT!!!
               *
               * valuesAfterAuto are an approximation for now, they're not real auto values, they just have closest defined values.
               *
               */
              valuesAfterAuto: closestDefinedValues
            }) ?? {
              [propName]: inputValue
            };
            parentDefinition.schema.forEach(schemaProp => {
              if (!result.hasOwnProperty(schemaProp.prop)) {
                return;
              }
              let pathPrefix = `${componentPath}.${schemaProp.prop}`;
              if (pathPrefix[0] === ".") {
                pathPrefix = pathPrefix.substring(1);
              }
              if (isTrulyResponsiveValue$2(config[schemaProp.prop])) {
                form.change(`${pathPrefix}.${editorContext.breakpointIndex}`, result[schemaProp.prop]);
              } else {
                form.change(`${pathPrefix}`, result[schemaProp.prop]);
              }
            });
          } else {
            form.change(path, parsedValue);
          }
        });
      });
    },
    getValue() {
      const fieldValues = normalizedFieldName.map(fieldName => {
        const propName = last(fieldName.split("."));
        if (propName.startsWith("$") && "defaultValue" in field.schemaProp) {
          return field.schemaProp.defaultValue;
        }
        if (hasLocaleToken(fieldName)) {
          const resolvedFieldName = replaceLocaleToken(fieldName, editorContext.contextParams.locale);
          const fieldValue = dotNotationGet(form.values, resolvedFieldName);
          if (fieldValue) {
            return fieldValue;
          }
          const fallbackLocale = getFallbackLocaleForLocale$1(editorContext.contextParams.locale, editorContext.locales);
          const resolvedFieldFallbackName = replaceLocaleToken(fieldName, fallbackLocale);
          const fieldFallbackValue = dotNotationGet(form.values, resolvedFieldFallbackName);
          return fieldFallbackValue;
        }
        return dotNotationGet(form.values, fieldName);
      });
      const uniqueFieldValues = getUniqueValues(fieldValues, fieldValue => {
        const {
          getHash
        } = getSchemaDefinition(field.schemaProp, editorContext);
        return getHash(fieldValue, editorContext.breakpointIndex, editorContext.devices);
      });
      if (uniqueFieldValues.length > 1) {
        return {
          __mixed__: true
        };
      }
      return format(uniqueFieldValues[0], normalizedFieldName[0], field);
    }
  };
}
function hasLocaleToken(configPath) {
  return configPath.includes("[locale]");
}
function replaceLocaleToken(configPath, locale) {
  const localisedFieldName = configPath.replace("[locale]", locale);
  return localisedFieldName;
}
function getValue(eventOrValue) {
  // Event of course has more properties or methods, but for this case
  // checking only for `currentTarget` is sufficient
  const isEventObject = typeof eventOrValue === "object" && eventOrValue !== null && "currentTarget" in eventOrValue;
  if (isEventObject) {
    if ("checked" in eventOrValue.currentTarget && eventOrValue.currentTarget.type === "checkbox") {
      return eventOrValue.currentTarget.checked;
    }
    return eventOrValue.currentTarget.value;
  } else {
    return eventOrValue;
  }
}
// $richText and @easyblocks/rich-text-part uses a lot of portals to display correct fields within sidebar
// Changing value through portal won't trigger the recompilation of component using that portal.
// When we change any $richText related component we remove cache for that component (if it is $richText)
// and for all of its ancestors.
const richTextCacheInvalidator = (cache, changedPath, context) => {
  const cacheKeysToRemove = [];
  const {
    templateId,
    fieldName,
    parent
  } = parsePath(changedPath, context.form);
  const isRichTextOrRichTextAncestorComponent = templateId.startsWith("@easyblocks/rich-text") || parent?.templateId.startsWith("@easyblocks/rich-text");
  if (isRichTextOrRichTextAncestorComponent) {
    const richTextPath = templateId === "@easyblocks/rich-text" && fieldName ? changedPath.replace(`.${fieldName}`, "") : findPathOfFirstAncestorOfType(changedPath, "@easyblocks/rich-text", context.form);
    const richTextConfig = dotNotationGet(context.form.values, richTextPath);
    traverseComponents(richTextConfig, context, _ref2 => {
      let {
        componentConfig
      } = _ref2;
      if (componentConfig && componentConfig._component.startsWith("@easyblocks/rich-text")) {
        cacheKeysToRemove.push(componentConfig._id);
      }
    });
  }
  return cacheKeysToRemove;
};
const cacheInvalidators = [richTextCacheInvalidator];
function invalidateCache(changedPath, context) {
  const cacheKeysToRemove = new Set(cacheInvalidators.flatMap(invalidator => {
    return invalidator(context.compilationCache, changedPath, context);
  }));
  cacheKeysToRemove.forEach(cacheKey => {
    context.compilationCache.remove(cacheKey);
  });
}

function shouldFieldBeDisplayed(field) {
  if (field.component === null) return false;
  if (Array.isArray(field.name)) {
    return true;
  }
  if (field.hidden) {
    return false;
  }
  return true;
}
const FIELD_COMPONENTS = [TextFieldPlugin, NumberFieldPlugin, ToggleFieldPlugin, SelectFieldPlugin, RadioGroupFieldPlugin, PositionFieldPlugin, BlockFieldPlugin, SliderFieldPlugin, SVGPickerFieldPlugin, ResponsiveFieldPlugin, ExternalFieldPlugin, TokenFieldPlugin, IdentityFieldPlugin, LocalFieldPlugin];
function FieldBuilder(_ref) {
  let {
    form,
    field,
    noWrap,
    isLabelHidden
  } = _ref;
  const editorContext = useEditorContext();
  if (!shouldFieldBeDisplayed(field)) {
    return null;
  }
  const fieldComponent = FIELD_COMPONENTS.find(component => component.name === field.component);
  const {
    onChange,
    getValue
  } = createFieldController({
    field,
    editorContext,
    format: field.format ?? fieldComponent?.format,
    parse: field.parse ?? fieldComponent?.parse
  });
  if (fieldComponent) {
    return /*#__PURE__*/React__default.createElement(fieldComponent.Component, {
      // Let's talk about this code
      // This branch of code is created to display single input and label that handles multiple inputs under the hood
      // To make this work, we had to skip usage of `Field` from `Final Form` because it requires a single field object with single name
      // Moreover, since we don't use `Field` anymore we have to pretend that it still exists to make fields works as it was there.
      // In the future, this code should become a part of new component (ex. FieldWrapper)
      // and new controller should be introduced (ex. fieldWrapperController) to have single source of truth about behaviour of responsive field.
      input: {
        value: getValue(),
        onChange
      }
      // MetaFieldWrapper accesses `error` property of this object, it's needed to prevent runtime error
      ,
      meta: {},
      tinaForm: form,
      form: form.finalForm,
      field: field,
      noWrap: noWrap,
      isLabelHidden: isLabelHidden
    });
  }
  if (typeof field.component !== "string" && field.component !== null) {
    console.log("not a string");
    return /*#__PURE__*/React__default.createElement(field.component, {
      input: {
        value: getValue(),
        onChange
      },
      meta: {},
      tinaForm: form,
      form: form.finalForm,
      field: field,
      noWrap: noWrap,
      isLabelHidden: isLabelHidden
    });
  }
  return /*#__PURE__*/React__default.createElement(FieldMetaWrapper, {
    input: {
      value: getValue(),
      onChange
    },
    field: field,
    layout: "column"
  }, /*#__PURE__*/React__default.createElement(Typography, null, "Unrecognized field type"));
}
const HorizontalLine = styled.div.withConfig({
  displayName: "fields-builder__HorizontalLine",
  componentId: "sc-ignixa-0"
})(["height:1px;margin-top:-1px;background-color:", ";"], Colors.black10);
function FieldsBuilder(_ref2) {
  let {
    form,
    fields
  } = _ref2;
  const editorContext = useEditorContext();
  const panelContext = useContext(PanelContext);
  const grouped = {};
  const ungrouped = [];
  fields.forEach(field => {
    if (!shouldFieldBeDisplayed(field)) {
      return;
    }
    if (field.group) {
      grouped[field.group] = grouped[field.group] || [];
      grouped[field.group].push(field);
    } else {
      if (field.component === "identity") {
        return;
      }
      ungrouped.push(field);
    }
  });
  const horizontalLine = /*#__PURE__*/React__default.createElement(HorizontalLine, null);
  const identityField = fields.find(field => field.component === "identity");
  const breakpointIndex = panelContext ? editorContext.breakpointIndex : undefined;
  return /*#__PURE__*/React__default.createElement(FieldsGroup, null, identityField !== undefined && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(FieldBuilder, {
    field: identityField,
    form: form
  }), horizontalLine), Object.keys(grouped).map(groupName => /*#__PURE__*/React__default.createElement("div", {
    key: groupName
  }, /*#__PURE__*/React__default.createElement(FieldsGroupLabel, null, groupName), grouped[groupName].map((field, index, fields) => /*#__PURE__*/React__default.createElement(FieldWrapper, {
    key: generateFieldKey(field, breakpointIndex),
    isLast: index === fields.length - 1
  }, /*#__PURE__*/React__default.createElement(FieldBuilder, {
    field: field,
    form: form,
    isLabelHidden: field.schemaProp.isLabelHidden
  }))), horizontalLine)), ungrouped.map((field, index, fields) => /*#__PURE__*/React__default.createElement(FieldWrapper, {
    key: generateFieldKey(field, breakpointIndex),
    isLast: index === fields.length - 1
  }, /*#__PURE__*/React__default.createElement(FieldBuilder, {
    field: field,
    form: form,
    isLabelHidden: field.schemaProp.isLabelHidden
  }))), horizontalLine);
}
function generateFieldKey(field, breakpointIndex) {
  const key = `${toArray(field.name).join("_")}_${field.schemaProp.type}${breakpointIndex ? `_${breakpointIndex}` : ""}`;
  return key;
}
const FieldWrapper = styled.div.withConfig({
  displayName: "fields-builder__FieldWrapper",
  componentId: "sc-ignixa-1"
})(["margin-bottom:", ";"], props => props.isLast ? "8px" : 0);
const FieldsGroupLabel = styled.div.withConfig({
  displayName: "fields-builder__FieldsGroupLabel",
  componentId: "sc-ignixa-2"
})(["display:flex;align-items:center;padding:20px 16px 10px 16px;", ";color:#000;"], Fonts.label);
const FieldsGroup = styled.div.withConfig({
  displayName: "fields-builder__FieldsGroup",
  componentId: "sc-ignixa-3"
})(["position:relative;display:block;width:100%;padding:0;white-space:nowrap;overflow-x:hidden;overflow-y:auto !important;"]);

const theme = css([":root{--tina-color-primary-light:#2296fe;--tina-color-primary:#2296fe;--tina-color-primary-dark:#0574e4;--tina-color-error-light:#eb6337;--tina-color-error:#ec4815;--tina-color-error-dark:#dc4419;--tina-color-warning-light:#f5e06e;--tina-color-warning:#e9d050;--tina-color-warning-dark:#d3ba38;--tina-color-success-light:#57c355;--tina-color-success:#3cad3a;--tina-color-success-dark:#249a21;--tina-color-grey-0:#ffffff;--tina-color-grey-1:#f6f6f9;--tina-color-grey-2:#edecf3;--tina-color-grey-3:#e1ddec;--tina-color-grey-4:#b2adbe;--tina-color-grey-5:#918c9e;--tina-color-grey-6:#716c7f;--tina-color-grey-7:#565165;--tina-color-grey-8:#433e52;--tina-color-grey-9:#363145;--tina-color-grey-10:#282828;--tina-radius-small:5px;--tina-radius-big:24px;--tina-padding-small:12px;--tina-padding-big:20px;--tina-font-size-0:12px;--tina-font-size-1:13px;--tina-font-size-2:15px;--tina-font-size-3:16px;--tina-font-size-4:18px;--tina-font-size-5:20px;--tina-font-size-6:22px;--tina-font-size-7:26px;--tina-font-size-8:32px;--tina-font-family:\"Inter\",sans-serif;--tina-font-weight-regular:400;--tina-font-weight-bold:600;--tina-shadow-big:0px 2px 3px rgba(0,0,0,0.05),0 4px 12px rgba(0,0,0,0.1);--tina-shadow-small:0px 2px 3px rgba(0,0,0,0.12);--tina-timing-short:85ms;--tina-timing-medium:150ms;--tina-timing-long:250ms;--tina-z-index-0:500;--tina-z-index-1:1000;--tina-z-index-2:1500;--tina-z-index-3:2000;--tina-z-index-4:2500;--tina-z-index-5:3000;--tina-sidebar-width:340px;--tina-sidebar-header-height:60px;--tina-toolbar-height:62px;}"]);
const GlobalStyles = createGlobalStyle(["", ";"], theme);
const tina_reset_styles = css(["*{font-family:\"Inter\",sans-serif;&::-webkit-scrollbar{width:8px;}::-webkit-scrollbar-track{background:transparent;border-left:1px solid var(--tina-color-grey-2);}&::-webkit-scrollbar-thumb{background-color:var(--tina-color-grey-3);border-radius:0;border:none;}}*,*:before,*:after{box-sizing:border-box;}hr{border-color:var(--tina-color-grey-2);color:var(--tina-color-grey-2);margin-bottom:var(--tina-padding-big);margin-left:calc(var(--tina-padding-big) * -1);margin-right:calc(var(--tina-padding-big) * -1);border-top:1px solid var(--tina-color-grey-2);border-bottom:none;height:0;box-sizing:content-box;}h1,h2,h3,h4,h5,h6,p{:not([class]){font-family:\"Inter\",sans-serif;&:first-child{margin-top:0;}&:last-child{margin-bottom:0;}}}td,th{padding:0;width:auto;height:auto;border:inherit;margin:0;}h1,h2,h3,h4,h5,h6{:not([class]){font-weight:var(--tina-font-weight-bold);}}h1:not([class]){font-size:var(--tina-font-size-8);}h2:not([class]){font-size:var(--tina-font-size-7);}h3:not([class]){font-size:var(--tina-font-size-5);}h4:not([class]){font-size:var(--tina-font-size-4);}h5:not([class]){font-size:var(--tina-font-size-3);}h6:not([class]){font-size:var(--tina-font-size-2);}"]);
const StyleReset = styled.div.withConfig({
  displayName: "Styles__StyleReset",
  componentId: "sc-1igvyu7-0"
})(["", ""], tina_reset_styles);

const Button = styled.button.withConfig({
  displayName: "Button",
  componentId: "sc-qplww2-0"
})(["text-align:center;border:0;border-radius:var(--tina-radius-big);box-shadow:var(--tina-shadow-small);background-color:var(--tina-color-grey-0);border:1px solid var(--tina-color-grey-2);color:var(--tina-color-primary);fill:var(--tina-color-primary);font-weight:var(--tina-font-weight-regular);cursor:pointer;font-size:var(--tina-font-size-1);height:40px;padding:0 var(--tina-padding-big);transition:all 85ms ease-out;&:hover{background-color:var(--tina-color-grey-1);}&:active{background-color:var(--tina-color-grey-2);outline:none;}", ";", ";", ";", ";", ";", ";"], p => p.disabled && css(["opacity:0.3;pointer:not-allowed;pointer-events:none;"]), p => p.primary && css(["background-color:var(--tina-color-primary);color:var(--tina-color-grey-0);fill:var(--tina-color-grey-0);border:none;&:hover{background-color:var(--tina-color-primary-light);}&:active{background-color:var(--tina-color-primary-dark);}"]), p => p.small && css(["height:32px;font-size:var(--tina-font-size-0);padding:0 var(--tina-padding-big);"]), p => p.margin && css(["&:not(:first-child){margin-left:8px;}"]), p => p.grow && css(["flex-grow:1;"]), p => p.busy && css(["cursor:wait;"]));
const ICON_BUTTON_SIZE = 23;
const ICON_SIZE = 23;
const IconButton = styled(Button).withConfig({
  displayName: "Button__IconButton",
  componentId: "sc-qplww2-1"
})(["padding:0;width:", "px;height:", "px;margin:0;position:relative;transform-origin:50% 50%;transition:all 150ms ease-out;padding:0;display:flex;flex-shrink:0;justify-content:center;align-items:center;svg{width:", "px;height:", "px;transition:all 150ms ease-out;}", ";"], ICON_BUTTON_SIZE, ICON_BUTTON_SIZE, ICON_SIZE, ICON_SIZE, props => props.open && css(["background-color:var(--tina-color-grey-0);border-color:var(--tina-color-grey-2);outline:none;fill:var(--tina-color-primary);svg{transform:rotate(45deg);}&:hover{background-color:var(--tina-color-grey-1);}&:active{background-color:var(--tina-color-grey-2);}"]));

function InlineSettings(_ref) {
  let {
    fields
  } = _ref;
  const hasNoExtraFields = !(fields && fields.length);
  if (hasNoExtraFields) {
    return null;
  }
  return /*#__PURE__*/React__default.createElement(StyleReset, {
    onClick: e => {
      e.stopPropagation();
    },
    style: {
      height: "100%"
    }
  }, /*#__PURE__*/React__default.createElement(SettingsContent, {
    fields: fields
  }));
}
function SettingsContent(_ref2) {
  let {
    fields
  } = _ref2;
  const {
    form,
    focussedField
  } = useEditorContext();
  return /*#__PURE__*/React__default.createElement(FormBody, {
    id: "sidebar-panels-root"
  }, /*#__PURE__*/React__default.createElement(Wrapper$1, null, /*#__PURE__*/React__default.createElement(FieldsBuilder, {
    form: form,
    fields: fields
  }), /*#__PURE__*/React__default.createElement(SidebarFooter, {
    paths: focussedField
  })));
}
const FormBody = styled.div.withConfig({
  displayName: "inline-settings__FormBody",
  componentId: "sc-fe5cee-0"
})(["position:relative;flex:1 1 auto;display:flex;flex-direction:column;width:100%;height:100%;border-top:1px solid var(--tina-color-grey-2);background-color:white;"]);
const Wrapper$1 = styled.div.withConfig({
  displayName: "inline-settings__Wrapper",
  componentId: "sc-fe5cee-1"
})(["display:block;margin:0 auto;width:100%;height:100%;overflow-y:auto;"]);

const Error$1 = styled.div.withConfig({
  displayName: "EditorSidebar__Error",
  componentId: "sc-xkxfa3-0"
})(["", " padding:7px 6px 7px;color:hsl(0deg 0% 50% / 0.8);white-space:normal;background:hsl(0deg 100% 50% / 0.2);margin-right:10px;border-radius:2px;margin:16px;"], Fonts.body);
const EditorSidebar = props => {
  const {
    focussedField,
    form
  } = props;
  const editorContext = useEditorContext();
  const error = (() => {
    if (focussedField.length === 1) {
      const path = focussedField[0];
      const compiledComponent = dotNotationGet(editorContext.compiledComponentConfig, path);
      const editableComponent = dotNotationGet(form.values, path);
      if (compiledComponent?._component === "@easyblocks/missing-component") {
        return `Can’t find definition for component: ${editableComponent._component} in your project. Please contact your developers to resolve this issue.`;
      }
    }
    return null;
  })();
  const areMultipleFieldsSelected = focussedField.length > 1;
  const focusedFields = focussedField.length === 0 ? [""] : focussedField;
  const fieldsPerFocusedField = focusedFields.map(focusedField => {
    return buildTinaFields(focusedField, editorContext);
  });
  const mergedFields = areMultipleFieldsSelected ? mergeCommonFields({
    fields: fieldsPerFocusedField
  }) : fieldsPerFocusedField.flat();
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, error && /*#__PURE__*/React__default.createElement(Error$1, null, error), /*#__PURE__*/React__default.createElement(InlineSettings, {
    fields: mergedFields
  }));
};

function useOnClickNTimes(ref, count, event) {
  const counterRef = useRef(0);
  const timerRef = useRef();
  useEffect(() => {
    if (!ref.current) {
      return;
    }
    ref.current?.addEventListener("click", () => {
      clearTimeout(timerRef.current);
      counterRef.current++;
      if (counterRef.current === count) {
        event();
        counterRef.current = 0;
      }
      timerRef.current = setTimeout(() => {
        counterRef.current = 0;
      }, 300);
    });
  }, []);
}

const TOP_BAR_HEIGHT = 40;
const TopBar = styled.div.withConfig({
  displayName: "EditorTopBar__TopBar",
  componentId: "sc-726nw9-0"
})(["position:relative;box-sizing:border-box;background-color:white;border-bottom:1px solid #eaeaea;padding:0 64px;min-height:", "px;display:flex;flex-direction:row;justify-content:center;align-items:center;"], TOP_BAR_HEIGHT);
const Label = styled.div.withConfig({
  displayName: "EditorTopBar__Label",
  componentId: "sc-726nw9-1"
})(["background:", ";height:24px;", " display:flex;justify-content:center;align-items:center;padding-left:12px;padding-right:12px;border-radius:12px;color:white;"], Colors.purple, Fonts.label);
const TopBarLeft = styled.div.withConfig({
  displayName: "EditorTopBar__TopBarLeft",
  componentId: "sc-726nw9-2"
})(["position:absolute;top:0;left:4px;height:100%;display:flex;flex-direction:row;align-items:center;gap:4px;"]);
const TopBarRight = styled.div.withConfig({
  displayName: "EditorTopBar__TopBarRight",
  componentId: "sc-726nw9-3"
})(["position:absolute;top:0;right:8px;height:100%;display:flex;flex-direction:row;align-items:center;gap:16px;"]);
const TopBarCenter = styled.div.withConfig({
  displayName: "EditorTopBar__TopBarCenter",
  componentId: "sc-726nw9-4"
})(["position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);"]);
const EditorTopBar = _ref => {
  let {
    onClose,
    onViewportChange,
    devices,
    viewport,
    onIsEditingChange,
    isEditing,
    onUndo,
    onRedo,
    onAdminModeChange,
    hideCloseButton,
    readOnly
  } = _ref;
  const headingRef = useRef(null);
  useOnClickNTimes(headingRef, 5, () => {
    onAdminModeChange(true);
  });
  return /*#__PURE__*/React__default.createElement(TopBar, {
    ref: headingRef
  }, /*#__PURE__*/React__default.createElement(TopBarLeft, null, !hideCloseButton && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(ButtonGhost, {
    icon: Icons.Close,
    hideLabel: true,
    onClick: () => {
      if (onClose) {
        onClose();
      }
    }
  }, "Close"), /*#__PURE__*/React__default.createElement("div", {
    style: {
      height: "100%",
      background: Colors.black10,
      width: 1
    }
  })), /*#__PURE__*/React__default.createElement(ButtonGhost, {
    icon: Icons.Undo,
    hideLabel: true,
    onClick: () => {
      onUndo();
    }
  }, "Undo"), /*#__PURE__*/React__default.createElement(ButtonGhost, {
    icon: Icons.Redo,
    hideLabel: true,
    onClick: () => {
      onRedo();
    }
  }, "Redo"), readOnly && /*#__PURE__*/React__default.createElement(Label, null, "Read-Only")), /*#__PURE__*/React__default.createElement(TopBarCenter, null, /*#__PURE__*/React__default.createElement(DeviceSwitch, {
    devices: devices,
    deviceId: viewport,
    onDeviceChange: onViewportChange
  })), /*#__PURE__*/React__default.createElement(TopBarRight, null, /*#__PURE__*/React__default.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "row",
      gap: "6px",
      alignItems: "center"
    }
  }, /*#__PURE__*/React__default.createElement(Typography, {
    variant: "body",
    component: "label",
    htmlFor: "easyblocks-edit-mode-button"
  }, "Edit mode"), " ", /*#__PURE__*/React__default.createElement(Toggle$1, {
    name: "easyblocks-edit-mode-button",
    checked: isEditing,
    onChange: () => {
      onIsEditingChange();
    }
  }))));
};
const DEVICE_ID_TO_ICON = {
  xs: /*#__PURE__*/React__default.createElement("svg", {
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M10 2.51691H6C5.44772 2.51691 5 2.96463 5 3.51691L5.00005 12.483C5.00005 13.0353 5.44777 13.483 6.00005 13.483H10.0001C10.5523 13.483 11.0001 13.0353 11.0001 12.483L11 3.51691C11 2.96463 10.5523 2.51691 10 2.51691ZM6 1.51691C4.89543 1.51691 4 2.41234 4 3.51691L4.00005 12.483C4.00005 13.5876 4.89548 14.483 6.00005 14.483H10.0001C11.1046 14.483 12.0001 13.5876 12.0001 12.483L12 3.51691C12 2.41234 11.1046 1.51691 10 1.51691H6Z",
    fill: "black"
  }), /*#__PURE__*/React__default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M8.99548 12.5H7.00452V11.5H8.99548V12.5Z",
    fill: "black"
  })),
  sm: /*#__PURE__*/React__default.createElement("svg", {
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M2.51694 6.00005L2.51694 10C2.51694 10.5523 2.96466 11 3.51694 11L12.4831 11C13.0353 11 13.4831 10.5523 13.4831 9.99999L13.4831 5.99999C13.4831 5.44771 13.0353 4.99999 12.4831 4.99999L3.51694 5.00005C2.96466 5.00005 2.51694 5.44776 2.51694 6.00005ZM1.51694 10C1.51694 11.1046 2.41238 12 3.51694 12L12.4831 12C13.5876 12 14.4831 11.1046 14.4831 9.99999L14.4831 5.99999C14.4831 4.89542 13.5876 3.99999 12.4831 3.99999L3.51694 4.00005C2.41237 4.00005 1.51694 4.89548 1.51694 6.00005L1.51694 10Z",
    fill: "black"
  }), /*#__PURE__*/React__default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M12.5 7.00452L12.5 8.99548L11.5 8.99548L11.5 7.00452L12.5 7.00452Z",
    fill: "black"
  })),
  md: /*#__PURE__*/React__default.createElement("svg", {
    width: "16",
    height: "18",
    viewBox: "0 0 16 18",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M12.4918 1.97229L3.50793 1.9723C2.95565 1.9723 2.50793 2.42001 2.50793 2.9723L2.50797 15.0277C2.50797 15.58 2.95569 16.0277 3.50797 16.0277L12.4918 16.0277C13.0441 16.0277 13.4918 15.58 13.4918 15.0277L13.4918 2.97229C13.4918 2.42001 13.0441 1.97229 12.4918 1.97229ZM3.50793 0.972299C2.40337 0.972299 1.50793 1.86773 1.50793 2.9723L1.50797 15.0277C1.50797 16.1323 2.4034 17.0277 3.50797 17.0277L12.4918 17.0277C13.5964 17.0277 14.4918 16.1323 14.4918 15.0277L14.4918 2.97229C14.4918 1.86772 13.5964 0.97229 12.4918 0.97229L3.50793 0.972299Z",
    fill: "black"
  }), /*#__PURE__*/React__default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M10 14.9777H6V13.9777H10V14.9777Z",
    fill: "black"
  })),
  lg: /*#__PURE__*/React__default.createElement("svg", {
    width: "18",
    height: "16",
    viewBox: "0 0 18 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M1.97229 3.50815L1.9723 12.492C1.9723 13.0443 2.42001 13.492 2.9723 13.492L15.0277 13.492C15.58 13.492 16.0277 13.0443 16.0277 12.492L16.0277 3.50812C16.0277 2.95583 15.58 2.50812 15.0277 2.50812L2.97229 2.50815C2.42 2.50815 1.97229 2.95587 1.97229 3.50815ZM0.972299 12.492C0.972299 13.5966 1.86773 14.492 2.9723 14.492L15.0277 14.492C16.1323 14.492 17.0277 13.5965 17.0277 12.492L17.0277 3.50812C17.0277 2.40355 16.1323 1.50812 15.0277 1.50812L2.97229 1.50815C1.86772 1.50815 0.97229 2.40359 0.97229 3.50815L0.972299 12.492Z",
    fill: "black"
  }), /*#__PURE__*/React__default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M14.9778 6L14.9778 10L13.9778 10L13.9778 6L14.9778 6Z",
    fill: "black"
  })),
  xl: /*#__PURE__*/React__default.createElement("svg", {
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M14.5111 13.0004L1.48889 13.0004L1.48889 12.0004L14.5111 12.0004V13.0004Z",
    fill: "black"
  }), /*#__PURE__*/React__default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M12.5828 3.99961H3.41723V9.91598H12.5828V3.99961ZM2.5 2.99961V10.916H13.5V2.99961H2.5Z",
    fill: "black"
  })),
  "2xl": /*#__PURE__*/React__default.createElement("svg", {
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M14 3.00213H2V10.9979H14V3.00213ZM1 2.00213V11.9979H15V2.00213H1Z",
    fill: "black"
  }), /*#__PURE__*/React__default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M11 13.9979L5 13.9979V12.9979L11 12.9979V13.9979Z",
    fill: "black"
  })),
  "fit-screen": /*#__PURE__*/React__default.createElement("svg", {
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default.createElement("path", {
    d: "M14.2872 7.97504L12.2872 5.79322M14.2872 7.97504C14.2872 7.97504 13.0683 9.30481 12.2872 10.1569M14.2872 7.97504L10.0372 7.97504",
    stroke: "black"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M1.79272 7.97503L3.79272 10.1568M1.79272 7.97503C1.79272 7.97503 3.01168 6.64527 3.79272 5.79321M1.79272 7.97503L6.04272 7.97503",
    stroke: "black"
  }), /*#__PURE__*/React__default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M3.96777 2.52881H12.0323V4.49858H13.0323V1.52881H2.96777V4.49858H3.96777V2.52881ZM3.96777 11.5014H2.96777V14.4712H13.0323V11.5014H12.0323V13.4712H3.96777V11.5014Z",
    fill: "black"
  }))
};
function DeviceSwitch(_ref2) {
  let {
    deviceId,
    devices,
    onDeviceChange
  } = _ref2;
  return /*#__PURE__*/React__default.createElement(ToggleGroup, {
    value: deviceId,
    onChange: deviceId => {
      if (deviceId === "") {
        return;
      }
      onDeviceChange(deviceId);
    }
  }, devices.map(d => {
    if (d.hidden) {
      return null;
    }
    return /*#__PURE__*/React__default.createElement(Tooltip$1, {
      key: d.id
    }, /*#__PURE__*/React__default.createElement(TooltipTrigger, null, /*#__PURE__*/React__default.createElement(ToggleGroupItem, {
      value: d.id
    }, DEVICE_ID_TO_ICON[d.id])), /*#__PURE__*/React__default.createElement(TooltipContent, null, /*#__PURE__*/React__default.createElement(Typography, {
      color: "white"
    }, d.label ?? d.id)));
  }), /*#__PURE__*/React__default.createElement(Tooltip$1, null, /*#__PURE__*/React__default.createElement(TooltipTrigger, null, /*#__PURE__*/React__default.createElement(ToggleGroupItem, {
    value: "fit-screen"
  }, DEVICE_ID_TO_ICON["fit-screen"])), /*#__PURE__*/React__default.createElement(TooltipContent, null, /*#__PURE__*/React__default.createElement(Typography, {
    color: "white"
  }, "Fit screen"))));
}

function normalizeToStringArray(arg) {
  return typeof arg === "string" ? [arg] : Array.isArray(arg) ? arg : [];
}

function getAllComponentTypes(editorContext) {
  const componentTypes = getComponentTypesFromDefinitions(editorContext.definitions.components);
  return Array.from(new Set([...componentTypes]));
}
function getComponentTypesFromDefinitions(definitions) {
  const types = new Set();
  definitions.forEach(_ref => {
    let {
      type
    } = _ref;
    normalizeToStringArray(type).forEach(componentType => {
      types.add(componentType);
    });
  });
  return Array.from(types);
}

function getAllComponentsOfType(type, editorContext) {
  return getAllComponentsOfTypeFromDefinitionsArray(type, editorContext.definitions.components);
}
function getAllComponentsOfTypeFromDefinitionsArray(type, definitions) {
  return definitions.filter(definition => isNoCodeComponentOfType(definition, type));
}

function unrollAcceptsFieldIntoComponents(accepts, editorContext) {
  const allComponentTypes = getAllComponentTypes(editorContext);
  const idsSet = new Set();
  normalizeToStringArray(accepts).forEach(acceptsEntry => {
    if (allComponentTypes.includes(acceptsEntry)) {
      const componentType = acceptsEntry;
      const components = getAllComponentsOfType(componentType, editorContext);
      components.forEach(component => {
        idsSet.add(component);
      });
    } else {
      const componentId = acceptsEntry;
      const component = findComponentDefinitionById(componentId, editorContext);
      if (component) {
        idsSet.add(component);
      }
    }
  });
  return Array.from(idsSet);
}

const ModalPicker = _ref => {
  let {
    config,
    onClose,
    pickers
  } = _ref;
  const editorContext = useEditorContext();
  const {
    form
  } = editorContext;
  const split = config.path.split("."); // TODO: right now only for collections
  const parentPath = split.slice(0, split.length - 1).join(".");
  const fieldName = split[split.length - 1];
  const parentData = dotNotationGet(form.values, parentPath);
  const schemaProp = findComponentDefinition(parentData, editorContext).schema.find(x => x.prop === fieldName);
  const componentTypes = config.componentTypes ?? schemaProp.accepts;
  const components = unrollAcceptsFieldIntoComponents(componentTypes, editorContext);
  let templatesDictionary = undefined;
  if (editorContext.templates) {
    templatesDictionary = {};
    components.forEach(component => {
      templatesDictionary[component.id] = {
        component,
        templates: []
      };
      editorContext.templates.forEach(template => {
        if (component.id === template.entry._component) {
          templatesDictionary[component.id].templates.push(template);
        }
      });
      if (templatesDictionary[component.id].templates.length === 0) {
        delete templatesDictionary[component.id];
      }
    });
  }
  const picker = schemaProp.picker ?? "compact";

  // const defaultPickerMode =
  //   accepts.includes("section") || componentTypes.includes("card")
  //     ? "big"
  //     : "small";
  //
  // const pickerMode = schemaProp.picker || defaultPickerMode;

  const close = config => {
    const _itemProps = {
      [parentData._component]: {
        [fieldName]: {}
      }
    };
    const newComponent = fieldName.startsWith("$") ? config : duplicateConfig(normalize({
      ...config,
      _itemProps
    }, editorContext), editorContext);
    onClose(newComponent);
  };
  const onModalClose = template => {
    if (template) {
      close(normalize(template.entry, editorContext));
    } else {
      onClose();
    }
  };
  return pickers?.[picker] ? pickers[picker]({
    isOpen: true,
    onClose: onModalClose,
    templates: templatesDictionary,
    mode: picker
  }) : /*#__PURE__*/React__default.createElement("div", null, "Unknown picker: ", picker);
};

const TemplateModal = props => {
  const [error, setError] = useState(null);
  const mode = props.action.mode;
  const backend = props.backend;
  const editorContext = useEditorContext();
  const [isLoadingEdit, setLoadingEdit] = useState(false);
  const [isLoadingDelete, setLoadingDelete] = useState(false);
  const toaster = useToaster();
  const [template, setTemplate] = useState(() => {
    if (props.action.mode === "edit") {
      return props.action.template;
    } else {
      return {
        label: "",
        entry: props.action.config
      };
    }
  });
  const label = template.label ?? "";
  const open = props.action !== undefined;
  const canSend = label.trim() !== "";
  const ctaLabel = "Save";
  useEffect(() => {
    if (open) {
      setError(null);
    }
  }, [open]);
  return /*#__PURE__*/React__default.createElement(Modal, {
    title: `Template details`,
    isOpen: true,
    onRequestClose: () => {
      props.onClose();
    },
    mode: "center-small",
    headerLine: true
  }, /*#__PURE__*/React__default.createElement("form", {
    onSubmit: e => {
      e.preventDefault();
      setError(null);
      if (!canSend) {
        return;
      }
      setLoadingEdit(true);
      if (mode === "create") {
        const createAction = props.action;
        backend.templates.create({
          label,
          entry: createAction.config,
          width: createAction.width,
          widthAuto: createAction.widthAuto
        }).then(() => {
          editorContext.syncTemplates();
          toaster.success("Template created!");
          props.onClose();
        }).catch(() => {
          toaster.error("Couldn't save template");
        }).finally(() => {
          setLoadingEdit(false);
        });
      } else {
        backend.templates.update({
          label,
          id: template.id
        }).then(() => {
          editorContext.syncTemplates();
          toaster.success("Template updated!");
          props.onClose();
        }).catch(() => {
          toaster.error("Couldn't update template");
        }).finally(() => {
          setLoadingEdit(false);
        });
      }
    }
  }, error && /*#__PURE__*/React__default.createElement("div", null, error), /*#__PURE__*/React__default.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: "12px",
      marginTop: "8px"
    }
  }, /*#__PURE__*/React__default.createElement(FormElement, {
    name: "label",
    label: "Template name"
  }, /*#__PURE__*/React__default.createElement(Input, {
    placeholder: "My template name",
    required: true,
    value: label,
    onChange: e => {
      setTemplate({
        ...template,
        label: e.target.value
      });
    },
    withBorder: true,
    autoFocus: true
  })), /*#__PURE__*/React__default.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "row",
      justifyContent: "space-between",
      marginTop: 8
    }
  }, /*#__PURE__*/React__default.createElement("div", null, mode === "edit" && /*#__PURE__*/React__default.createElement(ButtonDanger, {
    onClick: e => {
      e.preventDefault();
      setLoadingDelete(true);
      backend.templates.delete({
        id: template.id
      }).then(() => {
        editorContext.syncTemplates();
        toaster.success("Template deleted");
        props.onClose();
      }).catch(() => {
        toaster.error("Couldn't delete template");
      }).finally(() => {
        setLoadingDelete(false);
      });
    },
    isLoading: isLoadingDelete
  }, "Delete")), /*#__PURE__*/React__default.createElement(ButtonPrimary, {
    type: "submit",
    disabled: !canSend,
    isLoading: isLoadingEdit
  }, ctaLabel)))));
};

function duplicateItem(form, _ref, compilationContext) {
  let {
    name,
    sourceIndex,
    targetIndex
  } = _ref;
  // Placeholders are not copyable
  if (isPlaceholder(name + "." + sourceIndex, form.values)) {
    return;
  }
  const configToDuplicate = dotNotationGet(form.values, name + "." + sourceIndex);
  form.mutators.insert(name, targetIndex, duplicateConfig(configToDuplicate, compilationContext));
}
function pasteItems(_ref2) {
  let {
    what,
    where,
    resolveDestination,
    pasteCommand
  } = _ref2;
  const successfulInsertsPaths = [];
  takeLastOfEachParent(where).sort(preOrderPathComparator()).map(initialDestination => {
    const destination = successfulInsertsPaths.reduce((acc, current) => shiftPath(acc, current, "downward"), initialDestination);
    const resolvedDestinations = resolveDestination(destination);
    return pasteCommand(resolvedDestinations);
  }).forEach(paste => {
    what.forEach(item => {
      const insertedPath = paste(item);
      if (insertedPath) {
        successfulInsertsPaths.push(insertedPath);
      }
    });
  });
  return successfulInsertsPaths.length !== 0 ? successfulInsertsPaths : where;
}

/**
 * Duplicates fields given in `fieldNames` within given `form`.
 * `compilationContext` is used to properly duplicate elements associated with given names.
 * @returns Array of fields to focus
 */
function duplicateItems(form, fieldNames, compilationContext) {
  const duplicatableFieldNames = fieldNames.filter(fieldName => isFieldDuplicatable(fieldName, form, compilationContext));
  if (duplicatableFieldNames.length === 0) {
    return;
  }
  const fieldsGroupedByParentPath = groupFieldsByParentPath(duplicatableFieldNames, "ascending");
  const nextFocusedFieldsPerGroup = [];
  Object.values(fieldsGroupedByParentPath).forEach((sortedFields, fieldsGroupIndex) => {
    nextFocusedFieldsPerGroup.push([]);
    const lastFieldIndex = getFieldPathIndex(last(sortedFields));
    sortedFields.forEach((focusedField, fieldIndex) => {
      const sourceIndex = getFieldPathIndex(focusedField);
      const targetIndex = lastFieldIndex + 1 + fieldIndex;
      const parentPath = getParentPath(focusedField);
      duplicateItem(form, {
        name: parentPath,
        sourceIndex,
        targetIndex
      }, compilationContext);
      nextFocusedFieldsPerGroup[fieldsGroupIndex].push(`${parentPath}.${lastFieldIndex + 1 + fieldIndex}`);
    });
  });
  return nextFocusedFieldsPerGroup.flat();
}
function moveItem(form, _ref3) {
  let {
    from,
    to,
    name
  } = _ref3;
  // Placeholders are not movable
  if (isPlaceholder(name + "." + from, form.values)) {
    return;
  }
  form.mutators.move(name, from, to);
}

/**
 * Moves fields given in `fieldNamesToRemove` within given `form` in given `direction`.
 * @returns Array of fields to focus.
 */
function moveItems(form, fieldsToMove, direction) {
  const nextFocusedFields = [];
  const isMovingMultipleFields = fieldsToMove.length > 1;
  if (direction === "top" || direction === "left") {
    const fieldsGroupedByParentPath = groupFieldsByParentPath(fieldsToMove, "ascending");
    Object.values(fieldsGroupedByParentPath).forEach(sortedFields => {
      let wasAnyFieldWithinCurrentGroupMoved = false;
      sortedFields.forEach((fieldName, fieldNameIndex) => {
        const index = getFieldPathIndex(fieldName);
        const parentPath = getParentPath(fieldName);
        if (isFirst(fieldName)) {
          if (isMovingMultipleFields) {
            nextFocusedFields.push(fieldName);
          }
          return;
        }
        if (isMovingMultipleFields && fieldNameIndex > 0 && !wasAnyFieldWithinCurrentGroupMoved) {
          nextFocusedFields.push(fieldName);
          return;
        }
        moveItem(form, {
          from: index,
          name: parentPath,
          to: index - 1
        });
        if (!wasAnyFieldWithinCurrentGroupMoved) {
          wasAnyFieldWithinCurrentGroupMoved = true;
        }
        nextFocusedFields.push(`${parentPath}.${index - 1}`);
      });
    });
    if (nextFocusedFields.length > 0) {
      return nextFocusedFields;
    }
  } else {
    const fieldsGroupedByParentPath = groupFieldsByParentPath(fieldsToMove, "descending");
    Object.values(fieldsGroupedByParentPath).forEach(sortedFields => {
      let wasAnyFieldWithinCurrentGroupMoved = false;
      sortedFields.forEach((fieldName, fieldNameIndex) => {
        if (isLast(fieldName, form)) {
          if (isMovingMultipleFields) {
            nextFocusedFields.push(fieldName);
          }
          return;
        }
        if (isMovingMultipleFields && fieldNameIndex > 0 && !wasAnyFieldWithinCurrentGroupMoved) {
          nextFocusedFields.push(fieldName);
          return;
        }
        const index = getFieldPathIndex(fieldName);
        const parentPath = getParentPath(fieldName);
        moveItem(form, {
          name: parentPath,
          from: index,
          to: index + 1
        });
        if (!wasAnyFieldWithinCurrentGroupMoved) {
          wasAnyFieldWithinCurrentGroupMoved = true;
        }
        nextFocusedFields.push(`${parentPath}.${index + 1}`);
      });
    });
    if (nextFocusedFields.length > 0) {
      return nextFocusedFields;
    }
  }
}
function removeItem(form, _ref4) {
  let {
    index,
    name
  } = _ref4;
  const configPathToRemove = name + "." + index;

  // Placeholders are not removable
  if (isPlaceholder(configPathToRemove, form.values)) {
    return;
  }
  const componentConfigValue = dotNotationGet(form.values, name);
  if (componentConfigValue.length === 1) {
    form.change(name, []);
  } else {
    form.mutators.remove(name, index);
  }
}

/**
 * Removes fields given in `fieldNamesToRemove` from given `form`.
 * @returns Array of fields to focus
 */
function removeItems(form, fieldNamesToRemove, compilationContext) {
  const removableFieldNames = fieldNamesToRemove.filter(fieldName => isFieldRemovable(fieldName, form, compilationContext));
  if (removableFieldNames.length === 0) {
    return;
  }
  const isRemovingMultipleFields = removableFieldNames.length > 1;
  const fieldsGroupedByParentPath = groupFieldsByParentPath(removableFieldNames, "descending");
  if (!isRemovingMultipleFields) {
    const {
      index,
      parent,
      templateId
    } = parsePath(removableFieldNames[0], form);
    if (index === undefined || !parent) {
      throw new Error("Invalid path");
    }
    const fieldPath = `${parent.path}${parent.path === "" ? "" : "."}${parent.fieldName}`;
    const itemsLength = dotNotationGet(form.values, fieldPath).length;
    const isOnlyItem = itemsLength === 1;
    const isLastItem = itemsLength - 1 === index;
    removeItem(form, {
      index,
      name: fieldPath
    });
    const definition = findComponentDefinitionById(templateId, compilationContext);
    const isTextWrapper = definition && isNoCodeComponentOfType(definition, "@easyblocks/text-wrapper");

    // If we're removing item from the text wrapper field let's focus the component holding that field for better UX
    // TODO: We shouldn't decide based on the component type but rather on the source of the removal (canvas vs sidebar)
    if (isTextWrapper) {
      return [parent.path];
    }
    if (isOnlyItem) {
      return [];
    } else if (isLastItem) {
      return [`${fieldPath}.${index - 1}`];
    } else {
      return [`${fieldPath}.${index}`];
    }
  }
  Object.values(fieldsGroupedByParentPath).forEach(sortedFields => {
    sortedFields.forEach(focusedField => {
      const field = dotNotationGet(form.values, focusedField);

      // Field could be already removed if its parent element was also selected
      if (!field) {
        return;
      }
      const index = getFieldPathIndex(focusedField);
      const parentPath = getParentPath(focusedField);
      removeItem(form, {
        index,
        name: parentPath
      });
    });
  });
  return [];
}
function replaceItems(paths, newConfig, editorContext) {
  paths.forEach(path => {
    dotNotationGet(editorContext.form.values, path);
    editorContext.form.change(path, duplicateConfig(
    // newConfig && oldConfig
    //   ? changeComponentConfig(oldConfig, newConfig, editorContext)
    //   : newConfig,
    newConfig, editorContext));
  });
}
function logItems(form, configPaths) {
  const configValues = configPaths.map(configPath => {
    return dotNotationGet(form.values, configPath);
  });
  configValues.forEach((config, index) => {
    console.log("Config for", configPaths[index], config);
  });
}
function groupFieldsByParentPath(fields, sortDirection) {
  const fieldsIndicesGroupedByParentPath = fields.reduce((accumulator, currentField) => {
    const index = getFieldPathIndex(currentField);
    const parentPath = getParentPath(currentField);
    const indices = accumulator[parentPath];
    if (indices) {
      accumulator[parentPath] = [...indices, index].sort((a, b) => {
        return sortDirection === "descending" ? b - a : a - b;
      });
      return accumulator;
    }
    accumulator[parentPath] = [index];
    return accumulator;
  }, {});
  return Object.fromEntries(Object.entries(fieldsIndicesGroupedByParentPath).map(_ref5 => {
    let [parentPath, indices] = _ref5;
    return [parentPath, indices.map(index => parentPath + "." + index)];
  }));
}
function getFieldPathIndex(fieldPath) {
  const index = +last(fieldPath.split("."));
  if (Number.isNaN(index)) {
    return -1;
  }
  return index;
}
function getParentPath(fieldPath) {
  const fieldPathParts = fieldPath.split(".");
  return fieldPathParts.slice(0, -1).join(".");
}
function isFirst(fieldPath) {
  const index = getFieldPathIndex(fieldPath);
  return index === 0;
}
function isLast(fieldPath, form) {
  const index = getFieldPathIndex(fieldPath);
  const parentPath = getParentPath(fieldPath);
  const parentFieldElementsCount = dotNotationGet(form.values, parentPath).length;
  return index === parentFieldElementsCount - 1;
}
function isPlaceholder(path, values) {
  const templateId = dotNotationGet(values, path)._component;
  return templateId.startsWith("$Placeholder");
}
function isFieldRemovable(fieldName, form, compilationContext) {
  const {
    parent
  } = parsePath(fieldName, form);
  if (parent) {
    const parentComponentDefinition = findComponentDefinitionById(parent.templateId, compilationContext);
    const fieldNameParent = last(getParentPath(fieldName).split("."));
    const fieldSchema = parentComponentDefinition?.schema.find(schema => schema.prop === fieldNameParent);
    if (fieldSchema && fieldSchema.type === "component" && fieldSchema.required) {
      return false;
    }
  }
  return true;
}
function isFieldDuplicatable(fieldName, form, compilationContext) {
  return isFieldRemovable(fieldName, form, compilationContext);
}
const shiftPath = function (originalPath, shiftingPath) {
  let direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "downward";
  const directionFactor = direction === "downward" ? 1 : -1;
  const original = shiftingPath.split(".");
  const shifting = originalPath.split(".");
  if (original.length < 2) {
    return originalPath;
  }
  let index = 0;
  while (index < original.length - 1 && index < shifting.length - 1) {
    if (shifting[index] !== original[index]) {
      return originalPath;
    }
    if (shifting[index + 1] !== original[index + 1]) {
      const numberA = Number(original[index + 1]);
      const numberB = Number(shifting[index + 1]);
      if (numberA < numberB && (index + 1 == original.length - 1 || index + 1 === shifting.length - 1)) {
        shifting.splice(index + 1, 1, String(numberB + directionFactor));
        return shifting.join(".");
      } else {
        return originalPath;
      }
    }
    index += 2;
  }
  return originalPath;
};
function takeLastOfEachParent(where) {
  const lastOfEachParent = where.reduce((acc, curr) => {
    const trimmed = getParentPath(curr);
    const index = getFieldPathIndex(curr);
    acc[trimmed] = Math.max(index, acc[trimmed] ?? Number.MIN_SAFE_INTEGER);
    return acc;
  }, {});
  return Object.entries(lastOfEachParent).map(_ref6 => {
    let [key, value] = _ref6;
    return `${key}.${value}`;
  });
}

function reconcile(_ref) {
  let {
    context,
    templateId,
    fieldName
  } = _ref;
  return item => {
    if (!fieldName || !templateId) {
      return item;
    }
    const contextMatches = item._itemProps?.[templateId]?.[fieldName] !== undefined;
    if (contextMatches) {
      return item;
    }
    return normalize({
      ...item,
      _itemProps: {
        [templateId]: {
          [fieldName]: {}
        }
      }
    }, context);
  };
}

const getTypes = schema => {
  if (schema?.type === "component-collection" || schema?.type === "component") {
    return schema.accepts;
  }
  return [];
};
const insertCommand = _ref => {
  let {
    context,
    form,
    schema,
    templateId
  } = _ref;
  const types = getTypes(schema);
  const reconcileItem = reconcile({
    context,
    templateId,
    fieldName: schema?.prop
  });
  return (path, index, item) => {
    const itemDefinition = findComponentDefinition(item, context);
    if (!itemDefinition) {
      return null;
    }
    const itemTypes = [itemDefinition.id, ...normalizeToStringArray(itemDefinition.type)];
    if (!includesAny(types, itemTypes)) {
      return null;
    }
    const reconciledItem = reconcileItem(item);
    const duplicatedItem = duplicateConfig(reconciledItem, context);
    form.mutators.insert(path, index, duplicatedItem);
    return `${path}.${index}`;
  };
};

function getSchema(path, context) {
  const parentDefinition = findComponentDefinitionById(path.parent?.templateId ?? "", context);
  const schema = (parentDefinition?.schema ?? []).find(s => s.prop === path.parent?.fieldName);
  return schema;
}
const toName = destination => [destination.parent?.path, destination.parent?.fieldName].filter(Boolean).join(".");
const fixIndexInCollection = function () {
  let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  let schema = arguments.length > 1 ? arguments[1] : undefined;
  if (schema?.type === "component-collection") {
    return index + 1;
  }
  return index;
};
function destinationResolver(_ref) {
  let {
    form,
    context
  } = _ref;
  return function (initialDestinationPath) {
    const resolvedDestinations = [];
    const resolvedPaths = new Set();
    const pathsQueue = [initialDestinationPath];
    while (pathsQueue.length > 0) {
      const path = pathsQueue.shift();
      if (!path) {
        continue;
      }
      if (resolvedPaths.has(path)) {
        continue;
      }
      if (!dotNotationGet(form.values, path)) {
        continue;
      }
      const parsed = parsePath(path, form);
      const definition = findComponentDefinitionById(parsed.templateId ?? "", context);
      if (!definition) {
        continue;
      }
      const schema = getSchema(parsed, context);
      resolvedDestinations.push({
        index: fixIndexInCollection(parsed.index, schema),
        name: toName(parsed),
        insert: insertCommand({
          context,
          form,
          schema,
          templateId: parsed.parent?.templateId
        })
      });
      for (const slot of definition.pasteSlots ?? []) {
        const slotSchema = definition.schema.find(_ref2 => {
          let {
            prop
          } = _ref2;
          return prop === slot;
        });
        if (!slotSchema) {
          continue;
        }
        const slotPath = `${path}.${slot}`;
        const slotValues = dotNotationGet(form.values, slotPath) ?? [];
        if (slotValues.length === 0) {
          resolvedDestinations.push({
            name: slotPath,
            index: 0,
            insert: insertCommand({
              context,
              form,
              schema: slotSchema,
              templateId: definition.id
            })
          });
        } else if (slotSchema.type === "component") {
          pathsQueue.push(`${slotPath}.0`);
        } else if (slotSchema.type === "component-collection") {
          pathsQueue.push(...Array.from(Array(slotValues.length).keys()).map(idx => `${slotPath}.${idx}`).reverse());
        }
      }
    }
    return resolvedDestinations;
  };
}

function pasteManager() {
  const inserts = new Map();
  return destinations => item => {
    let i = 0;
    while (i < destinations.length) {
      const {
        index,
        name,
        insert
      } = destinations[i];
      const path = `${name}.${index}`;
      const latestDestinationInserts = inserts.get(path) ?? 0;
      const result = insert(name, index + latestDestinationInserts, item);
      if (result) {
        inserts.set(path, latestDestinationInserts + 1);
        return result;
      }
      i++;
    }
    return null;
  };
}

function editorVariable(name) {
  return `--shopstory-editor-${name}`;
}
const BEFORE_ADD_BUTTON_DISPLAY = editorVariable("before-add-button-display");
const BEFORE_ADD_BUTTON_TOP = editorVariable("before-add-button-top");
const BEFORE_ADD_BUTTON_LEFT = editorVariable("before-add-button-left");
const AFTER_ADD_BUTTON_DISPLAY = editorVariable("after-add-button-display");
const AFTER_ADD_BUTTON_TOP = editorVariable("after-add-button-top");
const AFTER_ADD_BUTTON_LEFT = editorVariable("after-add-button-left");

function AddButton(_ref) {
  let {
    position,
    index,
    offset,
    onClick
  } = _ref;
  const [isOpen, setIsOpen] = React__default.useState(false);
  const addBlockButtonRef = React__default.useRef(null);
  const handleOpenBlockMenu = event => {
    event.stopPropagation();
    event.preventDefault();

    // Custom add action
    if (onClick) {
      onClick();
      return;
    }
  };
  React__default.useEffect(() => {
    const inactivateBlockMenu = () => setIsOpen(false);
    document.addEventListener("mouseup", inactivateBlockMenu, false);
    return () => document.removeEventListener("mouseup", inactivateBlockMenu);
  }, []);
  return /*#__PURE__*/React__default.createElement(AddButtonWrapper, {
    index: index,
    offset: offset,
    position: position,
    isOpen: isOpen
  }, /*#__PURE__*/React__default.createElement(AddIconButton, {
    ref: addBlockButtonRef,
    onClick: handleOpenBlockMenu,
    isOpen: isOpen,
    primary: true,
    small: true
  }, /*#__PURE__*/React__default.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "23",
    height: "23",
    viewBox: "0 0 23 23",
    fill: "none"
  }, /*#__PURE__*/React__default.createElement("line", {
    x1: "11.5",
    y1: "4",
    x2: "11.5",
    y2: "19",
    stroke: "currentColor"
  }), /*#__PURE__*/React__default.createElement("line", {
    x1: "4",
    y1: "11.5",
    x2: "19",
    y2: "11.5",
    stroke: "currentColor"
  }))));
}
const AddIconButton = styled(IconButton).withConfig({
  displayName: "AddButton__AddIconButton",
  componentId: "sc-79bcl2-0"
})(["display:flex;align-items:center;&:focus{outline:none !important;}", ";"], props => props.isOpen && css(["pointer-events:none;"]));
const AddButtonWrapper = styled.div.withConfig({
  displayName: "AddButton__AddButtonWrapper",
  componentId: "sc-79bcl2-1"
})(["position:absolute;top:var( ", " );left:var( ", " );display:var( ", ",none );pointer-events:all;"], _ref2 => {
  let {
    position
  } = _ref2;
  return position === "before" ? BEFORE_ADD_BUTTON_TOP : AFTER_ADD_BUTTON_TOP;
}, _ref3 => {
  let {
    position
  } = _ref3;
  return position === "before" ? BEFORE_ADD_BUTTON_LEFT : AFTER_ADD_BUTTON_LEFT;
}, _ref4 => {
  let {
    position
  } = _ref4;
  return position === "before" ? BEFORE_ADD_BUTTON_DISPLAY : AFTER_ADD_BUTTON_DISPLAY;
});

const Wrapper = styled.div.withConfig({
  displayName: "SelectionFramestyles__Wrapper",
  componentId: "sc-xqih8j-0"
})(["position:absolute;top:0;left:0;bottom:0;right:0;display:grid;place-items:center;pointer-events:none;"]);
const FrameWrapper = styled.div.attrs(_ref => {
  let {
    width,
    height,
    transform
  } = _ref;
  return {
    style: {
      width,
      height,
      transform
    }
  };
}).withConfig({
  displayName: "SelectionFramestyles__FrameWrapper",
  componentId: "sc-xqih8j-1"
})(["position:relative;z-index:1;display:grid;place-items:center;transform-origin:left;"]);

function calculateAddButtonsProperties(direction, targetElementRect, viewport, containerElementRect) {
  const halfButtonSize = Math.floor(ICON_BUTTON_SIZE / 2);
  if (direction === "vertical") {
    const beforeButtonTopOffset = Math.floor(targetElementRect.top - halfButtonSize);
    const afterButtonTopOffset = Math.floor(targetElementRect.top + targetElementRect.height - halfButtonSize);
    const buttonsLeftOffset = Math.floor(targetElementRect.left + targetElementRect.width / 2 - halfButtonSize);
    const isBeforeButtonWithinViewport = isButtonWithinViewport({
      top: beforeButtonTopOffset + halfButtonSize,
      left: buttonsLeftOffset + halfButtonSize
    }, viewport);
    const isAfterButtonWithinViewport = isButtonWithinViewport({
      top: afterButtonTopOffset + halfButtonSize,
      left: buttonsLeftOffset + halfButtonSize
    }, viewport);
    if (containerElementRect) {
      const isBeforeButtonWithinContainer = isButtonWithinContainer({
        top: beforeButtonTopOffset + halfButtonSize,
        left: buttonsLeftOffset + halfButtonSize
      }, containerElementRect);
      const isAfterButtonWithinContainer = isButtonWithinContainer({
        top: afterButtonTopOffset + halfButtonSize,
        left: buttonsLeftOffset + halfButtonSize
      }, containerElementRect);
      return {
        before: {
          top: beforeButtonTopOffset,
          left: buttonsLeftOffset,
          display: isBeforeButtonWithinViewport && isBeforeButtonWithinContainer ? "block" : "none"
        },
        after: {
          top: afterButtonTopOffset,
          left: buttonsLeftOffset,
          display: isAfterButtonWithinViewport && isAfterButtonWithinContainer ? "block" : "none"
        }
      };
    } else {
      return {
        before: {
          top: beforeButtonTopOffset,
          left: buttonsLeftOffset,
          display: isBeforeButtonWithinViewport ? "block" : "none"
        },
        after: {
          top: afterButtonTopOffset,
          left: buttonsLeftOffset,
          display: isAfterButtonWithinViewport ? "block" : "none"
        }
      };
    }
  } else {
    const buttonsTopOffset = Math.floor(targetElementRect.top + targetElementRect.height / 2 - halfButtonSize);
    const beforeButtonLeftOffset = Math.floor(targetElementRect.left - halfButtonSize);
    const afterButtonLeftOffset = Math.floor(targetElementRect.left + targetElementRect.width - halfButtonSize);
    const isBeforeButtonWithinViewport = isButtonWithinViewport({
      top: buttonsTopOffset + halfButtonSize,
      left: beforeButtonLeftOffset + halfButtonSize
    }, viewport);
    const isAfterButtonWithinViewport = isButtonWithinViewport({
      top: buttonsTopOffset + halfButtonSize,
      left: afterButtonLeftOffset + halfButtonSize
    }, viewport);
    if (containerElementRect) {
      const isBeforeButtonWithinContainer = isButtonWithinContainer({
        top: buttonsTopOffset + halfButtonSize,
        left: beforeButtonLeftOffset + halfButtonSize
      }, containerElementRect);
      const isAfterButtonWithinContainer = isButtonWithinContainer({
        top: buttonsTopOffset + halfButtonSize,
        left: afterButtonLeftOffset + halfButtonSize
      }, containerElementRect);
      return {
        before: {
          top: buttonsTopOffset,
          left: beforeButtonLeftOffset,
          display: isBeforeButtonWithinViewport && isBeforeButtonWithinContainer ? "block" : "none"
        },
        after: {
          top: buttonsTopOffset,
          left: afterButtonLeftOffset,
          display: isAfterButtonWithinViewport && isAfterButtonWithinContainer ? "block" : "none"
        }
      };
    } else {
      return {
        before: {
          top: buttonsTopOffset,
          left: beforeButtonLeftOffset,
          display: isBeforeButtonWithinViewport ? "block" : "none"
        },
        after: {
          top: buttonsTopOffset,
          left: afterButtonLeftOffset,
          display: isAfterButtonWithinViewport ? "block" : "none"
        }
      };
    }
  }
}
function isButtonWithinViewport(target, viewport) {
  return target.top >= 0 && target.top <= viewport.height && target.left >= 0 && target.left <= viewport.width;
}
function isButtonWithinContainer(target, container) {
  return target.top >= container.top && target.top <= container.bottom && target.left >= container.left && target.left <= container.right;
}

function SelectionFrame(_ref) {
  let {
    width,
    height,
    transform
  } = _ref;
  const editorContext = useEditorContext();
  const {
    focussedField,
    form,
    actions
  } = editorContext;
  const compiledFocusedField = focussedField.length === 1 ? pathToCompiledPath(focussedField[0], editorContext) : undefined;
  const compiledComponentConfig = compiledFocusedField ? dotNotationGet(editorContext.compiledComponentConfig, compiledFocusedField) : undefined;
  const {
    direction = "vertical"
  } = compiledComponentConfig?.__editing ?? {};
  const isAddingEnabled = isAddingEnabledForSelectedFields(focussedField, editorContext);
  useLayoutEffect(() => {
    if (focussedField.length === 0) {
      hideAddButtons();
    }
  }, [focussedField]);
  useLayoutEffect(() => {
    function handleSelectionFrameMessages(event) {
      if (!isAddingEnabled) {
        hideAddButtons();
        return;
      }
      if (event.data.type === "@easyblocks-editor/selection-frame-position-changed") {
        updateAddButtons(direction, event.data.payload.target, {
          width,
          height
        }, event.data.payload.container);
      }
    }
    window.addEventListener("message", handleSelectionFrameMessages);
    return () => {
      window.removeEventListener("message", handleSelectionFrameMessages);
    };
  }, [direction, height, isAddingEnabled, width]);
  async function handleAddButtonClick(which) {
    let path = focussedField.length === 1 ? focussedField[0] : undefined;
    if (!path) {
      return;
    }
    if (isConfigPathRichTextPart(path)) {
      path = path.replace(RICH_TEXT_PART_CONFIG_PATH_REGEXP, "");
    }
    const {
      parent,
      index
    } = parsePath(path, form);
    if (!parent || index === undefined) {
      return;
    }
    const definition = findComponentDefinitionById(parent.templateId, editorContext);
    const schemaProp = definition?.schema.find(schemaProp => schemaProp.prop === parent.fieldName);
    if (!schemaProp) {
      return;
    }
    const parentPath = parent.path + (parent.path === "" ? "" : ".") + parent.fieldName;
    const config = await actions.openComponentPicker({
      path: parentPath
    });
    if (config) {
      actions.insertItem({
        name: schemaProp.type === "component-collection-localised" ? `${parentPath}.${editorContext.contextParams.locale}` : parentPath,
        index: which === "before" ? index : index + 1,
        block: config
      });
    }
  }
  return /*#__PURE__*/React__default.createElement(Wrapper, null, /*#__PURE__*/React__default.createElement(FrameWrapper, {
    width: width,
    height: height,
    transform: transform
  }, /*#__PURE__*/React__default.createElement(AddButton, {
    position: "before",
    onClick: () => handleAddButtonClick("before")
  }), /*#__PURE__*/React__default.createElement(AddButton, {
    position: "after",
    onClick: () => handleAddButtonClick("after")
  })));
}
function updateAddButtons(direction, targetElementRect, viewport, containerElementRect) {
  const {
    after,
    before
  } = calculateAddButtonsProperties(direction, targetElementRect, viewport, containerElementRect);
  setCssVariable(BEFORE_ADD_BUTTON_TOP, before.top + "px");
  setCssVariable(BEFORE_ADD_BUTTON_LEFT, before.left + "px");
  setCssVariable(AFTER_ADD_BUTTON_TOP, after.top + "px");
  setCssVariable(AFTER_ADD_BUTTON_LEFT, after.left + "px");
  setCssVariable(BEFORE_ADD_BUTTON_DISPLAY, before.display);
  setCssVariable(AFTER_ADD_BUTTON_DISPLAY, after.display);
}
function hideAddButtons() {
  setCssVariable(BEFORE_ADD_BUTTON_DISPLAY, "none");
  setCssVariable(AFTER_ADD_BUTTON_DISPLAY, "none");
}
function setCssVariable(name, value) {
  document.documentElement.style.setProperty(name, value.toString());
}
function isAddingEnabledForSelectedFields(focusedFields, editorContext) {
  if (focusedFields.length === 0) {
    return false;
  } else if (focusedFields.length === 1) {
    if (isConfigPathRichTextPart(focusedFields[0])) {
      return false;
    }
    const {
      parent
    } = parsePath(focusedFields[0], editorContext.form);
    if (!parent) return false;
    const parentDefinition = findComponentDefinitionById(parent.templateId, editorContext);
    const schemaProp = parentDefinition?.schema.find(schemaProp => schemaProp.prop === parent.fieldName);
    if (!schemaProp) return false;
    return isSchemaPropCollection(schemaProp);
  } else {
    return false;
  }
}

/**
 * Traverses recursively the config tree (similar to traverseConfig) but behaves like "Array.map". It returns new tree with elements mapped to new ones.
 * Responsive values are mapped "per breakpoint", it smells a bit, maybe in the future we'll have to apply some flag to have option whether we want to disassemble responsives or not.
 */

function configMapArray(configArray, context, callback, prefix) {
  /**
   * Why this?
   *
   * Sometimes you might need configMap for config that have not yet been normalized. Such config still can be considered correct if it has a component that have a new schema property. Example of this is mergeSingleLocaleConfigsIntoConfig.
   */
  if (configArray === undefined) {
    return;
  }
  if (!Array.isArray(configArray)) {
    return;
  }
  return configArray.map((x, index) => configMapInternal(x, context, callback, `${prefix}.${index}`));
}
function configMap(config, context, callback) {
  return configMapInternal(config, context, callback, "");
}
function configMapInternal(config, context, callback, prefix) {
  const componentDefinition = findComponentDefinition(config, context);
  const result = {
    ...config
  };
  if (!componentDefinition) {
    return result;
  }
  prefix = prefix === undefined || prefix === "" ? "" : `${prefix}.`;
  componentDefinition.schema.forEach(schemaProp => {
    if (schemaProp.type === "component-collection-localised") {
      if (config[schemaProp.prop] === undefined) {
        return;
      }
      result[schemaProp.prop] = {};
      for (const locale in config[schemaProp.prop]) {
        if (locale === "__fallback") {
          continue;
        }
        result[schemaProp.prop][locale] = configMapArray(config[schemaProp.prop][locale], context, callback, `${prefix}${schemaProp.prop}.${locale}`);
      }
      result[schemaProp.prop] = callback({
        value: result[schemaProp.prop],
        path: `${prefix}${schemaProp.prop}`,
        schemaProp
      });
    } else if (schemaProp.type === "component" || schemaProp.type === "component-collection") {
      result[schemaProp.prop] = configMapArray(config[schemaProp.prop], context, callback, `${prefix}${schemaProp.prop}`);
      result[schemaProp.prop] = callback({
        value: result[schemaProp.prop],
        path: `${prefix}${schemaProp.prop}`,
        schemaProp
      });
    } else {
      if (isTrulyResponsiveValue$2(result[schemaProp.prop])) {
        const mappedVal = {
          $res: true
        };
        for (const key in result[schemaProp.prop]) {
          if (key === "$res") {
            continue;
          }
          mappedVal[key] = callback({
            value: result[schemaProp.prop][key],
            schemaProp,
            path: `${prefix}${schemaProp.prop}.${key}`
          });
        }
        result[schemaProp.prop] = mappedVal;
      } else {
        result[schemaProp.prop] = callback({
          value: result[schemaProp.prop],
          schemaProp,
          path: `${prefix}${schemaProp.prop}`
        });
      }
    }
  });
  return result;
}

function getDefaultTemplateForDefinition(def, editorContext) {
  // Text has different way of building a default config
  const config = def.id === "@easyblocks/rich-text" ? buildRichTextNoCodeEntry$1({
    color: getDefaultTokenId(editorContext.theme.colors),
    font: getDefaultTokenId(editorContext.theme.fonts)
  }) : {
    _component: def.id,
    _id: uniqueId()
  };
  return {
    id: `${def.id}_default`,
    label: def.label ?? def.id,
    entry: config,
    isUserDefined: false
  };
}
function getDefaultTokenId(tokens) {
  return Object.entries(tokens).find(_ref => {
    let [, value] = _ref;
    return value.isDefault;
  })?.[0];
}
async function getTemplates(editorContext) {
  let configTemplates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  const remoteUserDefinedTemplates = !editorContext.disableCustomTemplates ? await editorContext.backend.templates.getAll() : [];
  return getTemplatesInternal(editorContext, configTemplates, remoteUserDefinedTemplates);
}
function getNecessaryDefaultTemplates(components, templates, editorContext) {
  const result = [];
  components.forEach(component => {
    const componentTemplates = templates.filter(template => template.entry._component === component.id);
    if (componentTemplates.length === 0) {
      result.push(getDefaultTemplateForDefinition(component, editorContext));
    }
  });
  return result;
}
function normalizeTextLocales(config, editorContext) {
  return configMap(config, editorContext, _ref2 => {
    let {
      value,
      schemaProp
    } = _ref2;
    if (schemaProp.type === "text") {
      const firstDefinedValue = Object.values(value.value).filter(x => x !== null && x !== undefined)[0];
      return {
        ...value,
        value: {
          [getDefaultLocale$1(editorContext.locales).code]: firstDefinedValue
        }
      };
    } else if (schemaProp.type === "component-collection-localised") {
      const firstDefinedValue = Object.values(value).filter(x => x !== null && x !== undefined)[0];
      return {
        [getDefaultLocale$1(editorContext.locales).code]: firstDefinedValue
      };
    }
    return value;
  });
}
function getTemplatesInternal(editorContext, configTemplates, remoteUserDefinedTemplates) {
  // If a component doesn't have a template, here's one added
  const allBuiltinTemplates = [...configTemplates, ...getNecessaryDefaultTemplates(editorContext.definitions.components, configTemplates, editorContext)];
  const allUserTemplates = [...remoteUserDefinedTemplates, ...allBuiltinTemplates];
  const result = allUserTemplates.filter(template => {
    const definition = findComponentDefinitionById(template.entry._component, editorContext);
    if (!definition || definition.hideTemplates) {
      return false;
    }
    return true;
  })
  // .filter((template) => {
  //
  //   const result = template.entry._itemProps
  //     ? Object.keys(template.entry._itemProps).every((componentId) =>
  //       findComponentDefinitionById(componentId, editorContext)
  //     )
  //     : true;
  //
  //   if (template.entry._component === "ProductCard") {
  //     console.log('WOW2222!!!', result);
  //   }
  //
  //   return result;
  // })
  .map(template => {
    const newTemplate = {
      ...template,
      entry: normalizeTextLocales(normalize({
        ...template.entry,
        _itemProps: {}
      }, editorContext), editorContext)
    };
    return newTemplate;
  });
  return result;
}

class Form {
  loading = false;
  constructor(_ref) {
    let {
      id,
      label,
      fields,
      actions,
      buttons,
      reset,
      loadInitialValues,
      onChange,
      ...options
    } = _ref;
    const initialValues = options.initialValues || {};
    this.__type = options.__type || "form";
    this.id = id;
    this.label = label;
    this.fields = fields || [];
    this.onSubmit = options.onSubmit;
    this.finalForm = createForm$1({
      ...options,
      initialValues,
      onSubmit: this.handleSubmit,
      mutators: {
        ...arrayMutators,
        ...options.mutators
      }
    });
    this._reset = reset;
    this.actions = actions || [];
    this.buttons = buttons || {
      save: "Save",
      reset: "Reset"
    };
    this.updateFields(this.fields);
    if (loadInitialValues) {
      this.loading = true;
      loadInitialValues().then(initialValues => {
        this.updateInitialValues(initialValues);
      }).finally(() => {
        this.loading = false;
      });
    }
    if (onChange) {
      let firstUpdate = true;
      this.subscribe(formState => {
        if (firstUpdate) {
          firstUpdate = false;
        } else {
          onChange(formState);
        }
      }, {
        values: true
      });
    }
  }

  /**
   * Returns the current values of the form.
   *
   * if the form is still loading it returns `undefined`.
   */
  get values() {
    if (this.loading) {
      return undefined;
    }
    return this.finalForm.getState().values || this.initialValues;
  }

  /**
   * The values the form was initialized with.
   */
  get initialValues() {
    return this.finalForm.getState().initialValues;
  }

  /**
   * @deprecated Unnecessary indirection
   */
  updateFields(fields) {
    this.fields = fields;
  }

  /**
   * Subscribes to changes to the form. The subscriber will only be called when
   * values specified in subscription change. A form can have many subscribers.
   */
  subscribe = (cb, options) => {
    return this.finalForm.subscribe(cb, options);
  };
  handleSubmit = async (values, form, cb) => {
    try {
      const response = await this.onSubmit(values, form, cb);
      form.initialize(values);
      return response;
    } catch (error) {
      return {
        [FORM_ERROR]: error
      };
    }
  };

  /**
   * Changes the value of the given field.
   *
   * @param name
   * @param value
   */
  change(name, value) {
    if (process.env.NODE_ENV === "development") {
      console.groupCollapsed("Change to", name === "" ? '""' : `"${name}"`);
      console.log("Old config", this.values);
      console.log("Old value", dotNotationGet(this.values, name));
      this.finalForm.change(name, value);
      console.log("New config", this.values);
      console.log("New value", value);
      console.groupEnd();
      return;
    }
    return this.finalForm.change(name, value);
  }
  get mutators() {
    return this.finalForm.mutators;
  }

  /**
   * Updates multiple fields in the form.
   *
   * The updates are batched so that it only triggers one `onChange` event.
   *
   * In order to prevent disruptions to the user's editing experience this
   * function will _not_ update the value of any field that is currently
   * being edited.
   *
   * @param values
   */
  updateValues(values) {
    this.finalForm.batch(() => {
      const activePath = this.finalForm.getState().active;
      if (!activePath) {
        updateEverything(this.finalForm, values);
      } else {
        updateSelectively(this.finalForm, values);
      }
    });
  }

  /**
   * Replaces the initialValues of the form without deleting the current values.
   *
   * This function is helpful when the initialValues are loaded asynchronously.
   *
   * @param initialValues
   */
  updateInitialValues(initialValues) {
    this.finalForm.batch(() => {
      const values = this.values || {};
      this.finalForm.initialize(initialValues);
      const activePath = this.finalForm.getState().active;
      if (!activePath) {
        updateEverything(this.finalForm, values);
      } else {
        updateSelectively(this.finalForm, values);
      }
    });
  }
}
function updateEverything(form, values) {
  Object.entries(values).forEach(_ref2 => {
    let [path, value] = _ref2;
    form.change(path, value);
  });
}
function updateSelectively(form, values, prefix) {
  const activePath = form.getState().active;
  Object.entries(values).forEach(_ref3 => {
    let [name, value] = _ref3;
    const path = prefix ? `${prefix}.${name}` : name;
    if (typeof value === "object") {
      if (activePath.startsWith(path)) {
        updateSelectively(form, value, path);
      } else {
        form.change(path, value);
      }
    } else if (path !== activePath) {
      form.change(path, value);
    }
  });
}

/**
 * A hook that creates a form and updates it's watched properties.
 */
function useForm(_ref) {
  let {
    loadInitialValues,
    ...options
  } = _ref;
  let watch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  /**
   * `initialValues` will be usually be undefined if `loadInitialValues` is used.
   *
   * If the form helper is using `watch.values`, which would contain
   * the current state of the form, then we set that to the `initialValues`
   * so the form is initialized with some state.
   *
   * This is beneficial for SSR and will hopefully not be noticeable
   * when editing the site as the actual `initialValues` will be set
   * behind the scenes.
   */
  options.initialValues = options.initialValues || watch.values;
  const [, setValues] = React__default.useState(options.initialValues);
  const [form, setForm] = React__default.useState(() => {
    return createForm(options, form => {
      setValues(form.values);
    });
  });
  React__default.useEffect(function () {
    if (form.id === options.id) return;
    setForm(createForm(options, form => {
      setValues(form.values);
    }));
  }, [options.id]);
  const [formIsLoading, setFormIsLoading] = React__default.useState(() => loadInitialValues ? true : false);
  const loadFormData = React__default.useCallback(async () => {
    if (loadInitialValues) {
      setFormIsLoading(true);
      await loadInitialValues().then(values => {
        form.updateInitialValues(values);
      }).finally(() => {
        setFormIsLoading(false);
      });
    }
  }, [form, setFormIsLoading]);
  React__default.useEffect(() => {
    loadFormData();
  }, [form, loadFormData]);
  useUpdateFormFields(form, watch.fields);
  useUpdateFormLabel(form, watch.label);
  useUpdateFormValues(form, watch.values);
  return [form ? form.values : options.initialValues, form, formIsLoading];
}
function createForm(options, handleChange) {
  const form = new Form(options);
  form.subscribe(handleChange, {
    values: true
  });
  return form;
}

/**
 * A React Hook that update's the `Form` if `fields` are changed.
 *
 * This hook is useful when dynamically creating fields, or updating
 * them via hot module replacement.
 */
function useUpdateFormFields(form, fields) {
  React__default.useEffect(() => {
    if (typeof fields === "undefined") return;
    form.updateFields(fields);
  }, [form, fields]);
}

/**
 * A React Hook that update's the `Form` if the `label` is changed.
 *
 * This hook is useful when dynamically creating creating the label,
 * or updating it via hot module replacement.
 */
function useUpdateFormLabel(form, label) {
  React__default.useEffect(() => {
    if (typeof label === "undefined") return;
    form.label = label;
  }, [form, label]);
}

/**
 * Updates the Form with new values.
 *
 * Only updates fields that are:
 *
 * 1. registered with the form
 * 2. not currently [active](https://final-form.org/docs/final-form/types/FieldState#active)
 *
 * This hook is useful when the form must be kept in sync with the data source.
 */
function useUpdateFormValues(form, values) {
  React__default.useEffect(() => {
    if (typeof values === "undefined") return;
    form.updateValues(values);
  }, [form, values]);
}

/**
 * Outputs comparable config that is FULL COPY of config
 */
function getConfigSnapshot(config) {
  const strippedConfig = deepClone(config);
  return strippedConfig;
}

function addLocalizedFlag(config, context) {
  return configMap(config, context, _ref => {
    let {
      value,
      schemaProp
    } = _ref;
    if (schemaProp.type === "text" && value.id?.startsWith("local.") || schemaProp.type === "component-collection-localised") {
      return {
        __localized: true,
        ...value
      };
    }
    return value;
  });
}

function removeLocalizedFlag(config, context) {
  return configMap(config, context, _ref => {
    let {
      value,
      schemaProp
    } = _ref;
    if (schemaProp.type === "text" && value.id.startsWith("local.") || schemaProp.type === "component-collection-localised") {
      delete value.__localized;
    }
    return value;
  });
}

/**
 * useDataSaver works in a realm of SINGLE CONFIG.
 * @param initialDocument
 * Data saver will use this document as a starting point. It can be `null` if there is no document yet.
 * Data saver will perform first save when any local change is detected.
 */
function useDataSaver(initialDocument, editorContext) {
  const remoteDocument = useRef(initialDocument);

  /**
   * This state variable is going to be used ONLY for comparison with local config in case of missing document.
   * It's not going to change at any time during the lifecycle of this hook.
   */
  const [initialConfigInCaseOfMissingDocument] = useState(deepClone(editorContext.form.values));
  const onTickRef = useRef(() => Promise.resolve());
  const onTick = async () => {
    // Playground mode is a special case, we don't want to save anything
    if (editorContext.readOnly) {
      return;
    }
    const localConfig = editorContext.form.values;
    const localConfigSnapshot = getConfigSnapshot(localConfig);
    const previousConfig = remoteDocument.current ? remoteDocument.current.entry : initialConfigInCaseOfMissingDocument;
    const previousConfigSnapshot = getConfigSnapshot(previousConfig);
    const isConfigTheSame = deepCompare(localConfigSnapshot, previousConfigSnapshot);
    const configToSaveWithLocalisedFlag = addLocalizedFlag(localConfigSnapshot, editorContext);
    async function runSaveCallback() {
      await editorContext.save(remoteDocument.current);
    }

    // New document
    if (remoteDocument.current === null) {
      console.debug("New document");

      // There must be at least one change in order to create a new document, we're not storing empty temporary documents
      if (isConfigTheSame) {
        console.debug("no change -> bye");
        return;
      }
      console.debug("change detected! -> create");
      const newDocument = await editorContext.backend.documents.create({
        entry: configToSaveWithLocalisedFlag
      });
      remoteDocument.current = {
        ...newDocument,
        // @ts-ignore
        config: {
          config: configToSaveWithLocalisedFlag
        }
      };
      await runSaveCallback();
    }
    // Document update
    else {
      console.debug("Existing document");
      const latestDocument = await editorContext.backend.documents.get({
        id: remoteDocument.current.id
      });
      const latestRemoteDocumentVersion = latestDocument.version ?? -1;
      const isNewerDocumentVersionAvailable = remoteDocument.current.version < latestRemoteDocumentVersion;

      // Newer version of document is available
      if (isNewerDocumentVersionAvailable) {
        console.debug("new remote version detected, updating");
        if (!latestDocument) {
          throw new Error("unexpected error");
        }
        const latestConfig = removeLocalizedFlag(latestDocument.entry, editorContext);
        editorContext.actions.runChange(() => {
          editorContext.form.change("", latestConfig);
          return [];
        });
        remoteDocument.current = latestDocument;

        // Notify when local config was modified
        if (!isConfigTheSame) {
          console.debug("there were local changes -> notify");
          editorContext.actions.notify("Remote changes detected, local changes have been overwritten.");
        }
        return;
      }
      // No remote change occurred
      else {
        if (isConfigTheSame) {
          console.debug("no local changes -> bye");
          // Let's do nothing, no remote and local change
        } else {
          console.debug("updating the document", remoteDocument.current.id);
          const updatedDocument = await editorContext.backend.documents.update({
            id: remoteDocument.current.id,
            entry: configToSaveWithLocalisedFlag,
            version: remoteDocument.current.version
          });
          remoteDocument.current.entry = localConfigSnapshot;
          remoteDocument.current.version = updatedDocument.version;
          await runSaveCallback();
        }
      }
    }
  };

  // We're keeping this in ref, because of setInterval keeping initial closure
  onTickRef.current = onTick;
  const inProgress = useRef(false);
  const wasSaveNowCalled = useRef(false);
  useEffect(() => {
    const interval = setInterval(() => {
      // We ignore ticks when previous requests are in progress
      if (inProgress.current || wasSaveNowCalled.current) {
        return;
      }
      inProgress.current = true;
      onTickRef.current().finally(() => {
        inProgress.current = false;
      });
    }, 5000);
    return () => {
      clearInterval(interval);
    };
  }, []);
  return {
    saveNow: async () => {
      wasSaveNowCalled.current = true;

      // Wait until inProgress is false
      while (true) {
        if (inProgress.current) {
          console.debug("waiting...");
          await sleep(500);
        } else {
          break;
        }
      }
      console.debug("Last save!");
      await onTick();
    }
  };
}

const GLOBAL_SHORTCUTS_KEYS = ["Delete", "Backspace", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "l", "L"];
const DATA_TRANSFER_FORMAT = "text/x-shopstory";
function useEditorGlobalKeyboardShortcuts(editorContext) {
  useEffect(() => {
    const {
      focussedField: focusedFields,
      actions
    } = editorContext;
    function handleKeydown(event) {
      if (isTargetInputElement(event.target)) {
        return;
      }
      if (!isGlobalShortcut(event) || !isAnyFieldSelected(focusedFields)) {
        return;
      }
      if (event.key === "Delete" || event.key === "Backspace") {
        actions.removeItems(focusedFields);
      } else if (event.key === "ArrowUp" || event.key === "ArrowLeft") {
        actions.moveItems(focusedFields, "top");
      } else if (event.key === "ArrowDown" || event.key === "ArrowRight") {
        actions.moveItems(focusedFields, "bottom");
      } else if (event.key.toUpperCase() === "L") {
        actions.logSelectedItems();
      }
    }
    function handleCopy(event) {
      if (!canHandleCopyPaste(focusedFields, event)) {
        return;
      }
      const configs = getConfigsToCopy(focusedFields, editorContext);
      event.preventDefault();
      event.clipboardData?.setData(DATA_TRANSFER_FORMAT, JSON.stringify(configs));
    }
    function handleCut(event) {
      if (!canHandleCopyPaste(focusedFields, event)) {
        return;
      }
      const configs = getConfigsToCopy(focusedFields, editorContext);
      event.preventDefault();
      event.clipboardData?.setData(DATA_TRANSFER_FORMAT, JSON.stringify(configs));
      actions.removeItems(focusedFields);
    }
    function handlePaste(event) {
      if (!canHandleCopyPaste(focusedFields, event)) {
        return;
      }
      const rawData = event.clipboardData?.getData(DATA_TRANSFER_FORMAT);
      if (!rawData || rawData === "") {
        return;
      }
      try {
        const parsedData = JSON.parse(rawData);
        const data = Array.isArray(parsedData) ? parsedData : [parsedData];
        actions.pasteItems(data);
        event.preventDefault();
      } catch (e) {
        console.error(e);
        return;
      }
    }
    window.document.addEventListener("keydown", handleKeydown);
    window.document.addEventListener("copy", handleCopy);
    window.document.addEventListener("cut", handleCut);
    window.document.addEventListener("paste", handlePaste);
    return () => {
      window.document.removeEventListener("keydown", handleKeydown);
      window.document.removeEventListener("copy", handleCopy);
      window.document.removeEventListener("cut", handleCut);
      window.document.removeEventListener("paste", handlePaste);
    };
  });
}
function isTargetInputElement(target) {
  return isTargetHtmlElement(target) && (["INPUT", "TEXTAREA", "SELECT"].includes(target.tagName) || target.tagName === "DIV" && target.getAttribute("role") === "textbox");
}
function isTargetHtmlElement(element) {
  return element !== null;
}
function getConfigsToCopy(paths, editorContext) {
  const sortedPaths = [...paths].sort(preOrderPathComparator("ascending"));
  return sortedPaths.map(path => {
    const config = dotNotationGet(editorContext.form.values, path);
    return duplicateConfig(config, editorContext);
  });
}
function canHandleCopyPaste(focusedFields, event) {
  const notInsideInputElement = !(isTargetInputElement(event.target) || isTargetInputElement(document.activeElement));
  const insideEditorIFrame = window.frameElement;
  const focusedFieldsSelected = isAnyFieldSelected(focusedFields);
  return notInsideInputElement && insideEditorIFrame && focusedFieldsSelected;
}
function isGlobalShortcut(event) {
  return GLOBAL_SHORTCUTS_KEYS.includes(event.key);
}

// FIXME: This is my mistake, because I was lazy at the beginning and it was easier for me to introduce changes
// by assuming that non empty array with empty string means no fields selected.
// IMO this is stupid and can lead to confusion.
function isAnyFieldSelected(focusedFields) {
  return focusedFields.length > 0 && focusedFields[0] !== "";
}

const HISTORY_SIZE = 50;
class EditorHistory {
  constructor() {
    this.values = [];
    this.currentIndex = -1;
  }
  push(value) {
    const isCurrentIndexLastEntry = this.values.length - 1 === this.currentIndex;

    // If we push to history while `currentIndex` is not set on latest history entry
    // our history would me messed up. We need to rewrite our history by removing all
    // entries after the current index.
    if (!isCurrentIndexLastEntry) {
      this.values.splice(this.currentIndex + 1, this.values.length - 1 - this.currentIndex);
    }
    const isAboutToReachSizeLimit = this.values.length + 1 > HISTORY_SIZE;
    if (isAboutToReachSizeLimit) {
      this.values.shift();
    }
    this.values.push(value);
    this.currentIndex = this.values.length - 1;
  }
  replace(value) {
    this.values[this.currentIndex] = value;
  }
  replaceAt(oldValue, newValue) {
    const entryIndex = this.values.findIndex(value => value.config === oldValue.config);
    if (entryIndex !== -1) {
      this.values[entryIndex] = newValue;
    }
  }
  forward() {
    if (!this.canGoForward()) {
      this.currentIndex = this.values.length - 1;
      return null;
    }
    const currentEntry = this.values[this.currentIndex];
    while (this.canGoForward()) {
      this.currentIndex += 1;
      const nextEntry = this.values[this.currentIndex];
      if (!deepCompare(nextEntry.config, currentEntry.config)) {
        return nextEntry;
      }
    }
    return null;
  }
  back() {
    if (!this.canGoBack()) {
      return null;
    }
    const currentEntry = this.values[this.currentIndex];
    while (this.canGoBack()) {
      this.currentIndex -= 1;
      const previousEntry = this.values[this.currentIndex];
      if (!deepCompare(previousEntry.config, currentEntry.config)) {
        return previousEntry;
      }
    }
    return null;
  }
  getEntries() {
    return this.values.map(value => ({
      ...value
    }));
  }
  canGoForward() {
    return this.currentIndex < this.values.length - 1;
  }
  canGoBack() {
    return this.currentIndex > 0;
  }
}

function useEditorHistory(_ref) {
  let {
    onChange
  } = _ref;
  const editorHistory = useRef(new EditorHistory()).current;
  function undo() {
    ReactDOM.unstable_batchedUpdates(() => {
      const entry = editorHistory.back();
      if (entry === null) {
        return;
      }
      const {
        focussedField,
        ...rest
      } = entry;
      onChange({
        focusedField: focussedField,
        ...rest,
        type: "undo"
      });
    });
  }
  function redo() {
    ReactDOM.unstable_batchedUpdates(() => {
      const entry = editorHistory.forward();
      if (!entry) {
        return null;
      }
      const {
        focussedField,
        ...rest
      } = entry;
      onChange({
        focusedField: focussedField,
        ...rest,
        type: "redo"
      });
    });
  }
  function push(entry) {
    editorHistory.push(entry);
  }
  return {
    push,
    redo,
    undo,
    editorHistoryInstance: editorHistory
  };
}

function checkLocalesCorrectness(locales) {
  if (locales.length === 0) {
    throw new Error("Locales array can't be empty");
  }
  const defaultLocales = locales.filter(l => l.isDefault);
  if (defaultLocales.length === 0) {
    throw new Error("One locale must be set as default, you didn't set any");
  }
  if (defaultLocales.length > 1) {
    throw new Error("Only one locale must be set as default, you set more than one");
  }
  const defaultLocale = defaultLocales[0];
  if (defaultLocale.fallback) {
    throw new Error("Default locale can't have fallback");
  }

  // Check for incorrect fallbacks
  locales.forEach(locale => {
    if (locale.fallback) {
      const fallback = locales.find(x => x.code === locale.fallback);
      if (!fallback) {
        throw new Error(`Locale ${locale} has a fallback ${locale.fallback} which doesn't exist in the locales list.`);
      }
    }
    // If there is no fallback, then we treat default locale as a fallback!
  });

  // Let's check for circulars
  locales.forEach(locale => {
    const localeChain = [];
    let currentLocale = locale;
    do {
      localeChain.push(currentLocale.code);
      const fallbackId = currentLocale.fallback ?? getDefaultLocale$1(locales).code;

      // If we got to the default locale then we're fine
      if (fallbackId === getDefaultLocale$1(locales).code) {
        break;
      }

      // If fallbackId does already exists in localeChain then it means we have circular!
      if (localeChain.includes(fallbackId)) {
        throw new Error(`There is circular reference in locales: ${[...localeChain, fallbackId].join(",")}`);
      }
      currentLocale = locales.find(x => x.code === fallbackId);
    } while (true);
  });
  return true;
}

const ContentContainer = styled.div.withConfig({
  displayName: "Editor__ContentContainer",
  componentId: "sc-t95yuf-0"
})(["position:relative;flex:1 1 auto;display:flex;flex-direction:column;"]);
const SidebarAndContentContainer = styled.div.withConfig({
  displayName: "Editor__SidebarAndContentContainer",
  componentId: "sc-t95yuf-1"
})(["height:", ";width:100%;background:#fafafa;display:flex;flex-direction:row;align-items:stretch;"], props => `calc(${props.height} - ${TOP_BAR_HEIGHT}px)`);
const SidebarContainer = styled.div.withConfig({
  displayName: "Editor__SidebarContainer",
  componentId: "sc-t95yuf-2"
})(["flex:0 0 240px;background:", ";border-left:1px solid ", ";box-sizing:border-box;> *{box-sizing:border-box;}overflow-y:auto;"], Colors.white, Colors.black100);
const DataSaverRoot = styled.div.withConfig({
  displayName: "Editor__DataSaverRoot",
  componentId: "sc-t95yuf-3"
})(["position:fixed;width:100%;height:100%;z-index:100000;display:flex;justify-content:center;align-items:center;"]);
const DataSaverOverlay = styled.div.withConfig({
  displayName: "Editor__DataSaverOverlay",
  componentId: "sc-t95yuf-4"
})(["z-index:-1;position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.25);"]);
const DataSaverModal = styled.div.withConfig({
  displayName: "Editor__DataSaverModal",
  componentId: "sc-t95yuf-5"
})(["background:white;padding:32px;border-radius:8px;display:flex;justify-content:center;align-items:center;", " font-size:16px;"], Fonts.body);
const AuthenticationScreen = styled.div.withConfig({
  displayName: "Editor__AuthenticationScreen",
  componentId: "sc-t95yuf-6"
})(["width:100vw;height:100vh;display:flex;flex-direction:column;justify-content:center;align-items:center;gap:24px;text-align:center;", ""], Fonts.bodyLarge);
const Editor = EditorBackendInitializer;
function EditorBackendInitializer(props) {
  const [enabled, setEnabled] = useState(false);
  const [error, setError] = useState(undefined);
  const [document, setDocument] = useState(null);
  useEffect(() => {
    async function run() {
      try {
        if (props.documentId) {
          const document = await props.config.backend.documents.get({
            id: props.documentId
          });
          if (!document) {
            throw new Error(`Can't fetch document with id: ${props.documentId}`);
          }
          setDocument(document);
        }
      } catch (error) {
        console.error(error);
        setError(`Backend initialization error, check out console for more details.`);
        return;
      }
      setEnabled(true);
    }
    run();
  }, []);
  if (!enabled) {
    return /*#__PURE__*/React__default.createElement(AuthenticationScreen, null, "Loading...");
  }
  if (error) {
    return /*#__PURE__*/React__default.createElement(DataSaverRoot, null, /*#__PURE__*/React__default.createElement(DataSaverOverlay, null), /*#__PURE__*/React__default.createElement(DataSaverModal, null, error));
  }
  return /*#__PURE__*/React__default.createElement(EditorWrapper, _extends({}, props, {
    document: document
  }));
}
const EditorWrapper = /*#__PURE__*/memo(props => {
  if (!props.document) {
    if (props.rootTemplateId) {
      if (props.rootComponentId) {
        throw new Error("You can't pass both 'rootContainer' and 'rootTemplate' parameters to the editor");
      }
      const template = props.config.templates?.find(template => template.id === props.rootTemplateId);
      if (!template) {
        throw new Error(`The template given in "rootTemplate" ("${props.rootTemplateId}") doesn't exist in Config.templates`);
      }
    } else {
      if (props.rootComponentId === null) {
        throw new Error("When you create a new document you must pass a 'rootContainer' or 'rootTemplate' parameter to the editor");
      }
      if (!props.config.components?.find(component => component.id === props.rootComponentId)) {
        throw new Error(`The component given in rootContainer ("${props.rootComponentId}") doesn't exist in Config.components`);
      }
    }
  }

  // Locales
  if (!props.config.locales) {
    throw new Error("Required property Config.locales is empty");
  }
  checkLocalesCorrectness(props.config.locales); // very important to check locales correctness, circular references etc. Other functions
  const locale = props.locale ?? getDefaultLocale$1(props.config.locales).code;
  const rootTemplateEntry = props.rootTemplateId ? props.config.templates?.find(t => t.id === props.rootTemplateId)?.entry : null;
  const rootComponentId = props.document ? props.document.entry._component : rootTemplateEntry?._component ?? props.rootComponentId;
  const compilationContext = createCompilationContext(props.config, {
    locale
  }, rootComponentId);
  const initialEntry = props.document ? adaptRemoteConfig(props.document.entry, compilationContext) : normalize$1(rootTemplateEntry ?? {
    _id: uniqueId(),
    _component: rootComponentId
  }, compilationContext);
  return /*#__PURE__*/React__default.createElement(EditorContent, _extends({}, props, {
    compilationContext: compilationContext,
    initialDocument: props.document,
    initialEntry: initialEntry
  }));
});
function parseExternalDataId(externalDataId) {
  const [configId, fieldName, breakpointIndex] = externalDataId.split(".");
  return {
    configId,
    fieldName,
    breakpointIndex
  };
}
function useBuiltContent(editorContext, config, rawContent, externalData, onExternalDataChange) {
  const buildEntryResult = useRef();

  // cached inputs (needed to calculated "inputChanged")
  const inputRawContent = useRef();
  const inputIsEditing = useRef();
  const inputBreakpointIndex = useRef();
  const inputChanged = inputRawContent.current !== rawContent || inputIsEditing.current !== editorContext.isEditing || inputBreakpointIndex.current !== editorContext.breakpointIndex;
  if (!buildEntryResult.current || inputChanged) {
    /*
     * Why do we merge meta instead of overriding?
     * It might seem redundant. We could only take the newest meta and re-render, right?
     *
     * The problem is when we have nested Shopstory content.
     * The first call "buildSync" only compiles 1 level deep, doesn't compile deeper nested items.
     * Deeper nested items are compiled only when fetch is finished.
     *
     * Because of that, when we switch isEditing from true to false following thing will happen:
     * 1. We'll get only Metadata from 1 level compile.
     * 2. Shopstory Editor will try to re-render everything.
     * 3. It will remember old RenderableContent in the resources.
     * 4. But the metadata from old RenderableContent is not yet added.
     * 5. This will cause errors because there won't be enough definitions in the metadata.
     *
     * The solution is merging. Metadata code + definitions is growing incrementally in the editor.
     * There is no performance overhead of this operation and we might be sure that any definitions
     * that were added at any point will be available later.
     *
     */

    buildEntryResult.current = buildEntry({
      entry: rawContent,
      config,
      locale: editorContext.contextParams.locale,
      externalData,
      compiler: {
        findExternals,
        validate: validate$1,
        compile: content => {
          let resultMeta = {
            vars: {
              devices: editorContext.devices,
              locale: editorContext.contextParams.locale,
              definitions: {
                actions: [],
                components: [],
                links: [],
                textModifiers: []
              }
            }
          };
          const normalizedContent = normalizeInput(content);
          const {
            meta,
            ...rest
          } = compileInternal(normalizedContent, editorContext, editorContext.compilationCache);
          resultMeta = mergeCompilationMeta(resultMeta, meta);
          return {
            ...rest,
            meta: resultMeta
          };
        }
      },
      isExternalDataChanged(externalDataValue, defaultIsExternalDataChanged) {
        // When editing, we consider external data to be changed in more ways.
        const storedExternalData = externalData[externalDataValue.id];

        // If external data for given id is already stored, but now the external id is empty it means that the user
        // has removed that external value and thus the user of editor has to remove it from its external data.
        if (storedExternalData && externalDataValue.externalId === null) {
          return true;
        }

        // If external data for given is is already stored, but now the external id is different it means that the user
        // has changed the selected external value and thus the user of editor has to update it in its external data.
        if (storedExternalData && externalDataValue.externalId && inputRawContent.current) {
          const {
            breakpointIndex,
            configId,
            fieldName
          } = parseExternalDataId(externalDataValue.id);
          const config = findConfigById(inputRawContent.current, editorContext, configId === "$" ? inputRawContent.current._id : configId);
          if (!config) {
            return false;
          }
          const value = breakpointIndex ? responsiveValueGet$1(config[fieldName], breakpointIndex) : config[fieldName];
          const hasExternalIdChanged = value === undefined || value.id !== externalDataValue.externalId;
          return hasExternalIdChanged;
        }
        return defaultIsExternalDataChanged(externalDataValue);
      }
    });
    if (Object.keys(buildEntryResult.current.externalData).length > 0) {
      onExternalDataChange(buildEntryResult.current.externalData, editorContext.contextParams);
    }
  }
  inputRawContent.current = rawContent;
  inputIsEditing.current = editorContext.isEditing;
  inputBreakpointIndex.current = editorContext.breakpointIndex;
  return {
    renderableContent: buildEntryResult.current.renderableContent,
    configAfterAuto: buildEntryResult.current.configAfterAuto,
    meta: buildEntryResult.current.meta
  };
}
function calculateViewportRelatedStuff(viewport, devices, mainBreakpointIndex, availableSize) {
  let activeDevice;

  // Calculate active device
  if (viewport === "fit-screen") {
    if (!availableSize) {
      activeDevice = devices.find(device => device.id === mainBreakpointIndex);
    } else {
      const matchingDevice = getMatchingDevice(devices, availableSize.width);
      if (!matchingDevice) {
        throw new Error("can't find matching device");
      }
      activeDevice = matchingDevice;
    }
  } else {
    activeDevice = devices.find(device => device.id === viewport);
  }
  const activeDeviceindex = devices.findIndex(device => device.id === activeDevice.id);

  // Calculate width, height and scale
  let width, height;
  let scaleFactor = null;
  let offsetY = 0;
  if (!availableSize) {
    // lack of available size (first render) should wait until size is available to perform calculations
    width = 0;
    height = 0;
  } else {
    if (viewport === "fit-screen") {
      width = availableSize.width;
      height = availableSize.height;
    } else {
      const smallestNonScaledWidth = activeDeviceindex === 0 ? 0 : devices[activeDeviceindex - 1].breakpoint;
      width = activeDevice.w;
      height = activeDevice.h === null ? availableSize.height : Math.min(activeDevice.h, availableSize.height);
      if (activeDevice.w <= availableSize.width) ; else if (smallestNonScaledWidth <= availableSize.width) {
        // fits currently selected device range
        width = availableSize.width;
      } else {
        // we must scale
        scaleFactor = availableSize.width / activeDevice.w;
        if (activeDevice.h === null) {
          height = availableSize.height / scaleFactor;
          offsetY = (availableSize.height - height) / 2;
        }
      }
    }
  }
  return {
    breakpointIndex: activeDevice.id,
    iframeSize: {
      width,
      height,
      transform: scaleFactor === null ? "none" : `translateY(${offsetY}px) scale(${scaleFactor})`
    }
  };
}
function useRerenderOnIframeResize(iframe) {
  const {
    forceRerender
  } = useForceRerender();
  const resizeObserver = useRef(new ResizeObserver(throttle$1(() => {
    forceRerender();
  }, 100)));
  useEffect(() => {
    if (!iframe) {
      return;
    }
    resizeObserver.current.observe(iframe);
    return () => {
      resizeObserver.current.unobserve(iframe);
    };
  }, [iframe]);
}
const EditorContent = _ref => {
  let {
    compilationContext,
    heightMode = "viewport",
    initialDocument,
    initialEntry,
    externalData,
    ...props
  } = _ref;
  const [currentViewport, setCurrentViewport] = useState(compilationContext.mainBreakpointIndex); // "{ breakpoint }" or "fit-screen"

  const iframeContainerRef = useRef(null);
  const availableSize = iframeContainerRef.current ? {
    width: iframeContainerRef.current.clientWidth,
    height: iframeContainerRef.current.clientHeight
  } : undefined;
  const {
    breakpointIndex,
    iframeSize
  } = calculateViewportRelatedStuff(currentViewport, compilationContext.devices, compilationContext.mainBreakpointIndex, availableSize);
  useRerenderOnIframeResize(iframeContainerRef.current); // re-render on resize (recalculates viewport size, active breakpoint for fit-screen etc);

  const compilationCache = useRef(new CompilationCache());
  const [isEditing, setEditing] = useState(true);
  const [componentPickerData, setComponentPickerData] = useState(undefined);
  const [focussedField, setFocussedField] = useState([]);
  const handleSetFocussedField = React__default.useRef(field => {
    const nextFocusedField = Array.isArray(field) ? field : [field];
    setFocussedField(nextFocusedField);
  }).current;
  const handleSetEditing = useCallback(() => {
    compilationCache.current.clear();
    setEditing(!isEditing);
  }, [isEditing]);
  const closeComponentPickerModal = config => {
    setComponentPickerData(undefined);
    componentPickerData.promiseResolve(config);
  };
  const sidebarNodeRef = useRef(null);
  const [editableData, form] = useForm({
    id: "easyblocks-editor",
    label: "Edit entry",
    fields: [],
    initialValues: initialEntry,
    onSubmit: async () => {}
  });
  const {
    undo,
    redo,
    push
  } = useEditorHistory({
    onChange: _ref2 => {
      let {
        config,
        focusedField
      } = _ref2;
      setFocussedField(focusedField);
      form.finalForm.change("", config);
    }
  });
  const [templates, setTemplates] = useState(undefined);
  const [openTemplateModalAction, setOpenTemplateModalAction] = useState(undefined);
  const {
    notify
  } = useToaster();
  const actions = {
    openTemplateModal: setOpenTemplateModalAction,
    notify: message => {
      notify(message);
    },
    openComponentPicker: function (config) {
      return new Promise(resolve => {
        setComponentPickerData({
          promiseResolve: resolve,
          config
        });
      });
    },
    replaceItems: (paths, newConfig) => {
      actions.runChange(() => {
        replaceItems(paths, newConfig, editorContext);
      });
    },
    moveItems: (fieldNames, direction) => {
      actions.runChange(() => {
        return moveItems(form, fieldNames, direction);
      });
    },
    removeItems: fieldNames => {
      actions.runChange(() => {
        return removeItems(form, fieldNames, editorContext);
      });
    },
    insertItem: _ref3 => {
      let {
        name,
        index,
        block
      } = _ref3;
      actions.runChange(() => {
        form.mutators.insert(name, index, duplicateConfig(block, compilationContext));
        return [`${name}.${index}`];
      });
    },
    duplicateItems: fieldNames => {
      actions.runChange(() => {
        return duplicateItems(form, fieldNames, compilationContext);
      });
    },
    pasteItems: what => {
      actions.runChange(() => pasteItems({
        what,
        where: focussedField,
        resolveDestination: destinationResolver({
          form,
          context: compilationContext
        }),
        pasteCommand: pasteManager()
      }));
    },
    runChange: configChangeCallback => {
      let fieldsToFocus;

      // When multiple fields are selected, the update could probably invoke `form.change` multiple times.
      // To avoid multiple rerenders, we batch them to trigger single update.
      form.finalForm.batch(() => {
        // This shallow copy of `focussedField` array is SUPER IMPORTANT!
        // Here is why...
        //
        // We invoke `configChangeCallback`, but since we are in batch, changes made to form state won't notify
        // any listeners that there were any changes. This means `window.editorWindowAPI.onUpdate` won't be invoked.
        //
        // Next, update of `focussedField` is going to be queued up. React's heuristics will treat this update
        // as update with high priority and synchronously rerender. `EditorContent` is going to rerender with updated
        // `focussedField` state, but also with updated `editableData` because it's a result of **getter**!
        // `useEffect` that is responsible for invoking `window.editorWindowAPI.onUpdate` will receive new dependencies,
        // save them as the the latest, but it won't be immediately invoked after component have returned.
        // Then the batch ends and all form listeners are going to be notified. `EditorContent` will rerender again,
        // but `editableData` and `focussedField` are the same! `useEffect` will be invoked again, it will compare its dependencies
        // and finds that the haven't changed.
        //
        // Making a shallow copy of `focussedField` will make the second invocation of `useEffect` different from the first
        // triggered by calling `setFocussedField`.
        fieldsToFocus = configChangeCallback() ?? [...focussedField];
        push({
          config: form.values,
          focussedField: fieldsToFocus
        });
        setFocussedField(fieldsToFocus);
      });
    },
    logSelectedItems: () => {
      logItems(editorContext.form, focussedField);
    }
  };
  const [isAdminMode, setAdminMode] = useState(false);
  const syncTemplates = () => {
    getTemplates(editorContext, props.config.templates ?? []).then(newTemplates => {
      setTemplates(newTemplates);
    });
  };
  useEffect(() => {
    syncTemplates();
  }, [props.config.components, props.config.templates]);
  const editorTypes = Object.fromEntries(Object.entries(compilationContext.types).map(_ref4 => {
    let [typeName, typeDefinition] = _ref4;
    return [typeName, {
      ...typeDefinition,
      ...(typeDefinition.type === "external" ? {
        widgets: typeDefinition.widgets.map(w => {
          return {
            ...w,
            component: props.widgets?.[w.id]
          };
        })
      } : typeDefinition.widget ? {
        widget: {
          ...typeDefinition.widget,
          component: props.widgets?.[typeDefinition.widget.id]
        }
      } : {})
    }];
  }));
  const editorContext = {
    ...compilationContext,
    backend: props.config.backend,
    types: editorTypes,
    isAdminMode,
    templates,
    syncTemplates,
    breakpointIndex,
    focussedField,
    form,
    setFocussedField: handleSetFocussedField,
    isEditing,
    actions,
    save: async documentData => {
      window.postMessage({
        type: "@easyblocks/content-saved",
        document: documentData
      });
    },
    compilationCache: compilationCache.current,
    readOnly: props.readOnly,
    disableCustomTemplates: props.config.disableCustomTemplates ?? false,
    rootComponent: findComponentDefinitionById(initialEntry._component, compilationContext),
    components: props.components ?? {}
  };
  const {
    configAfterAuto,
    renderableContent,
    meta
  } = useBuiltContent(editorContext, props.config, editableData, externalData, props.onExternalDataChange);
  editorContext.compiledComponentConfig = renderableContent;
  editorContext.configAfterAuto = configAfterAuto;
  console.debug("editable data", editableData);
  console.debug("focused field", focussedField);
  console.debug("meta", meta);
  console.debug("compiled config", {
    configAfterAuto,
    renderableContent
  });
  console.debug("external data", externalData);
  window.editorWindowAPI = window.editorWindowAPI || {};
  window.editorWindowAPI.editorContext = editorContext;
  window.editorWindowAPI.meta = meta;
  window.editorWindowAPI.compiled = renderableContent;
  window.editorWindowAPI.externalData = externalData;
  useEffect(() => {
    push({
      config: initialEntry,
      focussedField: []
    });
  }, []);
  useEffect(() => {
    if (window.editorWindowAPI?.onUpdate) {
      window.editorWindowAPI.onUpdate();
    }
  }, [renderableContent, focussedField, isEditing, currentViewport, externalData]);
  useEffect(() => {
    function handleEditorEvents(event) {
      if (event.data.type === "@easyblocks-editor/component-picker-opened") {
        actions.openComponentPicker({
          path: event.data.payload.path
        }).then(config => {
          const shopstoryCanvasIframe = window.document.getElementById("shopstory-canvas");
          shopstoryCanvasIframe?.contentWindow?.postMessage(componentPickerClosed(config));
        });
      }
      if (event.data.type === "@easyblocks-editor/item-inserted") {
        actions.insertItem(event.data.payload);
      }
      if (event.data.type === "@easyblocks-editor/item-moved") {
        const {
          fromPath,
          toPath,
          placement
        } = event.data.payload;
        const fromPathParseResult = parsePath(fromPath, editorContext.form);
        const toPathParseResult = parsePath(toPath, editorContext.form);
        if (!fromPathParseResult.parent || !toPathParseResult.parent || fromPathParseResult.index === undefined || toPathParseResult === undefined) {
          return;
        }
        if (fromPathParseResult.parent.path === toPathParseResult.parent.path) {
          const pathToMove = `${fromPathParseResult.parent.path ? fromPathParseResult.parent.path + "." : ""}${fromPathParseResult.parent.fieldName}`;
          actions.runChange(() => {
            form.mutators.move(pathToMove, fromPathParseResult.index, toPathParseResult.index);
            return [toPath];
          });
        } else {
          // TODO: We should reuse logic of pasting items here, but we need to handle the case of pasting into placeholder (empty array)
          const isToPathPlaceholder = toPathParseResult.fieldName !== undefined;
          const insertionPath = `${toPathParseResult.parent.path === "" ? "" : toPathParseResult.parent.path + "."}${toPathParseResult.parent.fieldName}${isToPathPlaceholder ? `.${toPathParseResult.index}.${toPathParseResult.fieldName}` : ""}`;
          actions.runChange(() => {
            const newConfig = duplicateConfig(dotNotationGet(form.values, fromPath), editorContext);
            const insertionIndex = calculateInsertionIndex(fromPath, toPath, placement, form);
            form.mutators.insert(insertionPath, insertionIndex, newConfig);
            actions.removeItems([fromPath]);
            return [isToPathPlaceholder ? `${insertionPath}.0` : `${insertionPath}.${insertionIndex}`];
          });
        }
      }
    }
    window.addEventListener("message", handleEditorEvents);
    return () => window.removeEventListener("message", handleEditorEvents);
  }, []);
  const [isDataSaverOverlayOpen, setDataSaverOverlayOpen] = useState(false);
  useEditorGlobalKeyboardShortcuts(editorContext);
  const {
    saveNow
  } = useDataSaver(initialDocument, editorContext);
  const appHeight = heightMode === "viewport" ? "100vh" : "100%";
  useEffect(() => {
    Modal$1.setAppElement("#shopstory-app");
  }, []);
  return /*#__PURE__*/React__default.createElement("div", {
    id: "shopstory-app",
    style: {
      height: appHeight,
      overflow: "hidden"
    }
  }, isDataSaverOverlayOpen && /*#__PURE__*/React__default.createElement(DataSaverRoot, null, /*#__PURE__*/React__default.createElement(DataSaverOverlay, null), /*#__PURE__*/React__default.createElement(DataSaverModal, null, "Saving data, please do not close the window...")), /*#__PURE__*/React__default.createElement(EditorContext$1.Provider, {
    value: editorContext
  }, /*#__PURE__*/React__default.createElement(ConfigAfterAutoContext.Provider, {
    value: configAfterAuto
  }, /*#__PURE__*/React__default.createElement(EditorExternalDataProvider, {
    externalData: externalData
  }, /*#__PURE__*/React__default.createElement("div", {
    id: "rootContainer"
  }), /*#__PURE__*/React__default.createElement(EditorTopBar, {
    onUndo: undo,
    onRedo: redo,
    onClose: () => {
      setDataSaverOverlayOpen(true);
      saveNow().finally(() => {
        setDataSaverOverlayOpen(false);
        window.postMessage({
          type: "@easyblocks/closed"
        }, "*");
        if (props.onClose) {
          props.onClose();
        }
      });
    },
    devices: compilationContext.devices,
    viewport: currentViewport,
    onViewportChange: setCurrentViewport,
    onIsEditingChange: handleSetEditing,
    isEditing: isEditing,
    saveLabel: "Save",
    locale: compilationContext.contextParams.locale,
    locales: editorContext.locales,
    onLocaleChange: () => {},
    onAdminModeChange: val => {
      setAdminMode(val);
    },
    hideCloseButton: props.config.hideCloseButton ?? false,
    readOnly: editorContext.readOnly
  }), /*#__PURE__*/React__default.createElement(SidebarAndContentContainer, {
    height: appHeight
  }, /*#__PURE__*/React__default.createElement(ContentContainer, {
    onClick: () => {
      setFocussedField([]);
    }
  }, /*#__PURE__*/React__default.createElement(EditorIframe, {
    onEditorHistoryUndo: undo,
    onEditorHistoryRedo: redo,
    width: iframeSize.width,
    height: iframeSize.height,
    transform: iframeSize.transform,
    containerRef: iframeContainerRef
  }), isEditing && /*#__PURE__*/React__default.createElement(SelectionFrame, {
    width: iframeSize.width,
    height: iframeSize.height,
    transform: iframeSize.transform
  })), isEditing && /*#__PURE__*/React__default.createElement(SidebarContainer, {
    ref: sidebarNodeRef
  }, /*#__PURE__*/React__default.createElement(EditorSidebar, {
    focussedField: focussedField,
    form: form
  })), componentPickerData && /*#__PURE__*/React__default.createElement(ModalPicker, {
    onClose: closeComponentPickerModal,
    config: componentPickerData.config,
    pickers: props.pickers
  })), openTemplateModalAction && /*#__PURE__*/React__default.createElement(TemplateModal, {
    action: openTemplateModalAction,
    onClose: () => {
      setOpenTemplateModalAction(undefined);
    },
    backend: editorContext.backend
  })))));
};
function adaptRemoteConfig(config, compilationContext) {
  const withoutLocalizedFlag = removeLocalizedFlag(config, compilationContext);
  const normalized = normalize$1(withoutLocalizedFlag, compilationContext);
  return normalized;
}
function calculateInsertionIndex(fromPath, toPath, placement, form) {
  const mostCommonPath = getMostCommonSubPath(fromPath, toPath);
  const mostCommonPathParseResult = parsePath(mostCommonPath ?? "", form);
  const toPathParseResult = parsePath(toPath, form);
  const toPathNoCodeEntry = dotNotationGet(form.values, toPath);
  if (toPathNoCodeEntry.length === 0) {
    return 0;
  }

  // If there is no index in common path, it means that we're moving items between two sections
  if (mostCommonPathParseResult.index === undefined) {
    const fromPathRootSectionIndex = +fromPath.split(".")[1];
    const toPathRootSectionIndex = +toPath.split(".")[1];
    if (fromPathRootSectionIndex > toPathRootSectionIndex) {
      if (placement) {
        if (placement === "before") {
          return toPathParseResult.index;
        }
        return toPathParseResult.index + 1;
      }
      return toPathParseResult.index;
    }
    if (placement) {
      if (placement === "before") {
        return toPathParseResult.index;
      }
      return toPathParseResult.index + 1;
    }
    return toPathParseResult.index + 1;
  }
  return toPathParseResult.index + 1;
}
function getMostCommonSubPath(path1, path2) {
  const fromPathParts = path1.split(".");
  const toPathParts = path2.split(".");
  let mostCommonPathParts = undefined;
  for (let i = 0; i < Math.min(fromPathParts.length, toPathParts.length); i++) {
    const currentFromPathPart = fromPathParts[i];
    const currentToPathPart = toPathParts[i];
    if (currentFromPathPart !== currentToPathPart) {
      break;
    }
    if (!mostCommonPathParts) {
      mostCommonPathParts = [currentFromPathPart];
      continue;
    }
    mostCommonPathParts.push(currentFromPathPart);
  }
  return mostCommonPathParts?.join(".");
}
function findConfigById(config, context, configId) {
  let foundConfig;
  traverseComponents(config, context, _ref5 => {
    let {
      componentConfig
    } = _ref5;
    if (foundConfig) {
      return;
    }
    if (componentConfig._id === configId) {
      foundConfig = componentConfig;
    }
  });
  return foundConfig;
}
function getMatchingDevice(devices, width) {
  const highestDevice = devices.find(d => d.breakpoint === null);
  const visibleDevices = devices.filter(d => !d.hidden && d.breakpoint !== null);
  for (let i = 0; i < visibleDevices.length; i++) {
    const currentDevice = visibleDevices[i];
    if (currentDevice.breakpoint > width) {
      return currentDevice;
    }
  }
  if (highestDevice) {
    return highestDevice;
  }
  return null;
}

/**
 * This is a copy of validate-color function from validate-color npm package. This package has problem with bundling, so I copied it here. It was modified 100 years ago anyway and had 32 stars, so nothing fancy really.
 */

// Good article on HTML Colors:
// https://dev.to/alvaromontoro/the-ultimate-guide-to-css-colors-2020-edition-1bh1#hsl

// Check if parameter is defined and a string
const isString = color => color && typeof color === "string";
// All existing HTML color names
const htmlColorNames = ["AliceBlue", "AntiqueWhite", "Aqua", "Aquamarine", "Azure", "Beige", "Bisque", "Black", "BlanchedAlmond", "Blue", "BlueViolet", "Brown", "BurlyWood", "CadetBlue", "Chartreuse", "Chocolate", "Coral", "CornflowerBlue", "Cornsilk", "Crimson", "Cyan", "DarkBlue", "DarkCyan", "DarkGoldenrod", "DarkGray", "DarkGreen", "DarkKhaki", "DarkMagenta", "DarkOliveGreen", "DarkOrange", "DarkOrchid", "DarkRed", "DarkSalmon", "DarkSeaGreen", "DarkSlateBlue", "DarkSlateGray", "DarkTurquoise", "DarkViolet", "DeepPink", "DeepSkyBlue", "DimGray", "DodgerBlue", "FireBrick", "FloralWhite", "ForestGreen", "Fuchsia", "Gainsboro", "GhostWhite", "Gold", "Goldenrod", "Gray", "Green", "GreenYellow", "HoneyDew", "HotPink", "IndianRed", "Indigo", "Ivory", "Khaki", "Lavender", "LavenderBlush", "LawnGreen", "LemonChiffon", "LightBlue", "LightCoral", "LightCyan", "LightGoldenrodYellow", "LightGray", "LightGreen", "LightPink", "LightSalmon", "LightSalmon", "LightSeaGreen", "LightSkyBlue", "LightSlateGray", "LightSteelBlue", "LightYellow", "Lime", "LimeGreen", "Linen", "Magenta", "Maroon", "MediumAquamarine", "MediumBlue", "MediumOrchid", "MediumPurple", "MediumSeaGreen", "MediumSlateBlue", "MediumSlateBlue", "MediumSpringGreen", "MediumTurquoise", "MediumVioletRed", "MidnightBlue", "MintCream", "MistyRose", "Moccasin", "NavajoWhite", "Navy", "OldLace", "Olive", "OliveDrab", "Orange", "OrangeRed", "Orchid", "PaleGoldenrod", "PaleGreen", "PaleTurquoise", "PaleVioletRed", "PapayaWhip", "PeachPuff", "Peru", "Pink", "Plum", "PowderBlue", "Purple", "RebeccaPurple", "Red", "RosyBrown", "RoyalBlue", "SaddleBrown", "Salmon", "SandyBrown", "SeaGreen", "SeaShell", "Sienna", "Silver", "SkyBlue", "SlateBlue", "SlateGray", "Snow", "SpringGreen", "SteelBlue", "Tan", "Teal", "Thistle", "Tomato", "Turquoise", "Violet", "Wheat", "White", "WhiteSmoke", "Yellow", "YellowGreen"];
// These 3 values are valid, usable color names, which are special in their own way
const htmlColorNamesSpecial = ["currentColor", "inherit", "transparent"];

// Validate HTML color name (red, yellow, etc)
const validateHTMLColorName = color => {
  let status = false;
  if (isString(color)) {
    htmlColorNames.map(c => {
      if (color.toLowerCase() === c.toLowerCase()) {
        status = true;
      }
      return null;
    });
  }
  return status;
};

// Validate HTML color special name (currentColor, inherit, etc)
const validateHTMLColorSpecialName = color => {
  let status = false;
  if (isString(color)) {
    htmlColorNamesSpecial.map(c => {
      if (color.toLowerCase() === c.toLowerCase()) {
        status = true;
      }
      return null;
    });
  }
  return status;
};

// Validate HTML color 'hex'
const validateHTMLColorHex = color => {
  if (isString(color)) {
    const regex = /^#([\da-f]{3}){1,2}$|^#([\da-f]{4}){1,2}$/i;
    return !!color && regex.test(color);
  }
  return false;
};

// Validate HTML color 'rgb'
// -- legacy notation
// color: rgb(255, 255, 255);
// color: rgba(255, 255, 255, 1);
// -- new notation
// color: rgb(255 255 255);
// color: rgb(255 255 255 / 1);
// Note that 'rgba()' is now merged into 'rgb()'
const validateHTMLColorRgb = color => {
  if (isString(color)) {
    const regex = /(rgb)a?\((\s*\d+%?\s*?,?\s*){2}(\s*\d+%?\s*?,?\s*\)?)(\s*,?\s*\/?\s*(0?\.?\d+%?\s*)?|1|0)?\)$/i;
    return !!color && regex.test(color);
  }
  return false;
};
const optionalCommaOrRequiredSpace = `((\\s*,\\s*)|(\\s+))`;
const optionalDecimals = `(\\.\\d+)?`;
const anyPercentage = `((\\d*${optionalDecimals})%)`;
const hundredPercent = `(([0-9]|[1-9][0-9]|100)%)`;
const alphaPercentage = `(((${hundredPercent}))|(0?${optionalDecimals})|1))?`;
const endingWithAlphaPercentage = `\\s*?\\)?)(\\s*?(\\/?)\\s+${alphaPercentage}\\s*?\\)$`;

// Validate HTML color 'hsl'
// -- These units are valid for the first parameter
// 'deg': degrees | full circle = 360
// 'gra': gradians | full circle = 400
// 'radians': radians | full circle = 2π (approx. 6.28)
// 'turn': turns | full circle = 1
const validateHTMLColorHsl = color => {
  if (isString(color)) {
    // Validate each possible unit value separately, as their values differ
    const degRegex = `(-?([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9]|3[0-5][0-9]|360)(deg)?)`;
    const graRegex = `(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9]|3[0-9][0-9]|400)gra)`;
    const radRegex = `((([0-5])?\\.\\d+|6\\.([0-9]|1[0-9]|2[0-8])|[0-6])rad)`;
    const turnRegex = `((0?${optionalDecimals}|1)turn)`;
    const regexLogic = `(hsl)a?\\((\\s*?(${degRegex}|${graRegex}|${radRegex}|${turnRegex})${optionalCommaOrRequiredSpace})(\\s*?(0|${hundredPercent})${optionalCommaOrRequiredSpace})(\\s*?(0|${hundredPercent})\\s*?\\)?)(\\s*?(\\/?|,?)\\s*?(((${hundredPercent}))|(0?${optionalDecimals})|1))?\\)$`;
    const regex = new RegExp(regexLogic);
    return !!color && regex.test(color);
  }
  return false;
};

// Validate HTML color 'hwb'
// -- 'hwb' accepts 'deg' as unit in its 1st property, which stands for 'hue'
// 'deg': degrees | full circle = 360
const validateHTMLColorHwb = color => {
  if (isString(color)) {
    const degRegex = `(-?([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9]|3[0-5][0-9]|360)(deg)?)`;
    const regexLogic = `(hwb\\(\\s*?${degRegex}\\s+)((0|${hundredPercent})\\s+)((0|${hundredPercent})${endingWithAlphaPercentage}`;
    const regex = new RegExp(regexLogic);
    return !!color && regex.test(color);
  }
  return false;
};

// Validate HTML color 'lab'
// -- 'lab' 2nd & 3rd parameters are any number between -160 & 160
const validateHTMLColorLab = color => {
  if (isString(color)) {
    const labParam = `(-?(([0-9]|[1-9][0-9]|1[0-5][0-9])${optionalDecimals}?|160))`;
    const regexLogic = `(lab\\(\\s*?${anyPercentage}\\s+${labParam}\\s+${labParam}${endingWithAlphaPercentage}`;
    const regex = new RegExp(regexLogic);
    return !!color && regex.test(color);
  }
  return false;
};
const validateColor = color => {
  // Former validation - source: https://www.regextester.com/103656
  // if (isString(color)) {
  //   const regex = /^#([\da-f]{3}){1,2}$|^#([\da-f]{4}){1,2}$|(rgb|hsl)a?\((\s*-?\d+%?\s*,){2}(\s*-?\d+%?\s*,?\s*\)?)(,\s*(0?\.\d+)?|1|0)?\)$/i;
  //   return color && regex.test(color);
  // }
  // New validation
  if (color && validateHTMLColorHex(color) || validateHTMLColorName(color) || validateHTMLColorSpecialName(color) || validateHTMLColorRgb(color) || validateHTMLColorHsl(color) || validateHTMLColorHwb(color) || validateHTMLColorLab(color)) {
    return true;
  }
  return false;
};

function ColorTokenWidget(props) {
  const [inputValue, setInputValue] = useState(props.value);
  return /*#__PURE__*/React__default.createElement(Input, {
    value: inputValue,
    onChange: e => {
      setInputValue(e.target.value);
    },
    onBlur: () => {
      if (validateColor(inputValue)) {
        props.onChange(inputValue);
        return;
      }
      if (validateColor("#" + inputValue)) {
        props.onChange("#" + inputValue);
        return;
      }
      props.onChange(props.value);
    },
    align: "right"
  });
}

function SpaceTokenWidget(props) {
  const [inputValue, setInputValue] = useState(props.value);
  return /*#__PURE__*/React__default.createElement(Input, {
    value: inputValue,
    onChange: e => {
      setInputValue(e.target.value);
    },
    onBlur: () => {
      const int = Math.round(parseInt(inputValue));
      if (isNaN(int) || int < 0) {
        props.onChange("0px");
        return;
      }
      props.onChange(`${int}px`);
    },
    align: "right"
  });
}

function parseQueryParams() {
  const searchParams = new URLSearchParams(window.location.search);
  const readOnly = searchParams.get("readOnly") === "true" ? true : searchParams.get("readOnly") === "false" ? false : null;
  const documentId = searchParams.get("document");
  const templateId = searchParams.get("template");
  const rootComponentId = searchParams.get("rootComponent");
  const rootTemplateId = searchParams.get("rootTemplate");
  const locale = searchParams.get("locale");
  const debug = searchParams.get("debug") === "true";
  const preview = searchParams.get("preview") === "true";
  const editorSearchParams = {
    readOnly,
    documentId,
    templateId,
    rootComponentId,
    rootTemplateId,
    locale,
    preview,
    debug
  };
  return editorSearchParams;
}

function DocumentDataWidgetComponent(_ref) {
  let {
    id,
    onChange,
    resourceKey,
    path
  } = _ref;
  if (id !== null && typeof id !== "string") {
    return /*#__PURE__*/React__default.createElement(Typography, {
      style: {
        whiteSpace: "normal"
      }
    }, "Unsupported type of identifier for document data widget. Expected \"string\", but got \"", typeof id, "\".");
  }
  const {
    editorContext,
    externalData
  } = window.editorWindowAPI ?? {};
  const schema = editorContext.rootComponent.rootParams;
  const documentExternalLocationKeys = assertDefined(schema).map(s => getExternalReferenceLocationKey$1("$", s.prop));
  const documentCompoundResources = Object.entries(externalData).filter(r => {
    const [externalId, externalDataValue] = r;
    return documentExternalLocationKeys.includes(externalId) && isResolvedCompoundExternalDataValue(externalDataValue);
  });
  const entry = dotNotationGet(editorContext.form.values, path.slice(0, path.lastIndexOf(".")));
  const definition = findComponentDefinitionById(entry._component, editorContext);
  const schemaProp = definition.schema.find(s => s.prop === path.split(".").pop());
  const options = documentCompoundResources.flatMap(_ref2 => {
    let [externalId, externalDataValue] = _ref2;
    return getBasicResourcesOfType(externalDataValue.value, schemaProp.type).map(r => {
      const resourceSchemaProp = assertDefined(schema?.find(s => s.prop === externalId.split(".")[1]));
      return {
        id: externalId,
        key: r.key,
        label: `${resourceSchemaProp.label ?? resourceSchemaProp.prop} > ${r.label ?? r.key}`
      };
    });
  });
  if (options.length === 1 && !id && path) {
    // We perform form change manually to avoid storing this change in editor's history
    editorContext.form.change(path, {
      id: options[0].id,
      key: options[0].key,
      widgetId: "@easyblocks/document-data"
    });
  }
  if (!documentCompoundResources.length) {
    return /*#__PURE__*/React__default.createElement(Typography, {
      style: {
        whiteSpace: "normal"
      }
    }, "Please select at least one non optional external data for document.");
  }
  return /*#__PURE__*/React__default.createElement(CompoundResourceValueSelect, {
    options: options,
    resource: id === null ? {
      id,
      key: undefined
    } : {
      id,
      key: resourceKey
    },
    onResourceKeyChange: (newId, newKey) => {
      onChange(newId, newKey);
    }
  });
}

/**
 * CARD
 */

const CardRoot = styled.div.withConfig({
  displayName: "SectionPicker__CardRoot",
  componentId: "sc-5szert-0"
})(["&:hover{outline:1px solid ", ";outline-offset:8px;}.editButton{opacity:0;}&:hover{.editButton{opacity:1;}}"], Colors.black10);
const ImageContainer = styled.div.withConfig({
  displayName: "SectionPicker__ImageContainer",
  componentId: "sc-5szert-1"
})(["position:relative;background-color:", ";margin-bottom:8px;padding-bottom:", ";cursor:pointer;"], Colors.black10, p => p.mode === "large-3" ? "90%" : "60%");
const CardImg = styled.img.withConfig({
  displayName: "SectionPicker__CardImg",
  componentId: "sc-5szert-2"
})(["position:absolute;top:0;left:0;width:100%;height:100%;object-fit:contain;padding:24px;box-sizing:border-box;"]);
const CardImgPlaceholder = styled.div.withConfig({
  displayName: "SectionPicker__CardImgPlaceholder",
  componentId: "sc-5szert-3"
})(["position:absolute;top:0;left:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;"]);
const CardFooter = styled.div.withConfig({
  displayName: "SectionPicker__CardFooter",
  componentId: "sc-5szert-4"
})(["display:flex;flex-direction:row;justify-content:space-between;align-items:center;margin-top:8px;"]);
const CardLabelContainer = styled.div.withConfig({
  displayName: "SectionPicker__CardLabelContainer",
  componentId: "sc-5szert-5"
})(["display:flex;flex-direction:row;align-items:center;"]);
const CardLabelTemplateName = styled.div.withConfig({
  displayName: "SectionPicker__CardLabelTemplateName",
  componentId: "sc-5szert-6"
})(["", ";color:black;"], Fonts.body);
const Title = styled.div.withConfig({
  displayName: "SectionPicker__Title",
  componentId: "sc-5szert-7"
})(["", ""], Fonts.label);
const TitleContainer = styled.div.withConfig({
  displayName: "SectionPicker__TitleContainer",
  componentId: "sc-5szert-8"
})(["display:flex;flex-direction:row;gap:8px;align-items:center;margin-bottom:24px;"]);
const Message = styled.div.withConfig({
  displayName: "SectionPicker__Message",
  componentId: "sc-5szert-9"
})(["padding-top:32px;", ";"], Fonts.body);
function getTemplatePreviewImage(template, editorContext) {
  // template.previewImage is always most important and overrides other sources of preview
  if (template.thumbnail) {
    return template.thumbnail;
  }
  return;

  // if (template.configId) {
  //   return getComponentConfigPreviewImageURL({
  //     configId: template.configId,
  //     contextParams: editorContext.contextParams,
  //     locales: editorContext.locales,
  //     project: editorContext.project,
  //   });
  // }
}
const SectionCard = _ref => {
  let {
    template,
    onSelect,
    mode
  } = _ref;
  const imageRef = useRef(null);
  const editorContext = useEditorContext();
  const previewImage = getTemplatePreviewImage(template);
  return /*#__PURE__*/React__default.createElement(CardRoot, null, /*#__PURE__*/React__default.createElement(ImageContainer, {
    ref: imageRef,
    onClick: onSelect,
    mode: mode
  }, previewImage && /*#__PURE__*/React__default.createElement(CardImg, {
    src: previewImage
  }), !previewImage && template.thumbnailLabel && /*#__PURE__*/React__default.createElement(CardImgPlaceholder, null, /*#__PURE__*/React__default.createElement("span", {
    style: {
      color: "#6c6c6c"
    }
  }, template.thumbnailLabel)), !previewImage && !template.thumbnailLabel && /*#__PURE__*/React__default.createElement(CardImgPlaceholder, null, /*#__PURE__*/React__default.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "64",
    height: "64",
    viewBox: "0 0 16 16",
    fill: "none"
  }, /*#__PURE__*/React__default.createElement("path", {
    d: "M8.18102 5.39789L6.89683 10.3512L7.86482 10.6022L9.14901 5.64885L8.18102 5.39789Z",
    fill: Colors.black20
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M9.38171 6.1215L11.1837 7.92352L9.38172 9.72549L10.0888 10.4326L12.5979 7.92353L10.0888 5.4144L9.38171 6.1215Z",
    fill: Colors.black20
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M6.54828 6.11507L4.80393 7.92352L6.54828 9.73192L5.82854 10.4262L3.41455 7.92353L5.82853 5.42083L6.54828 6.11507Z",
    fill: Colors.black20
  }), /*#__PURE__*/React__default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M2 3C2 2.44772 2.44772 2 3 2H13C13.5523 2 14 2.44772 14 3V13C14 13.5523 13.5523 14 13 14H3C2.44772 14 2 13.5523 2 13V3ZM3 3H13V13H3L3 3Z",
    fill: Colors.black20
  })))), /*#__PURE__*/React__default.createElement(CardFooter, null, /*#__PURE__*/React__default.createElement(CardLabelContainer, null, /*#__PURE__*/React__default.createElement(React__default.Fragment, null, template.label && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(CardLabelTemplateName, null, template.label)))), /*#__PURE__*/React__default.createElement("div", null), template.isUserDefined && !editorContext.readOnly && /*#__PURE__*/React__default.createElement(ButtonGhostColor, {
    className: "editButton",
    onClick: () => {
      editorContext.actions.openTemplateModal({
        mode: "edit",
        template: template
      });
    }
  }, "Edit")));
};

/**
 * MODAL
 */

const ModalRoot = styled.div.withConfig({
  displayName: "SectionPicker__ModalRoot",
  componentId: "sc-5szert-10"
})(["position:absolute;top:0;left:0;width:100%;height:100%;display:grid;grid-template-columns:200px 1fr;"]);
const ModalGridRoot = styled.div.withConfig({
  displayName: "SectionPicker__ModalGridRoot",
  componentId: "sc-5szert-11"
})(["display:grid;grid-template-columns:", ";grid-column-gap:16px;grid-row-gap:30px;"], p => p.mode === "large-3" ? "1fr 1fr 1fr" : "1fr 1fr");
const Sidebar = styled.div.withConfig({
  displayName: "SectionPicker__Sidebar",
  componentId: "sc-5szert-12"
})(["overflow-y:hidden;overflow-x:hidden;border-right:1px solid ", ";height:100%;"], Colors.black5);
const SidebarContent = styled.div.withConfig({
  displayName: "SectionPicker__SidebarContent",
  componentId: "sc-5szert-13"
})(["padding:24px 4px;display:flex;flex-direction:column;gap:8px;"]);
const SidebarButton = styled.button.withConfig({
  displayName: "SectionPicker__SidebarButton",
  componentId: "sc-5szert-14"
})(["all:unset;height:38px;", " display:flex;padding-left:16px;align-items:center;&:hover{background:", ";}cursor:pointer;"], Fonts.body, Colors.black5);
const GridRoot = styled.div.withConfig({
  displayName: "SectionPicker__GridRoot",
  componentId: "sc-5szert-15"
})(["padding:0px 16px;height:100%;overflow-x:hidden;overflow-y:auto;"]);
const SectionPickerModal = _ref2 => {
  let {
    isOpen,
    onClose,
    templates,
    mode = "large"
  } = _ref2;
  const templateGroups = templates;
  const gridRootRef = useRef(null);
  const templateSelected = template => {
    if (onClose) {
      onClose(template);
    }
  };
  return /*#__PURE__*/React__default.createElement(Modal, {
    noPadding: true,
    title: "Pick section",
    isOpen: isOpen,
    onRequestClose: () => {
      if (onClose) {
        onClose();
      }
    },
    mode: "center-huge",
    headerLine: true
  }, /*#__PURE__*/React__default.createElement(ModalRoot, null, /*#__PURE__*/React__default.createElement(Sidebar, null, templateGroups && /*#__PURE__*/React__default.createElement(SidebarContent, null, Object.entries(templateGroups).map(_ref3 => {
    let [componentId, {
      component: {
        label
      }
    }] = _ref3;
    return /*#__PURE__*/React__default.createElement(SidebarButton, {
      key: `sectionPicker__group__${componentId}`,
      onClick: () => {
        const groupNode = document.getElementById(`sectionPicker__group__${componentId}`);
        const groupOffsetTop = groupNode.offsetTop;
        gridRootRef.current.scrollTo({
          top: groupOffsetTop,
          behavior: "smooth"
        });
      }
    }, label ?? componentId);
  }))), /*#__PURE__*/React__default.createElement(GridRoot, {
    ref: gridRootRef
  }, templates === undefined && /*#__PURE__*/React__default.createElement(Message, null, "Loading..."), templateGroups && Object.entries(templateGroups).map((_ref4, index) => {
    let [componentId, {
      component: {
        label
      },
      templates
    }] = _ref4;
    return /*#__PURE__*/React__default.createElement("div", {
      style: {
        paddingTop: "32px",
        paddingBottom: "32px"
      },
      id: `sectionPicker__group__${componentId}`,
      key: `sectionPicker__group__${componentId}`
    }, /*#__PURE__*/React__default.createElement(TitleContainer, null, /*#__PURE__*/React__default.createElement(Title, null, label ?? componentId)), /*#__PURE__*/React__default.createElement(ModalGridRoot, {
      mode: mode
    }, templates.map((template, index) => /*#__PURE__*/React__default.createElement(SectionCard, {
      key: index,
      template: template,
      onSelect: () => {
        templateSelected(template);
      },
      mode: mode
    }))));
  }))));
};

function checkQueryForTemplate(query, template, component) {
  return `${template.label ?? ""}${component.label ?? component.id}`.toLocaleLowerCase().includes(query.trim().toLocaleLowerCase());
}
const SearchableSmallPickerModal = _ref => {
  let {
    onClose,
    templates,
    isOpen
  } = _ref;
  const editorContext = useEditorContext();
  const templatesDict = templates;
  const [query, setQuery] = useState("");
  const trimmedQuery = query.trim().toLocaleLowerCase();
  const filteredTemplatesDict = {};
  if (templatesDict) {
    Object.values(templatesDict).forEach(_ref2 => {
      let {
        templates,
        component
      } = _ref2;
      const filteredTemplates = trimmedQuery === "" ? templates : templates.filter(template => checkQueryForTemplate(trimmedQuery, template, component));
      if (filteredTemplates.length > 0) {
        filteredTemplatesDict[component.id] = {
          component,
          templates: filteredTemplates
        };
      }
    });
  }
  const close = template => {
    setQuery("");
    if (!template) {
      onClose();
    } else {
      // @ts-expect-error
      onClose(template);
    }
  };
  return /*#__PURE__*/React__default.createElement(Modal, {
    mode: "center-small",
    isOpen: isOpen,
    onRequestClose: () => {
      close(undefined);
    },
    noPadding: true,
    headerLine: true,
    searchProps: {
      value: query,
      placeholder: "Search...",
      onChange: e => {
        setQuery(e.target.value);
      }
    },
    headerSymbol: "S"
  }, templatesDict === undefined && "Loading...", templatesDict !== undefined && Object.entries(filteredTemplatesDict).map(_ref3 => {
    let [, {
      templates,
      component
    }] = _ref3;
    const isOnlyOne = templates.length === 1;
    const componentLabel = component.label ?? component.id;
    return templates.map(template => {
      const templateLabel = template.label ?? template.id;
      const title = isOnlyOne ? componentLabel : templateLabel;
      const thumbnail = template.thumbnail ?? component.thumbnail;
      const description = isOnlyOne ? undefined : componentLabel;
      return /*#__PURE__*/React__default.createElement(BasicRow, {
        key: template.id,
        title: title,
        description: description,
        onClick: () => {
          close(template);
        },
        image: thumbnail,
        tinyDescription: true,
        onEdit: template.isUserDefined ? () => {
          editorContext.actions.openTemplateModal({
            mode: "edit",
            template: template
          });
        } : undefined
      });
    });
  }));
};

const shouldForwardProp = (propName, target) => {
  if (typeof target === "string") {
    // For HTML elements, forward the prop if it is a valid HTML attribute
    return isPropValid(propName);
  }
  // For other elements, forward all props
  return true;
};
const builtinWidgets = {
  color: ColorTokenWidget,
  space: SpaceTokenWidget,
  "@easyblocks/document-data": DocumentDataWidgetComponent
};
const builinPickers = {
  large: SectionPickerModal,
  compact: SearchableSmallPickerModal,
  "large-3": SectionPickerModal
};
function EasyblocksParent(props) {
  const editorSearchParams = parseQueryParams();
  return /*#__PURE__*/React__default.createElement(StyleSheetManager, {
    shouldForwardProp: shouldForwardProp,
    enableVendorPrefixes: true
  }, /*#__PURE__*/React__default.createElement(ModalContext.Provider, {
    value: () => {
      return document.querySelector("#modalContainer");
    }
  }, /*#__PURE__*/React__default.createElement(GlobalStyles, null), /*#__PURE__*/React__default.createElement(GlobalModalStyles, null), /*#__PURE__*/React__default.createElement(TooltipProvider, null, /*#__PURE__*/React__default.createElement("div", {
    id: "modalContainer",
    style: {
      position: "fixed",
      left: 0,
      top: 0,
      zIndex: 100000
    }
  }), /*#__PURE__*/React__default.createElement(Editor, {
    config: props.config,
    locale: editorSearchParams.locale ?? undefined,
    readOnly: editorSearchParams.readOnly ?? true,
    documentId: editorSearchParams.documentId,
    rootComponentId: editorSearchParams.rootComponentId ?? null,
    rootTemplateId: editorSearchParams.rootTemplateId,
    externalData: props.externalData,
    onExternalDataChange: props.onExternalDataChange,
    widgets: {
      ...builtinWidgets,
      ...props.widgets
    },
    components: props.components,
    pickers: {
      ...builinPickers,
      ...props.pickers
    }
  })), /*#__PURE__*/React__default.createElement(Toaster, {
    containerStyle: {
      zIndex: 100100
    }
  })));
}

function CanvasRoot(props) {
  const editorContext = window.parent.editorWindowAPI?.editorContext;
  if (!editorContext) {
    throw new Error("editorContext is not available.");
  }
  useEditorGlobalKeyboardShortcuts(editorContext);
  return /*#__PURE__*/React__default.createElement("div", {
    onClick: () => {
      if (editorContext.isEditing) {
        editorContext.setFocussedField([]);
      }
    }
  }, editorContext.isEditing && /*#__PURE__*/React__default.createElement("div", {
    style: {
      minHeight: "100vh"
    }
  }, /*#__PURE__*/React__default.createElement("style", {
    dangerouslySetInnerHTML: {
      __html: globalEditorRendererStyles
    }
  }), props.children), !editorContext.isEditing && props.children);
}
const globalEditorRendererStyles = `
    /*
        We don't use Tina native blocksmenu and they make page higher than document height (on the last section). So this is quick fix
    */
    [class^=BlocksMenu] {
        display: none !important;
    }
    
    body {
        margin: 0;
        padding: 0;
        overflow-x: hidden;
    }
      
  :root {
    --tina-color-primary-light: #2296fe;
    --tina-color-primary: #2296fe;
    --tina-color-primary-dark: #0574e4;
    --tina-color-error-light: #eb6337;
    --tina-color-error: #ec4815;
    --tina-color-error-dark: #dc4419;
    --tina-color-warning-light: #f5e06e;
    --tina-color-warning: #e9d050;
    --tina-color-warning-dark: #d3ba38;
    --tina-color-success-light: #57c355;
    --tina-color-success: #3cad3a;
    --tina-color-success-dark: #249a21;
    --tina-color-grey-0: #ffffff;
    --tina-color-grey-1: #f6f6f9;
    --tina-color-grey-2: #edecf3;
    --tina-color-grey-3: #e1ddec;
    --tina-color-grey-4: #b2adbe;
    --tina-color-grey-5: #918c9e;
    --tina-color-grey-6: #716c7f;
    --tina-color-grey-7: #565165;
    --tina-color-grey-8: #433e52;
    --tina-color-grey-9: #363145;
    --tina-color-grey-10: #282828;
    --tina-radius-small: 5px;
    --tina-radius-big: 24px;
    --tina-padding-small: 12px;
    --tina-padding-big: 20px;
    --tina-font-size-0: 12px;
    --tina-font-size-1: 13px;
    --tina-font-size-2: 15px;
    --tina-font-size-3: 16px;
    --tina-font-size-4: 18px;
    --tina-font-size-5: 20px;
    --tina-font-size-6: 22px;
    --tina-font-size-7: 26px;
    --tina-font-size-8: 32px;
    --tina-font-family: 'Inter', sans-serif;
    --tina-font-weight-regular: 400;
    --tina-font-weight-bold: 600;
    --tina-shadow-big: 0px 2px 3px rgba(0, 0, 0, 0.05),
      0 4px 12px rgba(0, 0, 0, 0.1);
    --tina-shadow-small: 0px 2px 3px rgba(0, 0, 0, 0.12);
    --tina-timing-short: 85ms;
    --tina-timing-medium: 150ms;
    --tina-timing-long: 250ms;
    --tina-z-index-0: 500;
    --tina-z-index-1: 1000;
    --tina-z-index-2: 1500;
    --tina-z-index-3: 2000;
    --tina-z-index-4: 2500;
    --tina-z-index-5: 3000;
    --tina-sidebar-width: 340px;
    --tina-sidebar-header-height: 60px;
    --tina-toolbar-height: 62px;
    
    
  }
  
  .Shopstory__ReactModal__Overlay {
    width: 100vw;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    
  }
  
  .Shopstory__ReactModal__Overlay::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0.2;
      z-index: -1;
      /* background-color: black; */
  }
  
  .Shopstory__ReactModal__Overlay.background-shade::before {
      background-color: black;
  }
  
  .Shopstory__ReactModal__Content::focus {
    border: none;
    outline: none;
  }
  
  
  .Shopstory__ReactModal__Content__Left {
    height: 100vh;
    width: 70vw;
    
    transition: all 350ms cubic-bezier(0.16, 1, 0.3, 1);
    transform: translateX(-100%);
  }
  
  
  .Shopstory__ReactModal__Content__Left::focus {
    border: none;
    outline: none;
  }
  
  .Shopstory__ReactModal__Content__Left.Shopstory__ReactModal__Content__Left--after-open {
      transform: none;
  }
  
  .Shopstory__ReactModal__Content__Left.Shopstory__ReactModal__Content__Left--before-close{
      transform: translateX(-100%);
  }
`;

function SelectionFrameController(_ref) {
  let {
    isActive,
    isChildrenSelectionDisabled,
    children,
    onSelect,
    stitches,
    sortable,
    id,
    direction,
    path
  } = _ref;
  const [node, setNode] = useState(null);
  useUpdateFramePosition({
    node,
    isDisabled: !isActive
  });
  const isInsertingBefore = sortable.activeIndex > sortable.index;
  const wrapperClassName = stitches.css({
    position: "relative",
    display: "grid",
    "&[data-children-selection-disabled=true] *": {
      pointerEvents: "none !important",
      userSelect: "none !important"
    },
    "&[data-draggable-active=false]::after": {
      content: `''`,
      boxSizing: "border-box",
      display: "block",
      position: "absolute",
      left: 0,
      top: 0,
      width: "100%",
      height: "100%",
      border: "1px solid var(--tina-color-primary)",
      opacity: 0,
      pointerEvents: "none",
      userSelect: "none",
      transition: "all 100ms",
      boxShadow: "var(--tina-shadow-big)",
      zIndex: "var(--tina-z-index-2)"
    },
    "&[data-active=true]::after": {
      opacity: 1
    },
    "&:hover::after": {
      opacity: 0.5
    },
    "&[data-active=true]:hover::after": {
      opacity: 1
    },
    "&[data-draggable-over=true]::before": {
      position: "absolute",
      ...(direction === "horizontal" ? {
        top: 0,
        bottom: 0,
        [isInsertingBefore ? "left" : "right"]: "0px",
        height: "100%",
        width: "4px"
      } : {
        left: 0,
        right: 0,
        [isInsertingBefore ? "top" : "bottom"]: "0px",
        width: "100%",
        height: "4px"
      }),
      display: "block",
      content: "''",
      backgroundColor: Colors.blue50,
      zIndex: 9999999
    },
    "&[data-draggable-active=true]": {
      opacity: 0.5
    },
    "&[data-draggable-dragging=true]": {
      cursor: "grabbing"
    }
  });
  useEffect(() => {
    return () => {
      // If the the node of active element is not in the DOM anymore we want to deselect it to prevent showing
      // add buttons on the not existing element.
      if (isActive && node && !window.document.contains(node) && path === window.parent.editorWindowAPI?.editorContext?.focussedField[0]) {
        window.parent.editorWindowAPI.editorContext.setFocussedField([]);
      }
    };
  });
  return /*#__PURE__*/React__default.createElement("div", _extends({
    "data-active": isActive,
    "data-children-selection-disabled": isChildrenSelectionDisabled,
    "data-draggable-dragging": sortable.active !== null,
    "data-draggable-over": sortable.isOver,
    "data-draggable-active": sortable.active !== null && sortable.active?.id === id,
    className: wrapperClassName().className,
    ref: node => {
      setNode(node);
      sortable.setNodeRef(node);
    },
    onClick: onSelect
  }, sortable.attributes, sortable.listeners), children);
}
function useUpdateFramePosition(_ref2) {
  let {
    node,
    isDisabled
  } = _ref2;
  const dispatch = window.parent.postMessage;
  useEffect(() => {
    if (isDisabled || !node) {
      return;
    }
    const updateSelectionFramePosition = createThrottledHandler(() => {
      const nodeRect = node.getBoundingClientRect();
      dispatch(selectionFramePositionChanged(nodeRect, window.document.documentElement.getBoundingClientRect()));
    });
    window.addEventListener("scroll", updateSelectionFramePosition, {
      passive: true
    });
    const handleResize = createThrottledHandler(() => {
      const nodeRect = node.getBoundingClientRect();
      dispatch(selectionFramePositionChanged(nodeRect));
    });
    window.addEventListener("resize", handleResize, {
      passive: true
    });
    const updateSelectionFramePositionInScrollableContainer = createThrottledHandler(event => {
      const nodeRect = node.getBoundingClientRect();
      const containerRect = event.target.getBoundingClientRect();
      dispatch(selectionFramePositionChanged(nodeRect, containerRect));
    });
    const closestScrollableElement = node.closest("[data-easyblocks-scrollable-root]");
    closestScrollableElement?.addEventListener("scroll", updateSelectionFramePositionInScrollableContainer, {
      passive: true
    });
    dispatch(selectionFramePositionChanged(node.getBoundingClientRect(), closestScrollableElement?.getBoundingClientRect()));
    return () => {
      window.removeEventListener("scroll", updateSelectionFramePosition);
      window.removeEventListener("resize", handleResize);
      closestScrollableElement?.removeEventListener("scroll", updateSelectionFramePositionInScrollableContainer);
    };
  });
}

/**
 * https://developer.mozilla.org/en-US/docs/Web/API/Element/scroll_event#scroll_event_throttling
 */
function createThrottledHandler(callback) {
  let isTicking = false;
  return event => {
    if (isTicking) {
      return;
    }
    requestAnimationFrame(() => {
      callback(event);
      isTicking = false;
    });
    isTicking = true;
  };
}

function BlocksControls(_ref) {
  let {
    children,
    path,
    disabled,
    direction,
    id,
    index,
    length
  } = _ref;
  const {
    focussedField,
    setFocussedField,
    form
  } = window.parent.editorWindowAPI?.editorContext;
  const meta = useEasyblocksMetadata();
  const dndContext = useDndContext();
  const isActive = focussedField.map(focusedField => {
    // If the focused field is rich text part path, we want to show the frame around rich text parent component.
    if (isConfigPathRichTextPart(focusedField)) {
      return focusedField.replace(RICH_TEXT_PART_CONFIG_PATH_REGEXP, "");
    }
    return focusedField;
  }).includes(path);
  const isChildComponentActive = focussedField.some(focusedField => focusedField.startsWith(path));
  const entryPathParseResult = parsePath(path, form);
  const entryComponentDefinition = meta.vars.definitions.components.find(c => c.id === entryPathParseResult.parent.templateId);

  // component` could be draggable, but right now we only support collections.
  const isEntryComponentOrComponentFixed = entryComponentDefinition.schema.some(s => s.prop === entryPathParseResult.parent.fieldName && s.type === "component");
  const isAncestorComponentActive = focussedField.some(f => entryPathParseResult.parent.path.startsWith(f));
  const isMultiSelection = focussedField.length > 1;
  const isSiblingComponentActive = focussedField.some(f => {
    const pathWithoutIndexPart = path.split(".").slice(0, -1).join(".");
    const regexp = new RegExp(`^${pathWithoutIndexPart}\\.\\d+$`);
    return regexp.test(f);
  });
  const draggedEntryPathParseResult = dndContext.active ? parsePath(dndContext.active.data.current.path, form) : null;
  const draggedComponentDefinition = draggedEntryPathParseResult ? meta.vars.definitions.components.find(c => c.id === draggedEntryPathParseResult.templateId) : null;
  const canDraggedComponentBeDropped = entryComponentDefinition && draggedComponentDefinition ? getAllowedComponentTypes(entryComponentDefinition).some(type => {
    return toArray(draggedComponentDefinition.type ?? []).includes(type) || draggedComponentDefinition.id === type;
  }) : true;
  const isDroppableDisabled = disabled || isEntryComponentOrComponentFixed || !canDraggedComponentBeDropped;
  const sortable = useSortable({
    id,
    data: {
      path
    },
    disabled: {
      draggable: disabled || isMultiSelection || isEntryComponentOrComponentFixed || !isActive && !isAncestorComponentActive && !isSiblingComponentActive && !isChildComponentActive,
      droppable: isDroppableDisabled
    },
    strategy: direction === "horizontal" ? horizontalListSortingStrategy : verticalListSortingStrategy
  });
  if (disabled) {
    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, children);
  }
  const focusOnBlock = event => {
    event.stopPropagation();
    if (isActive) {
      return;
    } else {
      event.preventDefault();
    }
    const closestEditableElementFromTarget = event.target.closest('[contenteditable="true"]');
    const isActiveElementContentEditable = document.activeElement?.getAttribute("contenteditable") === "true";

    // If target of event is within a content editable element we don't want to focus block.
    // If active element is a content editable element, we also don't want to focus block.
    // The latter is helpful when we start text selection within the content editable element
    // and end selection outside of anchor element.
    if (closestEditableElementFromTarget || isActiveElementContentEditable) {
      return;
    }
    const isMultipleSelection = event.shiftKey;
    function getNextFocusedField() {
      if (isMultipleSelection) {
        if (focussedField.includes(path)) {
          const result = focussedField.filter(fieldName => fieldName !== path);
          if (result.length > 0) {
            return result;
          }
          return [];
        }
        return [...focussedField, path];
      }
      return path;
    }
    const nextFocusedField = getNextFocusedField();
    setFocussedField(nextFocusedField);
    if (isMultipleSelection) {
      document.getSelection()?.removeAllRanges();
    }
  };
  const isActivePathInDifferentCollection = sortable.active && !isPathsParentEqual(sortable.active.data.current.path, path);
  return /*#__PURE__*/React__default.createElement(Fragment, null, !isDroppableDisabled && isActivePathInDifferentCollection && sortable.activeIndex < sortable.index && index === 0 && /*#__PURE__*/React__default.createElement(DroppablePlaceholder, {
    id: id,
    direction: direction,
    path: path,
    position: "before"
  }), /*#__PURE__*/React__default.createElement(SelectionFrameController, {
    isActive: isActive,
    isChildrenSelectionDisabled: !isActive && !isChildComponentActive,
    onSelect: focusOnBlock,
    stitches: meta.stitches,
    sortable: sortable,
    id: id,
    direction: direction,
    path: path
  }, children), !isDroppableDisabled && isActivePathInDifferentCollection && sortable.activeIndex > sortable.index && index === length - 1 && /*#__PURE__*/React__default.createElement(DroppablePlaceholder, {
    id: id,
    direction: direction,
    path: path,
    position: "after"
  }));
}
function getAllowedComponentTypes(componentDefinition) {
  const collectionSchemaProps = componentDefinition.schema.filter(s => s.type === "component-collection");
  const allowedComponentTypes = collectionSchemaProps.flatMap(s => s.accepts);
  return Array.from(new Set(allowedComponentTypes));
}
function isPathsParentEqual(path1, path2) {
  const activePathParts = path1.split(".");
  const currentPathParts = path2.split(".");
  return activePathParts.slice(0, -1).join(".") === currentPathParts.slice(0, -1).join(".");
}
function DroppablePlaceholder(_ref2) {
  let {
    id,
    direction,
    path,
    position
  } = _ref2;
  const meta = useEasyblocksMetadata();
  const sortable = useSortable({
    id: `${id}.${position}`,
    data: {
      path
    },
    disabled: {
      draggable: true,
      droppable: false
    }
  });
  const isInsertingBefore = sortable.activeIndex > sortable.index;
  const wrapperStyles = meta.stitches.css({
    position: "absolute",
    [position === "before" ? "top" : "bottom"]: direction === "vertical" ? "-100%" : 0,
    [position === "before" ? "left" : "right"]: direction === "horizontal" ? "-100%" : 0,
    height: "100%",
    background: "transparent",
    width: "100%",
    "&::before": {
      display: "block",
      content: "''",
      backgroundColor: Colors.blue50,
      zIndex: 9999999,
      position: "absolute",
      opacity: 0
    },
    "&[data-draggable-over=true]::before": {
      opacity: 1,
      ...(direction === "horizontal" ? {
        top: 0,
        bottom: 0,
        [isInsertingBefore ? "left" : "right"]: "0px",
        height: "100%",
        width: "4px"
      } : {
        left: 0,
        right: 0,
        [isInsertingBefore ? "top" : "bottom"]: "0px",
        width: "100%",
        height: "4px"
      })
    }
  });
  return /*#__PURE__*/React__default.createElement("div", _extends({
    "data-draggable-over": sortable.isOver,
    className: wrapperStyles().className,
    ref: sortable.setNodeRef
  }, sortable.attributes, sortable.listeners));
}

function EditableComponentBuilder(props) {
  const {
    path,
    compiled,
    index,
    length,
    components,
    ...restPassedProps
  } = props;
  const content = /*#__PURE__*/React__default.createElement(BlocksControls, {
    path: path,
    id: compiled._id,
    templateId: compiled._component,
    disabled: compiled.__editing?.noInline,
    direction: compiled.__editing?.direction ?? "vertical",
    compiled: compiled,
    index: index,
    length: length
  }, /*#__PURE__*/React__default.createElement(ComponentBuilder, {
    compiled: compiled,
    path: path,
    passedProps: restPassedProps,
    components: components
  }));
  return content;
}

function Placeholder(props) {
  const {
    stitches
  } = useEasyblocksMetadata();
  const styles = {};
  const {
    aspectRatio,
    width,
    height,
    label
  } = props.appearance;
  if (height) {
    styles.height = `${height}px`;
  } else if (aspectRatio) {
    styles.paddingBottom = `${1 / aspectRatio * 100}%`;
  }
  const rootClassName = stitches.css({
    border: `1px dashed ${Colors.blue50}`,
    position: "relative",
    width: `${width ? `${width}px` : "auto"}`,
    height: "auto",
    transition: "all 0.1s"
  });
  const contentClassName = stitches.css({
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    display: "flex",
    color: Colors.blue50,
    justifyContent: "center",
    alignItems: "center",
    cursor: "pointer",
    ...Fonts.body,
    "&:hover": {
      backgroundColor: Colors.blue10
    },
    "&[data-draggable-over=true]": {
      backgroundColor: Colors.blue10
    },
    "&[data-draggable-dragging=true]": {
      cursor: "grabbing"
    }
  });
  const content = /*#__PURE__*/React__default.createElement("div", {
    className: contentClassName(),
    onClick: event => {
      event.stopPropagation();
      props.onClick();
    },
    "data-draggable-over": props.sortable.isOver,
    "data-draggable-dragging": props.sortable.active !== null
  }, /*#__PURE__*/React__default.createElement("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    style: {
      color: Colors.blue50
    }
  }, /*#__PURE__*/React__default.createElement("path", {
    d: "M8 2.75C8 2.47386 7.77614 2.25 7.5 2.25C7.22386 2.25 7 2.47386 7 2.75V7H2.75C2.47386 7 2.25 7.22386 2.25 7.5C2.25 7.77614 2.47386 8 2.75 8H7V12.25C7 12.5261 7.22386 12.75 7.5 12.75C7.77614 12.75 8 12.5261 8 12.25V8H12.25C12.5261 8 12.75 7.77614 12.75 7.5C12.75 7.22386 12.5261 7 12.25 7H8V2.75Z",
    fill: "currentColor",
    fillRule: "evenodd",
    clipRule: "evenodd"
  })), label && /*#__PURE__*/React__default.createElement("span", null, "\xA0\xA0", label));
  return /*#__PURE__*/React__default.createElement("div", _extends({
    className: rootClassName(),
    ref: props.sortable.setDroppableNodeRef
  }, props.sortable.attributes, props.sortable.listeners), /*#__PURE__*/React__default.createElement("div", {
    style: {
      position: "relative",
      width: "100%",
      ...styles
    }
  }), content);
}
function TypePlaceholder(props) {
  const {
    form
  } = window.parent.editorWindowAPI?.editorContext || {};
  const meta = useEasyblocksMetadata();
  const dndContext = useDndContext();
  const draggedEntryPathParseResult = dndContext.active ? parsePath(dndContext.active.data.current.path, form) : null;
  const draggedComponentDefinition = draggedEntryPathParseResult ? meta.vars.definitions.components.find(c => c.id === draggedEntryPathParseResult.templateId) : null;
  const canDraggedComponentBeDropped = draggedComponentDefinition ? toArray(draggedComponentDefinition.type ?? []).includes(props.type) : true;
  const sortable = useSortable({
    id: `placeholder.${props.id}`,
    data: {
      path: props.path
    },
    disabled: {
      draggable: true,
      droppable: !canDraggedComponentBeDropped
    }
  });
  const {
    type
  } = props;
  let appearance;
  if (props.appearance) {
    appearance = props.appearance;
  } else {
    if (type === "section") {
      appearance = {
        label: "Add section",
        aspectRatio: 3.2
      };
    } else if (type === "card") {
      appearance = {
        label: "Add card",
        aspectRatio: 0.7
      };
    } else if (type === "button") {
      appearance = {
        label: "Add button",
        width: 250,
        height: 50
      };
    } else if (type === "item") {
      appearance = {
        label: "Add item",
        // width: 250,
        height: 50
      };
    } else if (type === "image") {
      appearance = {
        label: "Add image",
        aspectRatio: 1
      };
    } else if (type === "icon") {
      appearance = {
        label: "Pick icon",
        width: 50,
        height: 50
      };
    } else {
      appearance = {
        label: "Add",
        width: 50,
        aspectRatio: 1
      };
    }
  }
  return /*#__PURE__*/React__default.createElement(Placeholder, {
    appearance: appearance,
    onClick: props.onClick,
    meta: props.meta,
    sortable: sortable
  });
}

const dragDataSchema = z$2.object({
  path: z$2.string(),
  sortable: z$2.object({
    index: z$2.number()
  })
});
function customCollisionDetection(args) {
  // First, let's see if there are any collisions with the pointer
  const pointerCollisions = pointerWithin(args);

  // Collision detection algorithms return an array of collisions
  if (pointerCollisions.length > 0) {
    return pointerCollisions;
  }

  // If there are no collisions with the pointer, return rectangle intersections
  return rectIntersection(args);
}
function EasyblocksCanvas(_ref) {
  let {
    components
  } = _ref;
  const {
    meta,
    compiled,
    externalData,
    editorContext
  } = window.parent.editorWindowAPI;
  const [enabled, setEnabled] = useState(false);
  const activeDraggedEntryPath = useRef(null);
  const {
    forceRerender
  } = useForceRerender();
  const mouseSensor = useSensor(MouseSensor, {
    activationConstraint: {
      distance: 10
    }
  });
  useEffect(() => {
    if (window.self === window.top) {
      throw new Error("No host");
    } else {
      setEnabled(true);
    }
  }, []);
  useEffect(() => {
    if (window.parent && window.parent.editorWindowAPI) {
      window.parent.editorWindowAPI.onUpdate = () => {
        // Force re-render when child gets info from parent that data changed
        forceRerender();
      };
    }
  });
  const shouldNotRender = !enabled || !meta || !compiled || !externalData;
  if (shouldNotRender) {
    return /*#__PURE__*/React__default.createElement("div", null, "Loading...");
  }
  const sortableItems = getSortableItems(editorContext.form.values, editorContext);
  return /*#__PURE__*/ /* EasyblocksMetadataProvider must be defined in case of nested <Easyblocks /> components are used! */React__default.createElement(EasyblocksMetadataProvider, {
    meta: meta
  }, /*#__PURE__*/React__default.createElement(CanvasRoot, null, /*#__PURE__*/React__default.createElement(DndContext, {
    sensors: [mouseSensor],
    collisionDetection: customCollisionDetection,
    onDragStart: event => {
      document.documentElement.style.cursor = "grabbing";
      activeDraggedEntryPath.current = dragDataSchema.parse(event.active.data.current).path;
      window.parent.editorWindowAPI?.editorContext?.setFocussedField([]);
    },
    onDragEnd: event => {
      document.documentElement.style.cursor = "";
      const activeData = dragDataSchema.parse(event.active.data.current);
      if (event.over) {
        const overData = dragDataSchema.parse(event.over.data.current);
        if (event.over.id === event.active.id) {
          // If the dragged item is dropped on itself, we want to refocus the dragged item.
          window.parent.editorWindowAPI?.editorContext?.setFocussedField(activeData.path);
        } else {
          const itemMovedEvent = itemMoved({
            fromPath: activeData.path,
            toPath: overData.path,
            placement: ifValidPlacement(event.over.id.toString().split(".")[1])
          });
          requestAnimationFrame(() => {
            window.parent.postMessage(itemMovedEvent);
          });
        }
      } else {
        // If there was no drop target, we want to refocus the dragged item.
        window.parent.editorWindowAPI?.editorContext?.setFocussedField(activeData.path);
      }
    },
    onDragCancel: event => {
      document.documentElement.style.cursor = "";
      // If the drag was canceled, we want to refocus dragged item.
      window.parent.editorWindowAPI?.editorContext?.setFocussedField(dragDataSchema.parse(event.active.data.current).path);
    }
  }, /*#__PURE__*/React__default.createElement(SortableContext, {
    items: sortableItems
  }, /*#__PURE__*/React__default.createElement(Easyblocks, {
    renderableDocument: {
      renderableContent: compiled,
      meta
    },
    externalData: externalData,
    components: {
      ...components,
      "@easyblocks/rich-text.editor": RichTextEditor,
      "@easyblocks/text.editor": TextEditor,
      "EditableComponentBuilder.editor": EditableComponentBuilder,
      Placeholder: TypePlaceholder
    }
  })))));
}
function getSortableItems(rootNoCodeEntry, editorContext) {
  const sortableItems = [];
  configTraverse(rootNoCodeEntry, editorContext, _ref2 => {
    let {
      value,
      schemaProp,
      config
    } = _ref2;
    if (schemaProp.type === "component-collection") {
      if (value.length === 0) {
        sortableItems.push(`placeholder.${config._id}`);
        return;
      }
      sortableItems.push(`${value[0]._id}.before`);
      sortableItems.push(...value.map(v => v._id));
      sortableItems.push(`${value.at(-1)._id}.after`);
    }
  });
  return sortableItems;
}
function ifValidPlacement(value) {
  if (value === "before" || value === "after") {
    return value;
  }
  return;
}

const PreviewRenderer = props => {
  const config = props.config;
  const [data, setData] = useState(null);
  const [width, setWidth] = useState(-1);
  const [widthAuto, setWidthAuto] = useState(false);
  useEffect(() => {
    const {
      documentId,
      templateId,
      locale
    } = parseQueryParams();
    let mode;
    if (documentId && templateId) {
      console.warn(`'template' parameter ignored because 'document' parameter is specified`);
      mode = "document";
    } else if (!documentId && templateId) {
      mode = "template";
    } else if (documentId && !templateId) {
      mode = "document";
    } else {
      throw new Error("You must specify 'document' or 'template' parameter in preview mode");
    }
    const localeWithDefault = locale ?? getDefaultLocale$1(config.locales ?? []).code;
    (async () => {
      const {
        buildDocument,
        buildEntry
      } = await import('@redsun-vn/easyblocks-core');
      if (mode === "document") {
        const {
          renderableDocument,
          externalData
        } = await buildDocument({
          documentId: documentId,
          config,
          locale: localeWithDefault
        });
        props.onExternalDataChange?.(externalData, {
          locale: localeWithDefault
        });
        setData({
          renderableDocument,
          externalData
        });
      } else {
        const template = await config.backend.templates.get({
          id: templateId
        });
        const {
          renderableContent,
          meta,
          externalData
        } = buildEntry({
          entry: {
            ...template.entry,
            _itemProps: {}
          },
          config,
          locale: localeWithDefault
        });
        props.onExternalDataChange?.(externalData, {
          locale: localeWithDefault
        });
        setWidth(template.width ?? -1);
        setWidthAuto(template.widthAuto ?? false);
        setData({
          renderableDocument: {
            renderableContent,
            meta: serialize(meta)
          },
          externalData
        });
      }
    })();
  }, []);
  if (!data) {
    return null;
  }
  const requestedExternalDataLength = Object.keys(data.externalData).length;
  const givenExternalDataLength = Object.keys(props.externalData ?? {}).length;
  if (requestedExternalDataLength !== givenExternalDataLength) {
    return null;
  }
  return /*#__PURE__*/React__default.createElement("div", {
    style: {
      position: "relative",
      display: widthAuto ? "inline-flex" : "block",
      maxWidth: width === -1 ? "auto" : `${width}px`
    },
    id: "__easyblocks-preview-container"
  }, /*#__PURE__*/React__default.createElement(Easyblocks, {
    renderableDocument: data.renderableDocument,
    externalData: props.externalData,
    components: props.components
  }));
};

const validate = value => {
  return typeof value === "string" && (value.startsWith("http://") || value.startsWith("https://"));
};
const debugTypes = {
  debug_url_inline_never: {
    type: "inline",
    defaultValue: "https://google.com",
    responsiveness: "never",
    widget: {
      id: "debug_url",
      label: "Debug URL"
    },
    validate
  },
  debug_url_inline_optional: {
    type: "inline",
    defaultValue: "https://google.com",
    responsiveness: "optional",
    widget: {
      id: "debug_url",
      label: "Debug URL"
    },
    validate
  },
  debug_url_inline_always: {
    type: "inline",
    defaultValue: "https://google.com",
    responsiveness: "always",
    widget: {
      id: "debug_url",
      label: "Debug URL"
    },
    validate
  },
  debug_url_token_never: {
    type: "token",
    token: "debug_urls",
    responsiveness: "never",
    defaultValue: {
      tokenId: "google"
    },
    widget: {
      id: "debug_url",
      label: "Debug URL"
    },
    allowCustom: false,
    validate
  },
  debug_url_token_optional_no_custom: {
    type: "token",
    token: "debug_urls",
    responsiveness: "optional",
    defaultValue: {
      tokenId: "google"
    },
    widget: {
      id: "debug_url",
      label: "Debug URL"
    },
    allowCustom: false,
    validate
  },
  debug_url_token_optional_custom: {
    type: "token",
    token: "debug_urls",
    responsiveness: "optional",
    defaultValue: {
      tokenId: "google"
    },
    widget: {
      id: "debug_url",
      label: "Debug URL"
    },
    allowCustom: true,
    validate
  },
  debug_url_token_always_no_custom: {
    type: "token",
    token: "debug_urls",
    responsiveness: "always",
    defaultValue: {
      tokenId: "google"
    },
    widget: {
      id: "debug_url",
      label: "Debug URL"
    },
    allowCustom: false,
    validate
  },
  debug_url_token_always_custom: {
    type: "token",
    token: "debug_urls",
    responsiveness: "always",
    defaultValue: {
      tokenId: "google"
    },
    widget: {
      id: "debug_url",
      label: "Debug URL"
    },
    allowCustom: true,
    validate
  }
};

const debugSectionDefinition = {
  id: "DebugSection",
  schema: [{
    prop: "inline_never",
    label: "Never",
    type: "debug_url_inline_never",
    group: "Inline"
  }, {
    prop: "inline_optional_disabled",
    label: "Optional (off)",
    type: "debug_url_inline_optional",
    responsive: false,
    group: "Inline"
  }, {
    prop: "inline_optional_enabled",
    label: "Optional (on)",
    type: "debug_url_inline_optional",
    responsive: true,
    group: "Inline"
  }, {
    prop: "inline_always",
    label: "Always",
    type: "debug_url_inline_always",
    group: "Inline"
  }, {
    prop: "token_never",
    label: "Never",
    type: "debug_url_token_never",
    group: "Token - custom"
  }, {
    prop: "token_optional_disabled_custom",
    label: "Optional (off)",
    type: "debug_url_token_optional_custom",
    responsive: false,
    group: "Token - custom"
  }, {
    prop: "token_optional_enabled_custom",
    label: "Optional (on)",
    type: "debug_url_token_optional_custom",
    responsive: true,
    group: "Token - custom"
  }, {
    prop: "token_always_custom",
    label: "Always",
    type: "debug_url_token_always_custom",
    group: "Token - custom"
  }, {
    prop: "token_optional_disabled_no_custom",
    label: "Optional (off)",
    type: "debug_url_token_optional_no_custom",
    responsive: false,
    group: "Token - no custom"
  }, {
    prop: "token_optional_enabled_no_custom",
    label: "Optional (on)",
    type: "debug_url_token_optional_no_custom",
    responsive: true,
    group: "Token - no custom"
  }, {
    prop: "token_always_no_custom",
    label: "Always",
    type: "debug_url_token_always_no_custom",
    group: "Token - no custom"
  }],
  type: "section"
};

const debugTokens = {
  debug_urls: [{
    id: "google",
    value: "https://google.com"
  }, {
    id: "bing",
    value: "https://bing.com"
  }]
};

function DebugSection(_ref) {
  let {
    inline_never,
    inline_optional_disabled,
    inline_optional_enabled,
    inline_always,
    token_never,
    token_optional_disabled_no_custom,
    token_optional_enabled_no_custom,
    token_optional_disabled_custom,
    token_optional_enabled_custom,
    token_always_no_custom,
    token_always_custom
  } = _ref;
  return /*#__PURE__*/React__default.createElement("div", null, /*#__PURE__*/React__default.createElement("pre", null, JSON.stringify({
    inline_never,
    inline_optional_disabled,
    inline_optional_enabled,
    inline_always,
    token_never,
    token_optional_disabled_no_custom,
    token_optional_enabled_no_custom,
    token_optional_disabled_custom,
    token_optional_enabled_custom,
    token_always_no_custom,
    token_always_custom
  }, null, 2)));
}

function DebugUrlWidget(props) {
  const [active, setActive] = useState(false);
  const [value, setValue] = useState(props.value);
  useEffect(() => {
    if (!active) {
      setValue(props.value);
    }
  });
  return /*#__PURE__*/React__default.createElement(Input, {
    value: value,
    onChange: event => {
      setActive(true);
      setValue(event.target.value);
    },
    onBlur: () => {
      setActive(false);
      props.onChange(value);
    },
    align: "right"
  });
}

function addDebugToEditorProps(props) {
  return {
    ...props,
    config: {
      ...props.config,
      types: {
        ...props.config.types,
        ...debugTypes
      },
      components: [...(props.config.components ?? []), debugSectionDefinition],
      tokens: {
        ...props.config.tokens,
        ...debugTokens
      }
    },
    components: {
      ...props.components,
      DebugSection
    },
    widgets: {
      ...props.widgets,
      debug_url: DebugUrlWidget
    }
  };
}

// Extend the Window interface to include isShopstoryEditor

function EasyblocksEditor(props) {
  const [selectedWindow, setSelectedWindow] = useState(null);
  const setSelectedWindowToParent = () => {
    window.isShopstoryEditor = true;
    setSelectedWindow("parent");
  };
  useEffect(() => {
    if (parseQueryParams().preview) {
      setSelectedWindow("preview");
      return;
    }
    const setSelectedWindowToChild = () => {
      setSelectedWindow("child");
    };
    if (selectedWindow === null) {
      /**
       * Why try catch?
       *
       * It's because window.parent.isShopstoryEditor might throw if window.parent is cross origin (when shopstory Launcher is run in iframe of CMS - like Contentful); In that case we're sure it's a parent window, not a child.
       */
      try {
        // Parent window is always rendered first so `window.isShopstoryEditor` will always be set when <iframe /> with child is loading
        if (window.parent !== window.self && window.parent.isShopstoryEditor) {
          setSelectedWindowToChild();
        } else {
          setSelectedWindowToParent();
        }
      } catch (error) {
        setSelectedWindowToParent();
      }
    }
  }, []);
  if (!selectedWindow) {
    return null;
  }
  if (parseQueryParams().debug) {
    props = addDebugToEditorProps(props);
  }
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, selectedWindow === "parent" && /*#__PURE__*/React__default.createElement(EasyblocksParent, {
    config: props.config,
    externalData: props.externalData ?? {},
    onExternalDataChange: props.onExternalDataChange ?? (() => ({})),
    widgets: props.widgets,
    components: props.components,
    pickers: props.pickers
  }), selectedWindow === "child" && /*#__PURE__*/React__default.createElement(EasyblocksCanvas, {
    components: props.components
  }), selectedWindow === "preview" && /*#__PURE__*/React__default.createElement(PreviewRenderer, props));
}

export { EasyblocksEditor, useEditorContext };
